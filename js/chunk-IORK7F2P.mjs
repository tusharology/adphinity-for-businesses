import{$c as Nd,Ae as yt,Be as qn,Ce as dr,De as Md,Ee as Mt,Ie as Vt,Ke as Vd,Le as Hn,Ta as $a,Uc as fd,Vd as Dd,Xc as te,Yc as jn,Zc as Id,_c as wd,ad as ii,cd as Rd,hb as qa,qe as Ed,re as Ld,ue as $n,wb as Mn,we as kd,xe as zr,ye as Pd}from"chunk-TO3PG6NS.mjs";import{$a as Bn,A as Ka,B as An,Ga as rd,I as ri,M as ni,Ma as nd,N as Qa,Na as od,Oa as id,Pa as On,Ra as sd,Ya as ad,Za as dd,ba as Za,ga as oi,ia as ed,la as Fn,o as Wa,ra as Un,sa as td,ua as je}from"chunk-UZULDITV.mjs";import{m as Ha}from"chunk-DHVIQMT5.mjs";import{c as Td}from"chunk-PW3UNOS6.mjs";import{a as vd,b as bd,c as Sd,d as Cd}from"chunk-V74VFLF3.mjs";import{a as pd,b as _n,c as hd,d as zn,e as gd,f as yd}from"chunk-2WLJEEWM.mjs";import{a as md,d as ge}from"chunk-JSNDXE3K.mjs";import{b as _r}from"chunk-YQXRHNKK.mjs";import{a as Ja,g as gt,j as Ga}from"chunk-5QQ5KTFK.mjs";import{L as ja}from"chunk-VHBQVA4D.mjs";import{b as xd}from"chunk-ID3FOPOK.mjs";import{b as Ad,c as Fd,d as Ud,e as Od}from"chunk-EIICATV4.mjs";import{e as Wn}from"chunk-K2O2DWCZ.mjs";import{m as cd,n as ld,o as ud}from"chunk-WPFEDOJI.mjs";import{$h as za,Af as xa,Ah as ei,Bh as sr,Cb as Qo,Cc as Ta,Ch as Pe,Dc as Ia,Dh as Oa,Eh as Ba,Fh as ht,Gh as Br,Hh as _a,Kh as ar,Lh as ti,Mg as La,Ng as En,Q as tr,Rd as Na,Sc as wa,Sf as Da,U as Te,V as ea,W as ta,Xh as Ln,Z as ra,Za as va,_a as Ko,ab as ba,ac as Yo,cb as Sa,eb as Ca,fg as Ea,ih as ka,jh as Or,kh as Pa,mh as Ma,nh as pt,ni as kn,ph as Va,qc as Dn,uh as Aa,va as ia,vh as Fa,wh as Ua,xh as ir,yh as Xo,zf as Ra,zh as Zo}from"chunk-NYFEUS7P.mjs";import{f as ke}from"chunk-6Z2W7ESM.mjs";import{f as tt}from"chunk-75ILXMIH.mjs";import{Ue as Pn}from"chunk-BMVMSSVG.mjs";import{g as Ya,j as Xa}from"chunk-7O66E2IQ.mjs";import{Ah as sa,Cb as et,Ee as Fr,Ge as Ur,Gl as mt,Hl as Nn,Il as nr,Je as Ho,Jl as or,Jn as ga,Kl as Rn,Le as Jo,Lf as kt,Of as Xs,Pe as Qs,Qe as Ys,Qf as Zs,Qg as na,Yg as Go,_h as aa,ac as qs,b as bs,bl as S,el as Cn,gc as Ws,gg as ze,gh as oa,hl as Tn,il as In,jd as Gs,kl as ma,ld as Ks,lj as la,mc as Hs,nc as Wo,oc as Js,pc as Sn,ro as ya,ul as pa,wi as da,zi as ca}from"chunk-G5CI4O4F.mjs";import{b as js}from"chunk-SOM3QFWS.mjs";import{a as Vn}from"chunk-R32HLP7P.mjs";import{$n as Us,Ad as _o,As as wn,Bj as Es,Fm as Ms,Jj as Ls,Jr as qo,Kn as As,L as hn,Qh as Rs,Qn as Fs,Rn as jo,Sn as $o,Tc as Xt,Tg as Is,Ti as _,Ui as I,Vi as xs,Wd as er,Wg as ws,Wi as $,Xc as lt,Xd as ys,Xp as zs,Yi as A,Zc as Zt,Zg as Ns,Zi as p,_i as Be,_q as ft,aj as _e,dd as Et,dt as ua,ed as bn,ek as zo,hc as ms,ht as rr,it as fa,jp as Bs,kd as hs,ld as Le,lp as _s,mc as vn,md as de,nc as ps,nd as me,od as M,pb as yn,pf as Ss,qd as pe,qf as Cs,rd as he,sd as gs,tb as fs,ug as Ts,ul as Ps,vd as ut,vn as Vs,vs as Pt,we as Lt,wt as ha,xb as Bo,xe as vs,xj as Ds,xk as ks,yt as xn,zd as ee,zr as $s}from"chunk-LIUGL3AW.mjs";import{$ as Os,V as us,y as ls}from"chunk-RT6MD2HE.mjs";import{a as ct}from"chunk-B7SOVHNX.mjs";import{p as Yt}from"chunk-OBUCKN56.mjs";import{b as Z,e as B,g as Oo,j as U,m as Ar}from"chunk-CMAEAGWD.mjs";import{a as Uo,b as gn}from"chunk-JB2N3EQZ.mjs";import{g as dt}from"chunk-4X7KIAE7.mjs";import{c as cs}from"chunk-6E4TUQ3S.mjs";import{$ as ds,Ja as Ce,Ra as Qt,Ta as mn,Va as K,W as as,X as Gt,Xa as pn,Y as Kt,Z as Mr,da as x,f as ss,ma as Vr,na as fn,ra as Q,ta as Oe,ua as Ee}from"chunk-EEV263O3.mjs";import{a as m,b as ae}from"chunk-YOOGIIWU.mjs";import{e as Dt,j as f,k as T,l as X,m as Ze,n as is}from"chunk-AHQIRSXG.mjs";var Sl=x("DocumentLoader"),si=x("remote:verify"),Jn=class o{constructor(t,e,r){this.componentLoader=t;this.parser=e;this.settings=r;f(this,"canvasTreeVersion",0);f(this,"chunkingHints");this.canvasTreeVersion=this.parser.version,this.chunkingHints=this.parser.getChunkingHints()}static async createPartialParser(t,e,r){if(typeof t=="string"){let n=new Sd(t);return new o(e,n,r)}else{let n=new Cd(t);return new o(e,n,r)}}readFirstPage(){let t=!1,e=[];if(this.settings.activeNodeId&&(e.push(...this.parser.getPagesContainingId(this.settings.activeNodeId)),t=e.some(r=>je(this.parser.getShallowPage(r)))),!t){let r=this.parser.getShallowPages(),{maybeFirstPage:n}=Un(r,this.parser.getHomePageNodeID());e.push(n.id);let i=0,s;for(let a of r){if(M(a,!0)&&i++,i>1)break;pe(a,!0)&&(s??=a.id)}i===1&&s&&s!==n.id&&e.push(s)}return Sl.debug("loadPartialDocument():",e),yd(this.parser,this.componentLoader,e,this.settings.treeServices)}getScopesToLoad(){return this.parser.getPagesToLoad()}getParsedPageById(t){return this.parser.getParsedPageById(t)}buildPage(t){if(!t)return;let e=[],r=si.isLoggingTraceMessages()?[]:void 0,n=pt(t,this.parser.root.id,{extraChecksAndFixes:!0,errors:e,warnings:r});if(n&&zn(n,e),e.length>0&&si.warn("errors loading server tree: "+e.join(`
`)),r&&r.length>0&&si.trace("warnings loading server tree: "+r.join(`
`)),!!n)return n}};var ai=x("app");function Xm(o){return o.treeReflectsDocument?Cl(o.tree):null}function Cl(o){return o.toJS()}function Zm(o){function t(e){let{__class:r,width:n,height:i,top:s,bottom:a,left:d,right:c}=e,{children:u}=e;return u?(u=u.map(t),{__class:r,width:n,height:i,top:s,bottom:a,left:d,right:c,children:u}):e.styledText?{__class:r,width:n,height:i,top:s,bottom:a,left:d,right:c,text:e.styledText.blocks.map(l=>l.text)}:{__class:r,width:n,height:i,top:s,bottom:a,left:d,right:c}}return t(o.tree.toJS().root)}function ep(o,t){let e,r=new XMLHttpRequest;r.open("GET",o.toString(),!1);try{r.send(),e=JSON.parse(r.responseText)}catch(n){ai.error(`Retrieving document \u201C${o}\u201D failed. (${n})`)}return di(e,t)}function Bd(o){dt.isTest||o.forEach(t=>{ai.warn("[repaired]",t)})}function di(o,t){let e=[];try{let r=_n(o,t,e);return Bd(e),r}catch(r){throw Bd(e),ai.warn("tree failed to verify:",r),r}}var jr=class extends Error{constructor(){super("cancelled"),this.name="CancelledError"}},Gn=class{constructor(t){this.requestIdleCallback=t;f(this,"resumePromiseResolve");f(this,"resumePromise");f(this,"backgroundMode",!1);f(this,"done",!1);f(this,"firstError");f(this,"debugStepListener")}debugResumeOneStep(){this.resume(),this.pause()}currentMode(){return this.backgroundMode?"slow":"fast"}isDone(){return!!this.firstError||this.done}isSuccess(){return!this.firstError&&this.done}isCancelled(){return!!this.firstError&&this.firstError instanceof jr}isError(){return!!this.firstError&&!(this.firstError instanceof jr)}getError(){return this.firstError}cancel(){this.isDone()||(this.firstError=new jr)}error(t){return this.isDone()||(this.firstError=t),t}pause(){this.firstError||this.resumePromise||(this.resumePromise=new Promise(t=>{this.resumePromiseResolve=t}))}resume(){let t=this.resumePromiseResolve;t&&(this.resumePromise=void 0,this.resumePromiseResolve=void 0,t())}isPaused(){return!!this.resumePromise}fast(){return this.backgroundMode=!1,this}slow(){return this.backgroundMode=!0,this}async run(t){m(!this.isDone(),"task is already done");try{await t()}catch(e){throw e instanceof Error?this.error(e):this.error(new Error(String(e??"Unknown Error"),{cause:e}))}finally{this.done=!0}}async sleep(t){if(this.debugStepListener?.(),await ss(t),this.resumePromise&&await this.resumePromise,this.debugStepListener?.(),this.resumePromise&&await this.resumePromise,this.firstError)throw this.firstError}async yield(){if(this.debugStepListener?.(),this.resumePromise?await this.resumePromise:this.backgroundMode?await new Promise(t=>{this.requestIdleCallback?this.requestIdleCallback(t):typeof requestIdleCallback=="function"?requestIdleCallback(t):setTimeout(t,0)}):await mn(),this.resumePromise&&await this.resumePromise,this.debugStepListener?.(),this.resumePromise&&await this.resumePromise,this.firstError)throw this.firstError}};var z=x("DocumentLoader"),Kn=10,$r=1e3;function cr(o){return o<1024*.75?`${Math.round(o)}b`:o<1024*1024*.75?`${(o/1024).toFixed(2)}kb`:`${(o/1024/1024).toFixed(2)}Mb`}function Ie(o){return o<200?`${o.toFixed(1)}ms`:o<20*1e3?`${(o/1e3).toFixed(3)}s`:`${Math.round(o/1e3)}s`}var rt=class extends md.default{constructor(e,r,n,i){super();this.componentLoader=e;this.treeVersion=r;this.documentURL=n;this.settings=i;f(this,"scheduler");f(this,"activelyLoadingScope",!1);f(this,"retryCount",0);f(this,"scopesToLoad",new Set);f(this,"prioritizedScopeIds",new Set);f(this,"currentLoadingScope");f(this,"partialParser");f(this,"canvasTreeVersion",0);f(this,"documentSize",0);f(this,"loadedFirstScope",!1);f(this,"loadingDuration",0);f(this,"parsingDuration",0);f(this,"debugPaused",!1);f(this,"loadingScopesPaused",!1);f(this,"loadAllDataPriority",0);f(this,"updatePauseResumeState",()=>{if(!this.loadedFirstScope){this.scheduler.fast(),this.scheduler.resume();return}let e=this.loadAllDataPriority>0||this.prioritizedScopeIds.size>0,r=this.loadingScopesPaused||this.debugPaused;e?this.scheduler.fast():this.scheduler.slow(),e||!r||this.scopesToLoad.size<=0?this.scheduler.resume():this.scheduler.pause()});f(this,"tree");f(this,"loadCallbacksPerScope",new Map);f(this,"addedByDiff",new Set);f(this,"removedByDiff",new Set);this.scheduler=new Gn(i.requestIdleCallback),z.debug("new:",this.treeVersion,this.documentURL)}pauseLoadingScopes(){this.loadingScopesPaused||(this.loadingScopesPaused=!0,z.debug("pauseLoadingScopes"),this.updatePauseResumeState())}resumeLoadingScopes(){this.loadingScopesPaused&&(this.loadingScopesPaused=!1,z.debug("resumeLoadingScopes"),this.updatePauseResumeState())}prioritizeLoadingAllData(e){let r="preload"in e&&e.preload;if(r&&ti())return()=>{};let n=performance.now(),i=this.numberOfScopesToLoad();this.loadAllDataPriority=Math.max(1,this.loadAllDataPriority+1),z.debug("prioritizeLoadingScopes:",this.loadAllDataPriority),this.updatePauseResumeState();let s=r||"doNotTrack"in e&&e.doNotTrack,a=!1,d=s?void 0:this.afterAllDataLoaded(()=>{if(a)return;m("operationName"in e,"operationName is required");let h=performance.now()-n;ke("fulltree_force_load",{operationName:e.operationName,durationMs:Math.round(h),background:e.operationInBackground,shallowScopesCount:i})}),u=Yt.isOn("dataOnlyTree")&&ar()?this.afterAllDataLoaded(()=>{if(a)return;m(!("preload"in e),"preload should never load all data");let l={operationName:e.operationName,durationMs:Math.round(performance.now()-n),background:e.operationInBackground,shallowScopesCount:i};z.reportError(new Error("Full tree loaded"),l,{operationName:e.operationName})}):void 0;return()=>{a||(a=!0,d?.(),u?.(),this.stopPrioritizingLoadingAllData())}}stopPrioritizingLoadingAllData(){this.loadAllDataPriority-=1,z.debug("stopPrioritizingLoadingScopes:",this.loadAllDataPriority),this.updatePauseResumeState()}debugPause(){this.debugPaused||(this.debugPaused=!0,z.debug("debugPause"),this.updatePauseResumeState())}debugResume(){this.debugPaused&&(this.debugPaused=!1,z.debug("debugResume"),this.updatePauseResumeState())}isDebugPaused(){return this.debugPaused}afterAllDataLoaded(e){let r=this.scopesToLoad.size===0;if(e){if(r){let n=!1;return queueMicrotask(()=>{n||e()}),()=>{n=!0}}return this.once("loadedAllData",e),()=>{this.off("loadedAllData",e)}}return r?Promise.resolve():new Promise(n=>{this.once("loadedAllData",n)})}async start(){await this.scheduler.run(async()=>{z.debug("start"),ge("parsingInit"),this.updatePauseResumeState();let e=performance.now(),r=await this.loadData();if(this.loadingDuration=performance.now()-e,await this.scheduler.yield(),!this.settings.partialParsing||typeof r=="string"&&!bd(r))return this.parseFullDocumentSync(r);let n=await this.loadDocumentVersion(r);await this.scheduler.yield(),this.tree=await this.loadFirstTree(n),await this.loadAllScopesAsync()})}async loadAllScopesAsync(){this.loadedFirstScope=!0,this.updatePauseResumeState(),await this.scheduler.yield(),ge("parsingResume");let e;for(;(e=this.nextScopeIdToLoad())!==void 0;)await this.loadScopeAsync(e),this.updatePauseResumeState(),await this.scheduler.yield();await this.emitWrapped(()=>{m(this.tree,"tree must have been set"),this.tree.setService("loader",void 0),this.emit("loadedAllData")}),z.debug("done",cr(this.documentSize),"loading:",Ie(this.loadingDuration),"parsing:",Ie(this.parsingDuration))}async loadData(){if(this.settings.loadedData)return this.settings.loadedData;z.debug("Document in cache is not up to date. Tree version:",this.treeVersion);let e=this.settings.initData,r=e?.version===this.treeVersion,n=e?.prefetchPromise;if(e&&delete e.prefetchPromise,r&&n){z.debug("loadData: prefetch");let d=await n;if(n.then(c=>c.duration).then(c=>{ge("dataLoad",c)}),await this.scheduler.yield(),d.buffer){z.debug("loadData: prefetch bytes parser");let c=await d.buffer;return await this.scheduler.yield(),d.status<200||d.status>=300?this.handleErrorAndRetry(d.status,"Error loading project data"):new Uint8Array(c)}if(d.text){let c=await d.text;return await this.scheduler.yield(),d.status<200||d.status>=300?this.handleErrorAndRetry(d.status,c):c}}z.debug("loadData: fetch");let i;this.settings.refreshAccessToken&&(i=await this.settings.refreshAccessToken({}),await this.scheduler.yield());let s=await fetch(this.documentURL,i);await this.scheduler.yield();function a(d){if(!d.body)return!1;let c=new URLSearchParams(window.location.search).has("bytes"),u=document.cookie.includes("bytes-parser=true"),l=parseInt(d.headers.get("Uncompressed-Content-Length")??"0",10)>2e8;return c&&(document.cookie="bytes-parser=true; path=/;"),c||u||l}if(ge("dataLoad"),s.status<200||s.status>=300){let d=await s.text();return this.handleErrorAndRetry(s.status,d)}if(a(s)){z.debug("loadData: using streaming parser");let d=await s.arrayBuffer();return new Uint8Array(d)}else{z.debug("loadData: using text parser");let d=await s.text();return await this.scheduler.yield(),d}}async handleErrorAndRetry(e,r){let n=!1;try{n=JSON.parse(r).retry}catch{}if(n&&this.retryCount<Kn)return z.debug("onErrorStatusLoaded, retry:",this.retryCount),await this.scheduler.sleep(this.retryCount*$r+Math.random()*$r),this.retryCount+=1,this.loadData();throw Error(n?"Too many retries":`Fetch Error: ${e} - ${r}`)}parseFullDocumentSync(e){if(typeof e!="string")throw new Error("Full document sync parsing requires string data, not ReadableStream");let r=performance.now();this.documentSize=e.length;let n=JSON.parse(e);if(!B(n.version))throw Error("cannot read document version");if(this.canvasTreeVersion=n.version,z.debug("parseFullDocumentSync",this.canvasTreeVersion,cr(this.documentSize),Ie(this.loadingDuration)),this.emit("loadedDocumentVersion",n.version),this.scheduler.isDone())return;let i=di(n,this.componentLoader);this.emit("loadedFirstData",i),!this.scheduler.isDone()&&(this.emit("loadedAllData"),this.parsingDuration+=performance.now()-r,ge("parsingFirstPage"),z.debug("done",cr(this.documentSize),"loading:",Ie(this.loadingDuration),"parsing:",Ie(this.parsingDuration)))}hasLoadedScope(e){let r=this.scopesToLoad.has(e),n=this.currentLoadingScope?.id===e;return!r&&!n}numberOfScopesToLoad(){return this.scopesToLoad.size}prioritizeLoadingScope(e,r){let n,i;if(typeof r=="function")this.addScopeLoadCallback(e,r);else if(r&&"onLoaded"in r)this.addScopeLoadCallback(e,r.onLoaded),i=r;else{let s=new Qt;n=s,this.addScopeLoadCallback(e,s.resolve),i=r}if(!(i?.preload&&ti()))return this.scopesToLoad.has(e)&&(this.prioritizedScopeIds.add(e),this.updatePauseResumeState(),this.addScopeLoadCallback(e,this.updatePauseResumeState)),n}nextScopeIdToLoad(){for(let r of this.prioritizedScopeIds)if(this.prioritizedScopeIds.delete(r),!!this.scopesToLoad.has(r))return this.scopesToLoad.delete(r),this.scheduler.fast(),r;let e=this.loadAllDataPriority>0;this.settings.loadInBackground&&!e?this.scheduler.slow():this.scheduler.fast();for(let r of this.scopesToLoad)return this.scopesToLoad.delete(r),r}async loadDocumentVersion(e){let r=performance.now(),n=await Jn.createPartialParser(e,this.componentLoader,this.settings);return typeof e=="string"?this.documentSize=e.length:this.documentSize=0,this.canvasTreeVersion=n.canvasTreeVersion,this.parsingDuration+=performance.now()-r,z.debug("loadDocumentVersion",this.canvasTreeVersion,typeof e=="string"?cr(this.documentSize):"stream",Ie(this.loadingDuration)),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let i=performance.now();this.emit("loadedDocumentVersion",this.canvasTreeVersion),this.parsingDuration+=performance.now()-i}),this.partialParser=n,n}async loadFirstTree(e){let r=performance.now(),n=e.readFirstPage();this.scopesToLoad=e.getScopesToLoad();for(let i of this.scopesToLoad){let s=n.get(i);s&&(s.cache.isShallowLoad=!0)}return this.parsingDuration+=performance.now()-r,z.debug("loadFirstTree",Ie(this.parsingDuration)),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let i=performance.now();n.setService("loader",this),n.chunkingHints=e.chunkingHints,this.emit("loadedFirstData",n),ge("parsingFirstPage"),this.parsingDuration+=performance.now()-i}),n}async loadScopeAsync(e){m(!this.currentLoadingScope,"already have a currently loading scope"),this.activelyLoadingScope=!0,this.currentLoadingScope=this.createLoadingScope(e);let r=await this.currentLoadingScope.run(this.scheduler);if(z.debug("loadScopeAsync:",e,Ie(r.duration),"scheduler mode:",this.scheduler.currentMode()),!r.hasNode()){this.activelyLoadingScope=!1;return}await this.emitWrapped(()=>{if(this.activelyLoadingScope=!1,this.scheduler.isDone())return;let n=performance.now(),i=r.take();this.currentLoadingScope=void 0,i&&(this.emit("loadedScope",i),this.parsingDuration+=r.duration+performance.now()-n,this.signalScopeLoadCallbacks(i.id))})}createLoadingScope(e){return m(this.partialParser,"loadScope before the parser is available"),new ci(e,this.partialParser)}loadScope(e){if(this.currentLoadingScope?.id===e){let n=this.currentLoadingScope.force();return this.parsingDuration+=n.duration,this.currentLoadingScope=void 0,n.take()}if(this.prioritizedScopeIds.delete(e),!this.scopesToLoad.has(e))return;this.scopesToLoad.delete(e);let r=this.createLoadingScope(e).force();return this.parsingDuration+=r.duration,z.debug("loadScope:",e,Ie(r.duration)),this.signalScopeLoadCallbacks(e),r.take()}addScopeLoadCallback(e,r){if(!r)return;if(this.hasLoadedScope(e)){setTimeout(r);return}let n=this.loadCallbacksPerScope.get(e)??[];n.push(r),this.loadCallbacksPerScope.set(e,n)}signalScopeLoadCallbacks(e){setTimeout(()=>{let r=this.loadCallbacksPerScope.get(e);if(r){for(let n of r)n();this.loadCallbacksPerScope.delete(e)}})}async emitWrapped(e){this.settings.asyncEventWrapper?(await this.scheduler.yield(),await this.settings.asyncEventWrapper(e)):(await this.scheduler.yield(),e())}resetTreeForRecovery(e){e.setService("loader",this);for(let r of this.scopesToLoad){let n=e.get(r);n&&(n.cache.isShallowLoad=!0)}this.tree=e}async nodeIdsToLoad(){let e=performance.now(),r=new Set;if(!this.partialParser)return r;let n=performance.now();for(let i of this.scopesToLoad){performance.now()-n>50&&(await mn(),n=performance.now());let s=this.partialParser.getParsedPageById(i);_d(r,s)}for(let i of this.addedByDiff)r.add(i);for(let i of this.removedByDiff)r.delete(i);return z.debug("nodeIdsToLoad",r.size,Ie(performance.now()-e)),r}addNodeChanges(e){for(let r of e){let n=r.id;r.added?(this.addedByDiff.add(n),this.removedByDiff.delete(n)):r.removed&&(this.addedByDiff.delete(n),this.removedByDiff.add(n))}}};function _d(o,t){if(t&&(o.add(t.id),!!t.children))for(let e of t.children)_d(o,e)}var At=class{constructor(t,e){this.node=t;this.duration=e}hasNode(){return!!this.node}take(){let t=this.node;return this.node=void 0,t}},ci=class{constructor(t,e){this.id=t;this.parser=e;f(this,"data");f(this,"loadedScope")}async run(t){if(this.loadedScope)return this.loadedScope;let e=performance.now();this.data=this.parser.getParsedPageById(this.id);let r=performance.now()-e;if(await t.yield(),this.loadedScope)return this.loadedScope;let n=performance.now(),i=this.parser.buildPage(this.data);return i&&(i.cache.isShallowLoad=!1),this.loadedScope=new At(i,r+performance.now()-n),this.loadedScope}force(){if(this.loadedScope)return this.loadedScope;let t=performance.now();this.data||(this.data=this.parser.getParsedPageById(this.id));let e=this.parser.buildPage(this.data);return e&&(e.cache.isShallowLoad=!1),this.loadedScope=new At(e,performance.now()-t),this.loadedScope}};var vt=x("tree:timeline"),Tl=6e4,Il=6e4,lr=class{constructor(t){this.nodeChangesBuffers=t;f(this,"changes",new Map);this.nodeChangesBuffers.add(this)}trackChange(t,e){let r=this.changes.get(t);if(r){e&&r.push(e);return}this.changes.set(t,e?[e]:[])}read(){let t=this.changes;return this.changes=new Map,t}clear(){this.changes=new Map}dispose(){this.nodeChangesBuffers.delete(this)}},Qn=class{constructor(t,e,r=[],n=!1){this.tree=t;this.changes=e;this.editReasons=r;this.wasRebase=n;f(this,"wasScopeInsert",!1);f(this,"version",0);f(this,"timestamp",performance.now())}toDebugData(){return{version:this.version,changes:this.changes,editReasons:this.editReasons,wasScopeInsert:this.wasScopeInsert,wasRebase:this.wasRebase}}},ur=class{constructor(){f(this,"idToChanges",new Map)}getChanges(){return Array.from(this.idToChanges.values())}addChanges(t){if(t)for(let e of t){let r=this.idToChanges.get(e.id);r||(r={id:e.id,to:{}},this.idToChanges.set(e.id,r)),Zo(r,e)}}},Yn=class{constructor(t,e,r){this.componentLoader=e;f(this,"tree");f(this,"entries");f(this,"latestReversibleNodeChanges",null);f(this,"enableAddRemoveOptimizations",!0);f(this,"recorder");f(this,"trimmed",0);f(this,"isPartialLoading",!1);f(this,"internalRemoteTreeIndex",0);f(this,"inErrorRecovery",!1);f(this,"nodeChangesBuffers",new Set);f(this,"legacyMode",!1);f(this,"remoteTreeVersion",0);f(this,"recentEditReasons",[]);f(this,"flagsForNextCommit");f(this,"onlineStartTime",0);f(this,"validationEnabled",!0);f(this,"extraChangesForNextCommit");f(this,"resetTime",0);f(this,"epoch",0);this.reset(t,r)}get length(){return this.entries.length+this.trimmed}get localTreeIndex(){return this.length-1}get remoteTreeIndex(){return this.internalRemoteTreeIndex}incrementRemoteTreeIndex(t){this.internalRemoteTreeIndex+=t}setOnline(t){this.online!==t&&(this.onlineStartTime=t?performance.now():0)}get online(){return this.onlineStartTime!==0}setFlagsForNextCommit(t){this.flagsForNextCommit=t}validateUpdatesAreSentToServer(){if(!this.validationEnabled||!this.online)return;let t=performance.now();if(t-this.onlineStartTime<Il)return;let r=this.getOldestLocalEntry();if(!r)return;let n=t-r.timestamp;m(n<Tl,"Local changes not been processed in a while")}setExtraChangesForNextCommit(t){this.extraChangesForNextCommit=t}recordEditReasons(t){t&&this.recentEditReasons.push(t)}trackChange(t,e=null){for(let r of this.nodeChangesBuffers)r.trackChange(t,e)}getTreeForVersion(t){if(!this.isPartialLoading)return Na(this.entries,e=>e.version===t)?.tree}addEntry(t,e,r=[],n=!1){let i=new Qn(t,e,r,n);return this.entries.push(i),this.tree=t,i}getLastEntry(){let t=this.entries[this.entries.length-1];return m(t,"Timeline has no entries"),t}hasLocalEdits(){return this.remoteTreeIndex+1-this.trimmed<this.entries.length}getOldestLocalEntry(){return this.getEntry(this.remoteTreeIndex+1-this.trimmed)}getEntry(t){return this.entries[t]}reset(t,e){if(this.resetTime=performance.now(),this.inErrorRecovery&&t===this.tree){vt.debug("reset for error recovery..."),this.inErrorRecovery=!1,this.invalidateAllCursors(),this.clearNodeChangesReader();return}vt.debug("reset with tree:",t.root.id,"size:",t.size()),this.entries=[],this.addEntry(t,e?.initialChanges??[],["load"]),this.recentEditReasons=[],this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,this.latestReversibleNodeChanges=null,this.trimmed=0,this.internalRemoteTreeIndex=0,this.isPartialLoading=!!e?.isLoading,this.invalidateAllCursors(),this.clearNodeChangesReader()}invalidateAllCursors(){this.epoch+=1}openNodeChangesReader(){return new lr(this.nodeChangesBuffers)}clearNodeChangesReader(){for(let t of this.nodeChangesBuffers)t.clear()}applyFlagsToChange(t){t&&this.flagsForNextCommit&&(this.flagsForNextCommit.ignoreInUndo&&(t.ignoreInUndo=!0),this.flagsForNextCommit.ignoreInCodeGeneration&&(t.ignoreInCodeGeneration=!0))}commitLocalTree(){this.validateUpdatesAreSentToServer();let t=this.getLastEntry();m(this.tree===t.tree,"tree out of sync");let e={};this.tree=this.tree.commit(this.componentLoader,(n,i)=>{if(!n&&!i)return;let s=ht(n,i);if(this.applyFlagsToChange(s),this.trackChange(n?.id??i.id,s),s){if(s.to.parentid&&s.to.parentid!==s.from?.parentid){let d=this.tree.getScopeNodeAtStartFor(n),c=this.tree.getScopeNodeFor(i);d&&d?.id!==c?.id&&(s.previousScope=d.id)}e[s.id]=s}let a=[];ir(a,n,i);for(let d of a)this.applyFlagsToChange(d),this.trackChange(d.id,d),e[d.id]=d}),this.latestReversibleNodeChanges=Object.values(e);let r=this.latestReversibleNodeChanges;if(this.extraChangesForNextCommit){r=[...r];for(let n of this.extraChangesForNextCommit)this.applyFlagsToChange(n),this.trackChange(n.id,n),r.push(n)}return this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,vt.debug("commit local tree:",r.length,this.recentEditReasons),r.length>0?(m(t.tree!==this.tree,"must be a new tree"),t.tree.releaseMemory(),this.entries.push(new Qn(this.tree,r,this.recentEditReasons))):this.tree!==t.tree&&(t.tree.releaseMemory(),t.tree=this.tree),this.recentEditReasons=[],m(this.tree===this.getLastEntry().tree),this.tree}getLatestChangesForUndo(){return this.latestReversibleNodeChanges}getChangeTrackingCursor(){let t=this.remoteTreeIndex,e=this.localTreeIndex;return{remoteTree:t,localTree:e,timeline:this,tree:this.tree,epoch:this.epoch}}invalidatedByLoadCompletedDocument(t){return!(!t||this.trimmed>0||t.timeline!==this||t.epoch+1!==this.epoch||t.remoteTree+1!==this.remoteTreeIndex)}fetchForwardChanges(t){if(!t||t.epoch!==this.epoch||t.tree.lineage!==this.tree.lineage||t.tree.root.id!==this.tree.root.id||t.timeline!==this||t.localTree>0&&t.localTree<=this.trimmed||t.remoteTree>0&&t.remoteTree<=this.trimmed||this.remoteTreeIndex>0&&this.trimmed>0&&t.remoteTree===0)return;let e=t.localTree;if(this.remoteTreeIndex>0&&!ar())for(e=t.remoteTree-1;e<t.localTree&&!this.entries[e+1-this.trimmed]?.wasRebase;)e+=1;m(e-this.trimmed>=0,"buffer cut too close to remoteTree"),m(e<=t.localTree,"startIndex incorrectly calculated");let r=this.localTreeIndex;m(e<=r,"bad change tracking cursor");let n=t.tree;return t.remoteTree=this.remoteTreeIndex,t.localTree=r,t.tree=this.tree,this.computeForwardChanges(e,r,n)}computeForwardChanges(t,e,r){if(t>=e)return[];let n={};for(let s=t+1;s<=e;s++){let a=this.entries[s-this.trimmed];for(let d of a.changes){let c=d.id,u=n[c];u||(u=n[c]={id:c,to:{}});let l=u.added;Zo(u,d),!r&&l&&u.removed&&this.enableAddRemoveOptimizations&&delete n[c]}}let i=r??this.entries[t-this.trimmed]?.tree;if(!i)throw new Error(`${t} - ${this.trimmed}`);return Object.values(n).filter(s=>{if(s.removed)return s.to={},!0;let a=i.getNodeAtStart(s.id);if(a&&this.enableAddRemoveOptimizations)for(let[l,h]of Object.entries(s.to))ct(a[l],h)&&delete s.to[l];if(s.added||Object.keys(s.to).length>0)return!0;let d=s.toChildren;if(!d)return!1;if(!a)return!0;i.beginAllowPartialScopeAccess();let c=a.children;if(i.endAllowPartialScopeAccess(),!c||!this.enableAddRemoveOptimizations)return!0;let u=c.length;if(u!==d.length)return!0;for(let l=0;l<u;l++)if(c[l].id!==d[l])return!0;return!1})}getEditReasons(t,e){let r=[],n="";for(let i=t+1;i<=e;i++){let s=this.entries[i-this.trimmed].editReasons;for(let a of s)a&&n!==a&&(n=a,r.push(a))}return r.join(" ")}getChangesBetweenEntries(t,e){m(t<e,"inconsistency in getting local changes to send");let r=this.computeForwardChanges(t,e),n=this.getEditReasons(t,e);return{count:e-t,changes:r,reasons:n}}debugOverwriteCurrentTree(t){vt.debug("recover with tree:",t.root.id),this.tree=t,this.getLastEntry().tree=t}resetTreesForRecovery(t,e){vt.info("reset trees for recovery, remote:",this.remoteTreeIndex,"local:",this.localTreeIndex,"changes already sent:",e);let r=this.entries[t]?.tree;m(r,"unable to get remote tree");let n=r.getService("loader"),i=r.lineage.editHooks,s=[];try{let d=JSON.parse(JSON.stringify(r.toJS()));r=_n(d,this.componentLoader,s)}catch(d){if(d instanceof RangeError&&d.message.includes("Invalid string length"))vt.warn("[recovery] Tree too large for JSON serialization, using original tree",{error:d.message,treeSize:r.size()}),s.push("Recovery skipped: tree too large for serialization");else throw d}n&&(n.resetTreeForRecovery(r),m(r.getService("loader")===n,"tree must have the same loader")),i&&(r.lineage.editHooks=i),s.length>0&&vt.warn("[recovery] encountered errors while reloading the tree:",s),this.entries[t].tree=r,this.entries.length=t+e+1;let a=r;for(let d=t+1;d<this.entries.length;d++){let c=this.entries[d];Pe(r,c.changes),r=r.commitDiffs(this.componentLoader),c.tree=r,r!==a&&(a.releaseMemory(),a=r)}return this.inErrorRecovery=!0,this.tree=r,r}saveTimelineDataForRecovery(){if(window.localStorage)try{let t=`debugTimelineAtRecovery-${Math.floor(Math.random()*100)}`,e={date:new Date().toString(),entries:this.entries.map(r=>r.toDebugData())};window.localStorage.setItem(t,JSON.stringify(e))}catch(t){vt.warn("failed to store timeline in localStorage:",t)}}applyChanges(t){Pe(this.tree,t)}applyReverseChanges(t){Oa(this.tree,t)}discardChangeset(){}};var fr=class{constructor(t){this.buffer=t;f(this,"view");f(this,"decoder",new TextDecoder);f(this,"byteOffset",0);this.view=new DataView(t.buffer,t.byteOffset,t.byteLength)}align(t){let e=(t-this.byteOffset%t)%t;this.byteOffset+=e}endOfFile(){return this.byteOffset>=this.buffer.byteLength}readUint8(){let t=this.view.getUint8(this.byteOffset);return this.byteOffset+=1,t}readUint16(){let t=this.view.getUint16(this.byteOffset,!0);return this.byteOffset+=2,t}readVarUint(){let t=0,e=0;for(;;){let r=this.readUint8();if(t+=(r&127)*2**e,(r&128)===0)break;if(e+=7,e>53)throw new Error("VarUint is too big")}return t}readString(){let t=this.readVarUint(),e=this.buffer.subarray(this.byteOffset,this.byteOffset+t);return this.byteOffset+=t,this.decoder.decode(e)}readTypedArray(t){let e=this.readVarUint(),r=t.BYTES_PER_ELEMENT;this.align(r);let n=this.byteOffset+this.buffer.byteOffset,i=e*r;if(n%r!==0){let s=new ArrayBuffer(i);return new Uint8Array(s).set(new Uint8Array(this.buffer.buffer,n,i)),this.byteOffset+=i,new t(s,0,e)}return this.byteOffset+=i,new t(this.buffer.buffer,n,e)}};var wl=1024*1024,qr=class{constructor(t=new Uint8Array(wl)){this.buffer=t;f(this,"view");f(this,"encoder",new TextEncoder);f(this,"byteOffset",0);this.view=new DataView(this.buffer.buffer)}ensureCapacity(t){let e=this.byteOffset+t;if(e>this.buffer.length){let r=this.buffer.length*2;for(;r<e;)r*=2;let n=new Uint8Array(r);n.set(this.buffer),this.buffer=n,this.view=new DataView(this.buffer.buffer)}}align(t){let e=this.byteOffset+t-1&~(t-1);this.ensureCapacity(e-this.byteOffset),this.byteOffset=e}writeUint8(t){return this.ensureCapacity(1),this.view.setUint8(this.byteOffset,t),this.byteOffset+=1,1}writeUint16(t){this.ensureCapacity(2),this.view.setUint16(this.byteOffset,t,!0),this.byteOffset+=2}writeVarUint(t){let e=t;for(;e>=128;)this.writeUint8(e%128|128),e=Math.floor(e/128);this.writeUint8(e)}writeString(t){let e=this.encoder.encode(t);this.writeVarUint(e.length),this.ensureCapacity(e.length),this.buffer.set(e,this.byteOffset),this.byteOffset+=e.length}writeTypedArray(t,e=t.length){this.writeVarUint(e);let r=this.preallocateTypedArray(t.BYTES_PER_ELEMENT,e),n=new Uint8Array(t.buffer,t.byteOffset,r);this.buffer.set(n,this.byteOffset),this.byteOffset+=r}preallocateTypedArray(t,e){this.align(t);let r=e*t;return this.ensureCapacity(r),r}writeBytes(t){this.ensureCapacity(t.length),this.buffer.set(t,this.byteOffset),this.byteOffset+=t.length}getBuffer(){return this.buffer.slice(0,this.byteOffset)}};function Wr(o){if(o===Uint8Array)return"U8";if(o===Uint16Array)return"U16";if(o===Uint32Array)return"U32";if(o===Float64Array)return"F64";throw new Error("Invalid array name")}var N=Symbol("deleted"),ie=Symbol("keep"),re="$keep",bt="$deleted",Xn=new Map([[void 0,"undefined"],[N,"Symbol(deleted)"],[ie,"Symbol(keep)"]]);function Ft(o){return Xn.has(o)}var ui="__$$framerCrdtNativeField$$__",Nl=new Map([...Xn].map(([o,t])=>[t,o]));function Me(o){return typeof o=="object"&&o!==null&&ui in o}function St(o){return{[ui]:Xn.get(o)}}function Ve(o){return Nl.get(o[ui])}var mr=class{constructor(t,e,r){this.capacity=t;f(this,"buffer");f(this,"length",0);r?(this.buffer=r.buffer,this.length=r.length,m(this.buffer.length===this.capacity,"Buffer capacity mismatch:",this.buffer.length,"!=",this.capacity)):this.buffer=new e(t)}push(t){this.buffer[this.length]=t,this.length+=1}};var Rl=2**17,pr=class{constructor(t,e=Rl){this.arrayConstructor=t;this.bucketSize=e;f(this,"buckets",[]);f(this,"_length",0);f(this,"bucketShift");f(this,"bucketMask");m((e&e-1)===0,`Bucket size must be a power of 2, got: ${e}`),this.bucketShift=Math.log2(e),this.bucketMask=e-1}get type(){return`BucketedColumn(${Wr(this.arrayConstructor)})`}add(t){let e=this.buckets[this.buckets.length-1];(!e||e.length>=e.capacity)&&(e=new mr(this.bucketSize,this.arrayConstructor),this.buckets.push(e)),e.push(t);let r=this._length;return this._length+=1,r}get(t){m(t>=0&&t<this._length,"index",t,"out of bounds (column size:",this._length,")");let e=t>>this.bucketShift,r=t&this.bucketMask,n=this.buckets[e];return m(n,"invalid bucket index"),n.buffer[r]}_set(t,e){m(t>=0&&t<this._length,"index",t,"out of bounds (column size:",this._length,")");let r=t>>this.bucketShift,n=t&this.bucketMask,i=this.buckets[r];m(i,"invalid bucket index"),i.buffer[n]=e}get length(){return this._length}slice(t,e){t<0&&(t=this.length+t),e<0&&(e=this.length+e);let r=t>>this.bucketShift,n=e>>this.bucketShift,i=Math.min(this.length,e)-t;if(i<=0)return[];let s=Array.from({length:i}),a=0,d=t&this.bucketMask,c=this.buckets[r];if(r===n){let h=e&this.bucketMask;for(let g=d;g<h;++g)s[a++]=c.buffer[g];return s}for(let h=d;h<this.bucketSize;++h)s[a++]=c.buffer[h];for(let h=r+1;h<n;++h){let g=this.buckets[h];for(let y=0;y<g.length;++y)s[a++]=g.buffer[y]}let u=e&this.bucketMask,l=this.buckets[n];if(l)for(let h=0;h<u;++h)s[a++]=l.buffer[h];return s}serialize(t){t.writeVarUint(this.length),t.preallocateTypedArray(this.arrayConstructor.BYTES_PER_ELEMENT,this.length);for(let e of this.buckets)t.writeBytes(new Uint8Array(e.buffer.buffer,e.buffer.byteOffset,e.length*this.arrayConstructor.BYTES_PER_ELEMENT))}deserialize(t){let e=t.readTypedArray(this.arrayConstructor);this._length=e.length;let r=0;for(r=0;r<e.length-this.bucketSize;r+=this.bucketSize){let n=e.subarray(r,r+this.bucketSize);this.buckets.push(new mr(this.bucketSize,this.arrayConstructor,{buffer:n,length:n.length}))}if(r<e.length){let n=new mr(this.bucketSize,this.arrayConstructor);for(;r<e.length;++r)n.push(e[r]);this.buckets.push(n)}}};var we=class o{constructor(t,e){this.arrayConstructor=t;f(this,"uniques",[]);f(this,"maxUniques");f(this,"indices");f(this,"count",0);f(this,"lookup");f(this,"cursor",0);if(this.indices=new pr(t,e),t===Uint8Array)this.maxUniques=2**8-1;else if(t===Uint16Array)this.maxUniques=2**16-1;else if(t===Uint32Array)this.maxUniques=2**32-1;else if(t===Float64Array)this.maxUniques=Number.MAX_SAFE_INTEGER;else throw new Error(`Unsupported array constructor: ${t.name}`)}get type(){return`LazyNormalizedBucketedColumn(ref: ${Wr(this.arrayConstructor)})`}static withBuckets({buffer:t,size:e}){return{create:()=>new o(t,e)}}hydrateThrough(t){for(this.lookup||(this.lookup=new Map);this.cursor<=t;++this.cursor){let e=this.uniques[this.cursor];this.lookup.set(e,this.cursor)}}indexOfExisting(t){if(this.lookup?.has(t))return this.lookup.get(t);for(;this.cursor<this.uniques.length;++this.cursor){let e=this.uniques[this.cursor];if(this.lookup??=new Map,this.lookup.set(e,this.cursor),Object.is(e,t))return this.cursor}}addUnique(t){m(this.uniques.length<this.maxUniques,"limit reached for unique values");let e=this.uniques.length;return this.uniques.push(t),this.lookup??=new Map,this.lookup.set(t,e),this.cursor=this.uniques.length,e}add(t){let e=this.indexOfExisting(t);e===void 0&&(e=this.addUnique(t));let r=this.count;return this.indices.add(e),this.count=r+1,r}get(t){m(t>=0&&t<this.count,"index out of bounds");let e=this.indices.get(t);return this.uniques[e]}_set(t,e){m(t>=0&&t<this.count,"index out of bounds");let r=this.indexOfExisting(e);r===void 0&&(r=this.addUnique(e)),this.indices._set(t,r)}slice(t,e){let r=Math.max(0,e-t),n=Array.from({length:r}),i=this.indices.slice(t,e);for(let s=0;s<r;++s)n[s]=this.uniques[i[s]];return n}get length(){return this.count}serialize(t){t.writeString(JSON.stringify(this.uniques,(e,r)=>Ft(r)?St(r):r)),this.indices.serialize(t)}deserialize(t){this.uniques=JSON.parse(t.readString());for(let e=0;e<this.uniques.length;++e){let r=this.uniques[e];if(Me(r)){let n=Ve(r);this.uniques[e]=n}}this.indices.deserialize(t),this.count=this.indices.length,this.lookup=void 0,this.cursor=0}rehydrate(){this.cursor<this.uniques.length&&this.hydrateThrough(this.uniques.length-1)}};var $e=class{constructor(t=1024){f(this,"uniques",[]);f(this,"indices");f(this,"count",0);f(this,"lookup");f(this,"cursor",0);this.indices=new Uint32Array(t)}get type(){return"LazyNormalizedColumn"}ensureCapacity(t){if(t<=this.indices.length)return;let e=this.indices.length||1;for(;e<t;)e<<=1;let r=new Uint32Array(e);r.set(this.indices),this.indices=r}hydrateThrough(t){for(this.lookup||(this.lookup=new Map);this.cursor<=t;++this.cursor){let e=this.uniques[this.cursor];this.lookup.set(e,this.cursor)}}indexOfExisting(t){if(this.lookup?.has(t))return this.lookup.get(t);for(;this.cursor<this.uniques.length;++this.cursor){let e=this.uniques[this.cursor];if(this.lookup??=new Map,this.lookup.set(e,this.cursor),Object.is(e,t))return this.cursor}}addUnique(t){let e=this.uniques.length;return this.uniques.push(t),this.lookup??=new Map,this.lookup.set(t,e),this.cursor=this.uniques.length,e}add(t){let e=this.indexOfExisting(t);e===void 0&&(e=this.addUnique(t));let r=this.count;return this.ensureCapacity(r+1),this.indices[r]=e,this.count=r+1,r}get(t){if(t<0||t>=this.count)throw RangeError("index out of bounds");return this.uniques[this.indices[t]]}_set(t,e){if(t<0||t>=this.count)throw RangeError("index out of bounds");let r=this.indexOfExisting(e);r===void 0&&(r=this.addUnique(e)),this.indices[t]=r}slice(t,e){let r=Math.max(0,e-t),n=Array.from({length:r});for(let i=0;i<r;++i)n[i]=this.uniques[this.indices[t+i]];return n}get length(){return this.count}serialize(t){t.writeString(JSON.stringify(this.uniques,(e,r)=>Array.isArray(r)?r.map(n=>Ft(n)?St(n):n):Ft(r)?St(r):r)),t.writeTypedArray(this.indices.subarray(0,this.count))}deserialize(t){this.uniques=JSON.parse(t.readString());for(let r=0;r<this.uniques.length;++r){let n=this.uniques[r];if(Array.isArray(n)){for(let i=0;i<n.length;++i)if(Me(n[i])){let s=Ve(n[i]);n[i]=s}}else if(Me(n)){let i=Ve(n);this.uniques[r]=i}}let e=t.readTypedArray(Uint32Array);this.indices=new Uint32Array(e),this.count=this.indices.length,this.lookup=void 0,this.cursor=0}rehydrate(){this.cursor<this.uniques.length&&this.hydrateThrough(this.uniques.length-1)}};var Zn="$deleted",fi="$keep_value";function xl(o){let t=new Set,e=Dl(o);for(let r=0;r<e.length;r++){let n=e[r],i=o.key.get(n),s=o.id.get(n),a=o.client.get(n);if(i==="parentid"){let u=o.value.get(n);if(u===null){o.id._set(n,Zn);continue}if(m(typeof u=="string","parentid is not a string for row:",n),mi(u))continue;let l=new Map,h;for(let g=r+1;g<e.length;g++){let y=e[g];if(o.client.get(y)!==a)continue;let v=o.seq.get(y);if(h!==void 0&&v>h)break;let C=o.key.get(y),w=o.id.get(y),R=o.value.get(y);if(t.has(y)||typeof C!="number"||w!==`${u}.children`||R===Zn||R===fi)continue;h===void 0&&(h=v);let E=Ut(R);m(E,"should be a valid object reference",R),E===s?o.value._set(n,zd(u,C)):l.set(E,C),t.add(y)}for(let g of l.keys()){let y;for(let b=r+1;b<e.length;b++){let v=e[b];if(o.client.get(v)!==a)continue;let w=o.id.get(v),R=o.key.get(v),E=o.value.get(v);if(!(w!==g||R!=="parentid"||E!==u)){if(mi(E))break;y=v;break}}m(y!==void 0,"failed to find parentid row for",g),o.value._set(y,zd(u,l.get(g)))}continue}if(i==="children"){o.value._set(n,fi);continue}let d=o.value.get(n);if(s.endsWith(".children")&&d===fi){t.add(n);continue}if(s.endsWith(".children")&&d===Zn){t.add(n);continue}let c=typeof d=="string"&&Ut(d);if(!t.has(n)&&s.endsWith(".children")&&c&&typeof i=="number"){let u=o.seq.get(n),l=!1;for(let h=r+1;h<e.length;h++){let g=e[h];if(o.client.get(g)!==a)continue;if(o.seq.get(g)!==u)break;let v=o.key.get(g),C=o.id.get(g);if(v!=="parentid"||C!==c)continue;let w=o.value.get(g);if(!mi(w)&&(m(typeof w=="string","expecting value to be a string for rowIdx",g),s.startsWith(w))){l=!0,o.value._set(g,`${w}@${i}`),t.add(n);break}}if(!l){let h=s.split(".",2)[0];o.id._set(n,c),o.key._set(n,"parentid"),o.value._set(n,`${h}@${i}`)}}}for(let r of t)o.id.get(r).endsWith(".children")&&o.id._set(r,Zn)}var jd={description:"Migrates multi-seq rows for hierarchy changes to `{parentid}@{position}`",migrate:xl};function Dl(o){let t=[];for(let e=0;e<o.client.length;e++){let r=o.key.get(e);if(r==="parentid"||r==="children"){t.push(e);continue}o.id.get(e).endsWith(".children")&&t.push(e)}return t.sort((e,r)=>{let n=o.seq.get(e),i=o.seq.get(r);return n===i?o.client.get(e)-o.client.get(r):n-i}),t}function mi(o){return typeof o=="string"&&o.split("@").length===2}function zd(o,t){return`${o}@${t.toString()}`}var $d="$keep_value",qd="$deleted",Wd={description:"Replace deleted and keep values with symbols",migrate(o){if(o.value instanceof $e||o.value instanceof we){let t=o.value.uniques;for(let e in t)t[e]===qd?t[e]=N:t[e]===$d&&(t[e]=ie)}else for(let t=0;t<o.value.length;++t){let e=o.value.get(t);e===qd?o.value._set(t,N):e===$d&&o.value._set(t,ie)}}};function El(o){if(o.client instanceof $e||o.client instanceof we){let t=o.client.uniques;for(let e in t)t[e]=Hd(t[e])}else for(let t=0;t<o.client.length;++t){let e=o.client.get(t);o.client._set(t,Hd(e))}}var Jd={description:"Migrates row `client` to u32",migrate:El};function Hd(o){return o>>>0}var hr=62,pi="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",Gd={};for(let o=0;o<pi.length;o++)Gd[pi[o]]=o;function hi(o,t){if(m(o>=0,"Cannot encode negative number:",o),m(Number.isInteger(o),"Cannot encode non-integer:",o),o===0)return"0".repeat(t);let e=[],r=o;for(;r>0;)e.push(pi[r%hr]),r=Math.floor(r/hr);let n=e.reverse().join("");return m(n.length<=t,"Encoded value exceeds width:",n,"from",o,"width",t),n.padStart(t,"0")}function gi(o){m(o.length>0,"Cannot decode empty string");let t=0;for(let e=0;e<o.length;e++){let r=o[e],n=Gd[r];m(n!==void 0,"Invalid base62 character:",r,"in string",o),t=t*hr+n}return m(t<=Number.MAX_SAFE_INTEGER,"Decoded number exceeds MAX_SAFE_INTEGER"),t}var Ot=5,Kd=6,yi=Ot+Kd;function Ll(o){let t=hi(o.position,Ot),e=hi(o.client,Kd);return t+e}function kl(o){m(o.length===yi,"Component string must be",yi,"chars, got",o.length);let t=o.slice(0,Ot),e=o.slice(Ot);return{position:gi(t),client:gi(e)}}var vi=":";function Ct(o){return o.map(Ll).join(vi)}function gr(o){m(o.length>0,"Position ID is empty");let t=o.split(vi);return m(t.length>0,"Position ID has no parts"),t.map(kl)}function Qd(o){if(typeof o!="string"||o.length===0)return!1;let t=o.split(vi);for(let e of t)if(e.length!==yi)return!1;return!0}var Pl=0,Ml=62**5,Vl=0,Al=Number.MAX_SAFE_INTEGER;function eo(o,t,e){o&&t&&(m(o<=t,"Invalid boundaries",o,">",t),m(o!==t,"Trying to allocate between equal boundarys (same position, same client)",o));let r=o?gr(o):[],n=t?gr(t):[],i=Fl(r,n,e);return Ct(i)}var Yd;function Fl(o,t,e){let r=[],n=0,i=!1;for(;;){m(n<2e3,"Infinite loop");let s=n<o.length,a=n<t.length,d=s?o[n]:{position:Pl,client:Vl},c=a&&!i?t[n]:{position:Ml,client:Al};if(c.position-d.position>1){let u;Yd?u=Yd:t.length===0?u=(h,g)=>Xd(h,g,4096,2):i?u=(h,g)=>Xd(h,g,8192,2):u=Ul;let l=u(d.position+1,c.position-1);return r.push({position:l,client:e}),r}if(r.push({...d}),!i){let u=d.position<c.position,l=a&&d.position===c.position&&d.client<c.client;i=u||l}n++}}function Xd(o,t,e,r){m(o<=t,"Invalid range:",o,">",t);let n=Math.min(t,o+r),i=Math.min(t,n+e);return Zd(n,i)}function Ul(o,t){m(o<=t,"Invalid range:",o,">",t);let e=Math.floor((o+t)/2),r=Math.min(8,Math.floor((t-o)/4)),n=Math.max(o,e-r),i=Math.min(t,e+r);return Zd(n,i)}function Zd(o,t){let e=t-o+1;return Math.floor(Math.random()*e)+o}var Hr="$deleted",Bl="$keep",to=hr**Ot-1;function _l(o){zl(o),jl(o),$l(o),Hl(o)}var ec={description:"Migrates array positions from fraction indices to Logoot-style position ids",migrate:_l};function zl(o){let t=new Set;for(let e=0;e<o.client.length;e++){let r=o.id.get(e);if(r===Hr)continue;let n=o.key.get(e);if(n!=="parentid")continue;let i=o.value.get(e);if(i===N)continue;if(m(typeof i=="string"),i.split("@").length===1){o.id._set(e,Hr);continue}let a=o.client.get(e),d=o.seq.get(e),c=`${r}/${n}/${i}${a}/${d}`;if(t.has(c)){o.id._set(e,Hr);continue}t.add(c)}}function jl(o){for(let t=0;t<o.client.length;t++)o.key.get(t)!==-1||o.value.get(t)!==ie||o.key._set(t,Bl)}function $l(o){let t=ql(o);for(let[e,r]of t){let n=Array.from(r.keys()).sort((s,a)=>s-a),i=Math.floor(to/(n.length+3));m(i>0,"step must be positive");for(let s=0;s<n.length;s++){let a=(s+1)*i;m(a<=to,"position exceeds max position");let d=n[s],c=r.get(d);c.sort((l,h)=>Wl(o,l,h));let u=[];for(let l of c){if(o.value.get(l)===N){let g=u.pop();m(g,"expected to have a previous position to delete"),o.key._set(l,g);continue}let h=Ct([{position:a,client:o.client.get(l)}]);o.key._set(l,h),u.push(h)}}}}function ql(o){let t=new Map;for(let e=0;e<o.client.length;e++){let r=o.id.get(e);if(r===Hr)continue;let n=o.key.get(e);if(typeof n!="number")continue;let i=t.get(r);i||(i=new Map,t.set(r,i));let s=i.get(n);s||(s=[],i.set(n,s)),s.push(e)}return t}function Wl(o,t,e){let r=o.seq.get(t),n=o.seq.get(e);if(r<n)return-1;if(r>n)return 1;let i=o.client.get(t),s=o.client.get(e);return i<s?-1:i>s?1:0}function Hl(o){let t=Jl(o);for(let[e,r]of t){let n=r.sort((s,a)=>Gl(o,s,a)),i=Math.floor(to/(n.length+3));m(i>0,"step must be positive");for(let s=0;s<n.length;s++){let a=(s+1)*i;m(a<=to,"position exceeds max position");let{rowIdx:d}=n[s];Kl(o,d,e,a)}}}function Jl(o){let t=new Map;for(let e=0;e<o.client.length;e++){if(o.id.get(e)===Hr||o.key.get(e)!=="parentid")continue;let i=o.value.get(e);if(i===N)continue;m(typeof i=="string");let s=i.split("@");m(s.length===2,"invalid hierarchy key");let a=s[0],d=parseFloat(s[1]),c=t.get(a);c||(c=[],t.set(a,c)),c.push({rowIdx:e,value:d})}return t}function Gl(o,t,e){if(t.value<e.value)return-1;if(t.value>e.value)return 1;let r=o.seq.get(t.rowIdx),n=o.seq.get(e.rowIdx);if(r>n)return-1;if(r<n)return 1;let i=o.client.get(t.rowIdx),s=o.client.get(e.rowIdx);return i>s?-1:i<s?1:0}function Kl(o,t,e,r){let n=Ct([{position:r,client:o.client.get(t)}]);o.value._set(t,`${e}@${n}`)}var tc=27,rc=2**tc-1,bi=1,Ql=26,nc=2**Ql-1,Si=1,Ci=2**tc;function yr({batchNo:o,rowCount:t}){return m(t>=bi&&t<=rc,"rowCount out of range",t),m(o>=Si&&o<=nc,"batchNo out of range",o),m(Number.isSafeInteger(o),"batchNo is not a safe integer",o),m(Number.isSafeInteger(t),"rowCount is not a safe integer",t),o*Ci+t}function Ti(o){return m(Number.isSafeInteger(o),"batchId not safe integer",o),m(o>=0,"batchId is negative",o),Math.floor(o/Ci)}function Ii(o){let t=Ti(o);return{rowCount:o-t*Ci,batchNo:t}}var Vh={ROW_COUNT_MIN:bi,ROW_COUNT_MAX:rc,BATCH_NO_MIN:Si,BATCH_NO_MAX:nc,MIN_BATCH_ID:yr({batchNo:Si,rowCount:bi})};function Yl(o){let t=new Map;for(let n=0;n<o.client.length;n++){let i=o.client.get(n),s=t.get(i);s===void 0?t.set(i,1):t.set(i,s+1)}let e=new Map;for(let[n,i]of t)e.set(n,yr({batchNo:1,rowCount:i}));let r=we.withBuckets({buffer:Uint32Array}).create();for(let n=0;n<o.client.length;n++){let i=o.client.get(n),s=e.get(i);r.add(s)}o.batch=r}var oc={description:"Adds batch column and populates initial value",migrate:Yl};function Xl(o){Zl(o);let t=new Map;for(let e=0;e<o.client.length;e++){if(o.id.get(e)===bt)continue;let n=o.value.get(e);if(typeof n!="string"||!n.startsWith("arr("))continue;let i=n.slice(4,-1),s=t.get(i);if(s){s.referenceRowIdx.push(e);continue}t.set(i,{itemRowIdxs:[],referenceRowIdx:[e],keepRowIdx:-1,isAtomic:!1})}for(let e=0;e<o.client.length;e++){let r=o.id.get(e);if(!t.has(r))continue;let n=t.get(r);if(o.key.get(e)===re){m(n.keepRowIdx===-1,"array has multiple keep rows",r),n.keepRowIdx=e;continue}let s=o.value.get(e);if(typeof s=="string"&&(s.startsWith("arr(")||s.startsWith("obj("))){m(n.itemRowIdxs.length===0,"array has mixed primitive/reference items",r);continue}!n.isAtomic&&s===N||(n.isAtomic=!0,n.itemRowIdxs.push(e))}for(let[e,r]of t){if(!r.isAtomic)continue;for(let c of r.referenceRowIdx)o.id._set(c,bt);r.itemRowIdxs.sort((c,u)=>{let l=o.seq.get(c),h=o.seq.get(u);if(l<h)return-1;if(l>h)return 1;let g=o.client.get(c),y=o.client.get(u);return g<y?-1:g>y?1:0});let n=e.split(".");m(n.length>=2,"invalid array reference id",e);let i=n.pop(),s=n.join("."),a=[],d=r.keepRowIdx;m(d!==-1,"array reference has no keep row",e),o.id._set(d,s),o.key._set(d,i),o.value._set(d,[]);for(let c of r.itemRowIdxs){o.id._set(c,s);let u=o.key.get(c),l=o.value.get(c);if(l===N){let h=a.findIndex(g=>g.key===u);h!==-1&&a.splice(h,1)}else{let h=a.findIndex(g=>g.key>u);h!==-1?a.splice(h,0,{key:u,value:l}):a.push({key:u,value:l})}o.key._set(c,i),o.value._set(c,a.map(({value:h})=>h))}}}function Zl(o){let t=new Set;for(let e=0;e<o.client.length;e++){let r=o.id.get(e);if(r===bt)continue;let n=o.key.get(e),i=o.client.get(e),s=o.seq.get(e),a=o.value.get(e);typeof a=="symbol"&&(a=a.toString());let d=`${r}/${n}/${a}/${i}/${s}`;if(t.has(d)){o.id._set(e,bt);continue}t.add(d)}}var ic={description:"Migrates arrays of primitives to atomic array values",migrate:Xl};var sc="$keep",wi="$deleted";function eu(o){let t=ru(o),e=nu(o,t);for(let[r,n]of e){n.sort((a,d)=>ou(o,a,d));let i=new Map,s=new Map;for(let a=0;a<n.length;a++){let d=n[a],c=o.id.get(d);m(c===r,"array reference id does not match row id",c);let u=o.key.get(d);m(u!==sc,"array reference key cannot be $keep",u);let l=o.value.get(d);if(m(l===N||Ni(l),"array reference value must be object reference",l),l===N)continue;let h=l.slice(4,-1);i.set(h,u),s.set(u,h)}for(let a=0;a<n.length;a++){let d=n[a],c=o.key.get(d),u=o.value.get(d);if(u===N){let h=s.get(c);if(h===void 0){o.id._set(d,wi);continue}let g=i.get(h);c===g?o.key._set(d,h):o.id._set(d,wi);continue}m(Ni(u),"array reference value must be object reference",u);let l=u.slice(4,-1);o.key._set(d,l),o.value._set(d,c)}}}function tu(o){return typeof o=="string"&&o.startsWith("arr(")}function ru(o){let t=new Set;for(let e=0;e<o.client.length;e++){if(o.id.get(e)===wi)continue;let n=o.value.get(e);if(!tu(n))continue;let i=n.slice(4,-1);t.add(i)}return t}function Ni(o){return typeof o=="string"&&o.startsWith("obj(")}function nu(o,t){let e=new Map([...t].map(r=>[r,[]]));for(let r=0;r<o.client.length;r++){let n=o.id.get(r);if(!e.has(n)||o.key.get(r)===sc)continue;let s=o.value.get(r);m(s===N||Ni(s),"only DELETED_VALUE and object references can be reference array items"),e.get(n).push(r)}return e}function ou(o,t,e){let r=o.seq.get(t),n=o.seq.get(e);if(r<n)return-1;if(r>n)return 1;let i=o.client.get(t),s=o.client.get(e);return i<s?-1:i>s?1:0}var ac={description:"Migrates array of objects to invert index from position-keyed to id-keyed",migrate:eu};var dc={migrate(){},description:"Dummy migration. Does nothing"};var Ri={m1_2:dc,m2_3:jd,m3_4:Wd,m4_5:Jd,m5_6:ec,m6_7:oc,m7_8:ic,m8_9:ac};function cc(o,t){let e=`m${o}_${t}`;return m(Ri[e],"Migration from",o,"to",t,"does not exist"),Ri[e]}var xi=9,Jr=class Jr{constructor(t=xi){this.version=t;f(this,"columns",{client:we.withBuckets({buffer:Uint32Array}).create(),seq:new pr(Float64Array),batch:we.withBuckets({buffer:Uint32Array}).create(),id:new $e,key:new $e,value:new $e,user:we.withBuckets({buffer:Uint8Array}).create()})}addRows(t){for(let e of t)this.addRow(e)}addRow(t){return this.columns.seq.add(t.seq),this.columns.id.add(t.id),this.columns.key.add(t.key),this.columns.value.add(t.value),this.columns.user.add(t.user),this.columns.batch.add(t.batch),this.columns.client.add(t.client)}addSerializableRow(t){let e=t.value;Me(e)&&(e=Ve(e)),this.addRow({...t,value:e})}getRowInternal(t){return{client:this.columns.client.get(t),seq:this.columns.seq.get(t),id:this.columns.id.get(t),key:this.columns.key.get(t),value:this.columns.value.get(t),user:this.columns.user.get(t),batch:this.columns.batch.get(t)}}getRow(t){if(t<0||t>=this.columns.client.length)throw new Error("Index out of bounds");return this.getRowInternal(t)}getRows(t=0,e=this.columns.client.length){if(t<0||e>this.columns.client.length||t>e)throw new Error("Index out of bounds");let r=Array.from({length:e-t});for(let n=t;n<e;n++)r[n-t]=this.getRowInternal(n);return r}getSerializableRows(t=0,e=this.columns.client.length){if(t<0||e>this.columns.client.length||t>e)throw new Error("Index out of bounds");let r=Array.from({length:e-t});for(let n=t;n<e;++n){let i=this.getRowInternal(n);Ft(i.value)&&(i.value=St(i.value)),r[n-t]=i}return r}toBuffer(){let t=new qr;t.writeString(Jr.MAGIC),t.writeUint16(this.version);let e;for(e in this.columns){let r=this.columns[e];t.writeString(e),t.writeString(r.type),r.serialize(t)}return t.getBuffer()}migrateBufferIfNeeded(t,e=this.version){let r=new fr(t),{version:n}=this.readHeader(r);if(n!==e){m(n<e,"Binary document version is newer than current version (",n,">",e,")"),this.readColumns(r);for(let i=n;i<e;++i)cc(i,i+1).migrate(this.columns);return{migrated:!0,from:n,to:e}}return{migrated:!1,version:e}}fromBuffer(t){let e=new fr(t),{version:r}=this.readHeader(e);m(r===this.version,"Version mismatch:",r,"(actual)","!=",this.version,"(expected)"),this.readColumns(e)}readHeader(t){let e=t.readString();return m(e===Jr.MAGIC,"Not a framer document:",e),{version:t.readUint16()}}readColumns(t){for(;!t.endOfFile();){let e=t.readString(),r=this.columns[e];m(r,"Column",e,"not found");let n=t.readString();m(n===r.type,"Column type does not match:",n,"(actual)","!=",r.type,"(expected)"),r.deserialize(t)}}get length(){return this.columns.client.length}};f(Jr,"MAGIC","FRAMERCRDT");var Bt=Jr;var Gr="@";function ro(o){if(o===N)return!0;if(typeof o!="string")return!1;let t=o.indexOf(Gr);return t===-1?!1:o.indexOf(Gr,t+1)===-1}function no(o,t){return`${o}${Gr}${t}`}function Di(o){m(o!==N,"trying to get positionId of deleted child");let t=o.indexOf(Gr);return o.slice(t+1)}function ye(o){if(o===N)return N;let t=o.indexOf(Gr);return o.slice(0,t)}var iu=2**32-1,Ei=class{constructor(){f(this,"id","");f(this,"parentIdHistory",[]);f(this,"resolvedParentId");f(this,"childrenById");f(this,"childrenSorted");f(this,"inTree",!1);f(this,"__class");f(this,"isMaster",!1);f(this,"inMaster");f(this,"replicaInfoMaster");f(this,"replicaInfo")}getReplicaInfo(t,e){if(this.replicaInfo)return this.replicaInfo;if(!this.replicaInfoMaster)return;let r="replicaInfo",n=e.map.get(r);if(n!==void 0){let i=t.getNodeValueForRow(e.nodeData.id,r,n);if(i!==N)return this.replicaInfo=i,this.replicaInfo}}};function oo(o){return o?.nodeData?.inTree??!1}var Kr=class{constructor(t,e,r){this.store=t;this.table=e;this.latest=r;f(this,"rootNodeId");f(this,"classToIds",new Map);f(this,"masterIdToReplicaIds",new Map);f(this,"parentOverrides",new Map);f(this,"parentHistory",[]);f(this,"inTreeCount",0)}getRootId(){return this.rootNodeId}sizeWithoutReplicas(){return this.inTreeCount+1}has(t){return!!(t===this.rootNodeId||this.getNodeData(t)?.inTree||this.getLatestReplicaChild(t))}getNodeData(t){return this.latest.getLatest(t)?.nodeData}getLatest(t){return this.latest.getLatest(t)}ensureNodeData(t){let e=this.latest.getLatest(t);return e||(e=this.latest.create(t)),e.nodeData||(e.nodeData=new Ei,e.nodeData.id=t),e.nodeData}getLatestReplicaChild(t){if(t.length<11)return;let r=t.slice(0,9),n=this.getLatest(r);if(oo(n)){if(!n.nodeData.replicaInfoMaster)return;let i=n.nodeData.replicaInfoMaster,s=t.slice(9),a=this.getLatest(s);return!oo(a)||a.nodeData.inMaster!==i?void 0:[r,n,s,a]}for(let i=7;i<t.length-9+2;i++)if(i!==9&&(r=t.slice(0,i),n=this.getLatest(r),oo(n))){if(!n.nodeData?.replicaInfoMaster)return;let s=n.nodeData.replicaInfoMaster,a=t.slice(i),d=this.getLatest(a);return!oo(d)||d.nodeData.inMaster!==s?void 0:[r,n,a,d]}}computeTreeHash(){let t=0,e=this;function r(n){t=ds(n,t);let i=e.getChildrenIds(n);for(let s of i)r(s)}return this.rootNodeId&&r(this.rootNodeId),t}addChild(t,e,r){t.childrenById||(t.childrenById=new Map),t.childrenById.set(e,r),t.childrenSorted=void 0}removeChild(t,e){let r=this.getNodeData(t);m(r?.childrenById,"no children to delete from, parentid: ",t),r.childrenById.delete(e),r.childrenSorted=void 0}addToNodeIndexes(t,e){if(e.__class){let r=this.classToIds.get(e.__class);r?r.add(t):this.classToIds.set(e.__class,new Set([t]))}}removeFromNodeIndexes(t,e){this.classToIds.get(e.__class)?.delete(t)}markInTree(t,e,r){if(t.inTree&&(e.inTree||(e.inTree=!0,this.inTreeCount+=1,this.addToNodeIndexes(r,e)),t.isMaster?e.inMaster=t.id:e.inMaster=t.inMaster,!!e.childrenById))for(let n of e.childrenById.keys()){let i=this.getNodeData(n);m(i,"child not in tree, id: ",n),!i.inTree&&this.markInTree(e,i,n)}}clearInTree(t,e){if(t.inTree&&(t.inTree=!1,this.inTreeCount-=1,this.removeFromNodeIndexes(e,t),!!t.childrenById))for(let r of t.childrenById.keys()){let n=this.getNodeData(r);m(n,"child not in tree, id: ",r),n.inTree&&this.clearInTree(n,r)}}applyIsMaster(t,e){if(t.childrenById)for(let r of t.childrenById.keys()){let n=this.getNodeData(r);m(n,"child not in tree, id: ",r),n.inMaster=e,this.applyIsMaster(n,e)}}updateParent(t,e,r,n,i){let s=this.getParentBySeq(t,r,!0),a=s?ye(s.value):void 0;a&&a!==N&&this.removeChild(a,e);let d=ye(n);if(d!==N){let c=this.ensureNodeData(d);this.addChild(c,e,i),this.markInTree(c,t,e)}else this.clearInTree(t,e)}getChildrenRowIndices(t){let e=this.getNodeData(t);if(!e?.childrenById)return[];if(e.childrenSorted)return e.childrenSorted;let r=this.table.columns,n=Array.from(e.childrenById.values());return n.sort((i,s)=>{let a=this.getHierarchyKey(r.id.get(i));m(a!==N,"deleted child in hierarchy, row",i);let d=this.getHierarchyKey(r.id.get(s));if(m(d!==N,"deleted child in hierarchy, row",s),a<d)return-1;if(a>d)return 1;let c=r.seq.get(i),u=r.seq.get(s),l=r.client.get(i),h=r.client.get(s);return io(c,l,u,h)?-1:1}),e.childrenSorted=n,n}getChildrenIds(t){return this.getChildrenRowIndices(t).map(e=>this.table.columns.id.get(e))}updateLatestValue(t,e,r){switch(e){case"__class":{if(typeof r!="string")return;let n=this.ensureNodeData(t);if(r==="RootNode"&&(this.rootNodeId=t,n.inTree=!0,n.childrenById))for(let i of n.childrenById.keys()){let s=this.getNodeData(i);s&&this.markInTree(n,s,i)}if(n.__class!==r&&n.inTree&&n.__class&&this.classToIds.get(n.__class)?.delete(t),n.__class=r,n.inTree){let i=this.classToIds.get(r);i?i.add(t):this.classToIds.set(r,new Set([t]))}break}case"isMaster":{if(typeof r!="boolean")return;let n=this.ensureNodeData(t);n.isMaster=r,n.inTree&&n.isMaster&&this.applyIsMaster(n,t);break}case"replicaInfo":{let n=this.store.getReferenceValue(r,1,0);if(!n||typeof n!="object")return;let i=n.master;if(typeof i!="string")return;let s=this.masterIdToReplicaIds.get(i);s?s.add(t):this.masterIdToReplicaIds.set(i,new Set([t]));let a=this.ensureNodeData(t);a.replicaInfoMaster=i,a.replicaInfo=void 0;break}}}updateParentId(t,e){let r=this.ensureNodeData(t),n=r.resolvedParentId,i=this.table.columns,s=i.seq.get(e),a=i.client.get(e);if(n===void 0||io(s,a,i.seq.get(n),i.client.get(n))){let c=i.value.get(e);r.resolvedParentId=e,this.updateParent(r,t,s,c,e)}r.parentIdHistory.push(e),this.parentHistory.push(e)}getParentRowIdx(t){return this.getNodeData(t)?.resolvedParentId}getParentIdSeq(t){let e=this.getParentRowIdx(t);if(e!==void 0)return this.table.columns.seq.get(e)}getHierarchyKey(t){let e=this.getParentRowIdx(t);if(e===void 0)return;let r=this.table.columns.seq.get(e),n=this.table.columns.client.get(e);return this.parentOverrides.get(t)?.get(r)?.get(n)?.parentTo??this.table.columns.value.get(e)}getChildPosition(t){let e=this.getHierarchyKey(t);if(e!==void 0)return Di(e)}getParentId(t){let e=this.getHierarchyKey(t);if(e!==void 0)return ye(e)}getParentBySeq(t,e,r){let n,i=t.parentIdHistory;if(!i.length)return n;let s=this.table.columns;for(let a of i){let d=s.seq.get(a);if(d>e||!r&&d===e)continue;let c=s.client.get(a);if(!n||d>n.seq||d===n.seq&&c>n.client){let u=s.id.get(a),l=this.parentOverrides.get(u)?.get(d)?.get(c);n={id:u,seq:d,client:c,key:"parentid",value:l?.parentTo??s.value.get(a),index:a}}}return n}getSortedParentsBySeq(t,e,r){let n=[],i=t.parentIdHistory;if(!i?.length)return n;let s=this.table.columns;for(let a of i){let d=s.seq.get(a);if(d>e||!r&&d===e)continue;let c=s.id.get(a),u=s.client.get(a),l=this.parentOverrides.get(c)?.get(d)?.get(u);n.push({id:c,seq:d,client:u,key:"parentid",value:l?.parentTo??s.value.get(a),index:a})}return n.sort((a,d)=>a.seq===d.seq?d.client-a.client:d.seq-a.seq),n}isAncestorOf(t,e,r,n=new Set){if(t===e)return!0;if(!t||t===N||n.has(t))return!1;n.add(t);let i=this.getNodeData(t);if(!i)return!1;let s=this.getParentBySeq(i,r,!0);if(!s)return!1;let a=this.parentOverrides.get(t)?.get(s.seq)?.get(s.client)?.parentTo??s.value,d=ye(a);return this.isAncestorOf(d,e,r,n)}clearParentOverrides(t){let e=[];for(let[r,n]of this.parentOverrides)for(let[i,s]of n)if(!(i<t)){for(let[a,d]of s){let c=d.rowIdx,u=this.getNodeData(r);if(!u||!(u.resolvedParentId===c))continue;e.push(d);let h=ye(d.parentTo);h!==N&&this.removeChild(h,r);let g=ye(d.parentFrom);if(g!==N){let y=this.ensureNodeData(g);this.addChild(y,r,c),this.markInTree(y,u,r)}else this.clearInTree(u,r)}n.delete(i)}return e}createOverrideHierarchyKey(t){let e=Di(t),r=ye(t);m(r!==N,"deleted parentid, cannot override hierarchyKey");let n=gr(e);n[n.length-1].client=iu;let i=Ct(n);return no(r,i)}resolveCycles(t){let e=this.clearParentOverrides(t),r=[],n=this.table.columns;this.parentHistory.sort((i,s)=>{let a=n.seq.get(i),d=n.seq.get(s);return a===d?n.client.get(i)-n.client.get(s):a-d});for(let i of this.parentHistory){let s=n.id.get(i),a=n.seq.get(i);if(a<t)continue;let d=n.value.get(i);m(d,"parentid without a value, index: ",i);let c=ye(d);if(this.isAncestorOf(c,s,a)){let u=this.getNodeData(s);m(u,"node not in tree, id: ",s);let l=this.getSortedParentsBySeq(u,a,!1),h;for(let R of l){let E=ye(R.value);if(!this.isAncestorOf(E,s,a)){h=R;break}}if(u.resolvedParentId===i){let R=this.getParentId(s);if(m(R&&R!==N,"unable to resolve parent of",s),this.removeChild(R,s),h&&h.value!==N){let E=ye(h.value),D=this.ensureNodeData(E);this.addChild(D,s,h.index),this.markInTree(D,u,s)}else this.clearInTree(u,s)}let b={nodeId:s,parentFrom:d,parentTo:h&&h.value!==N?this.createOverrideHierarchyKey(h.value):N,rowIdx:i},v=this.parentOverrides.get(s);v||(v=new Map,this.parentOverrides.set(s,v));let C=v.get(a);C||(C=new Map,v.set(a,C));let w=n.client.get(i);C.set(w,b),r.push(b)}}return{prevOverrides:e,nextOverrides:r}}};var so=class{constructor(){f(this,"map",new Map);f(this,"nodeData")}keys(){return this.map.keys()}values(){return this.map.values()}entries(){return this.map.entries()}has(t){return this.map.has(t)}get(t){return this.map.get(t)}set(t,e){this.map.set(t,e)}},ao=class{constructor(){f(this,"map",new Map)}values(){return this.map.values()}create(t){let e=new so;return this.map.set(t,e),e}set(t,e,r){let n=this.map.get(t);n||(n=new so,this.map.set(t,n)),n.set(e,r)}getLatest(t){return this.map.get(t)}get(t,e){return this.getLatest(t)?.get(e)}clear(){this.map.clear()}};var co=class{constructor(t){f(this,"seqs",[]);f(this,"idxs",[]);f(this,"maxSize");this.maxSize=t?.maxSize}clear(){this.seqs=[],this.idxs=[]}get(t){let e=this.seqs.length;if(e===0)return 0;let r=lc(this.seqs,t);return r<e&&this.seqs[r]===t?this.idxs[r]:0}add(t,e){if(this.maxSize&&this.seqs.length>=this.maxSize&&this.seqs[0]>t)return;let i=lc(this.seqs,t);if(i<this.seqs.length&&this.seqs[i]===t){e<this.idxs[i]&&(this.idxs[i]=e,this.propagateLeftFrom(i));return}this.seqs.splice(i,0,t),this.idxs.splice(i,0,e),i+1<this.idxs.length&&(this.idxs[i]=Math.min(this.idxs[i],this.idxs[i+1])),this.propagateLeftFrom(i),this.evict()}evict(){if(this.maxSize){let t=this.seqs.length-this.maxSize;t>0&&(this.seqs.splice(0,t),this.idxs.splice(0,t))}}propagateLeftFrom(t){let e=this.idxs[t];for(let r=t-1;r>=0&&!(this.idxs[r]<=e);r--)this.idxs[r]=e}__snapshot(){return this.seqs.map((t,e)=>({seq:t,idx:this.idxs[e]}))}};function lc(o,t){let e=0,r=o.length;for(;e<r;){let n=e+r>>>1;o[n]<t?e=n+1:r=n}return e}var lo=class{constructor(t,e){this.table=t;this.latest=e;f(this,"sortedIndicesCache",new Map)}isSortableArray(t){let e=this.latest.getLatest(t);if(!e)return!1;let r=Array.from(e.values());if(!r.length)return!1;let n=this.table.columns;if(r.length===1)return n.key.get(r[0])===re;for(let i of r){let s=n.value.get(i);if(s!==N&&s!==ie)return Qd(s)}return!0}getIndices(t){let e=this.sortedIndicesCache.get(t);if(e)return e;let r=this.latest.getLatest(t);if(!r)return[];let n=this.table.columns,s=Array.from(r.values()).filter(a=>{let d=n.key.get(a),c=n.value.get(a);return d!==re&&c!==N}).sort((a,d)=>{let c=n.value.get(a),u=n.value.get(d);return c<u?-1:c>u?1:0});return this.sortedIndicesCache.set(t,s),s}invalidate(t){this.sortedIndicesCache.delete(t)}unsetItem(t,e,r){let n=this.getIndices(t);if(!n)return;let i=this.latest.get(t,e),s=i!==void 0?n.indexOf(i):-1;s===r&&n.splice(s,1)}clear(){this.sortedIndicesCache.clear()}};function Li(o,t){let e=o.length,r=t.length,n=Array.from({length:e+1},()=>new Array(r+1).fill(0));for(let d=e-1;d>=0;--d)for(let c=r-1;c>=0;--c)o[d]===t[c]?n[d][c]=n[d+1][c+1]+1:n[d][c]=Math.max(n[d+1][c],n[d][c+1]);let i=[],s=0,a=0;for(;s<e&&a<r;)o[s]===t[a]?(s+=1,a+=1):n[s+1][a]>n[s][a+1]?(i.push({operation:"delete",index:s,value:o[s]}),s+=1):(i.push({operation:"insert",index:a,value:t[a]}),a+=1);for(;s<e;)i.push({operation:"delete",index:s,value:o[s]}),s+=1;for(;a<r;)i.push({operation:"insert",index:a,value:t[a]}),a+=1;return i}function uo(o){return typeof o=="object"&&o!==null&&!Array.isArray(o)}var vr="meta",br={ROOT_ID:"rootId",VERSION:"version"};function io(o,t,e,r){return o===e?t>r:o>e}function su(o,t){return o.seq===t.seq?o.client-t.client:o.seq-t.seq}function uc(o){if(!Array.isArray(o)||o.length===0)return!1;let t,e=new Set,r=!1;for(let n of o){if(typeof n!="object"||n===null)return!1;pc(n)&&(r=!0);let i=typeof n.id=="string"?"id":typeof n.identifier=="string"?"identifier":void 0;if(!i)return!1;t&&m(t===i,"Mergeable arrays must have consistent id/identifier",JSON.stringify(o)),t=i;let s=n[t];if(!s)return!1;r||m(!e.has(s),"Mergeable arrays must have unique ids.",JSON.stringify(o)),e.add(s)}return!0}function au(o){return"key"in o||"offset"in o&&"style"in o}function du(o){return"_id"in o||"field"in o&&"text"in o}function pc(o){return"__class"in o&&o.__class==="PathSegment"}function cu(o){return o.every(t=>typeof t=="object"&&t!==null&&(au(t)||du(t)||pc(t)))}function lu(o){m(!o.some(t=>typeof t=="object"&&t!==null)||cu(o),"Atomic arrays must only contain primitives.",JSON.stringify(o))}function hc(o){return typeof o=="string"&&o.startsWith("arr(")}function fc(o){if(hc(o))return o.slice(4,-1)}function mc(o){return`arr(${o})`}function Ut(o){if(typeof o=="string"&&o.startsWith("obj("))return o.slice(4,-1)}function ki(o){return`obj(${o})`}function uu(o,t,e=0){let r={},n=r;for(let s=e;s<o.length-1;++s){let a=o[s];n[a]={},n=n[a]}let i=o[o.length-1];return n[i]=t,r}function Pi(o){return`${o.client}/${o.seq}/${o.id}/${o.key}/${JSON.stringify(o.value)}/${o.batch}`}var nt=class o{constructor({client:t,user:e,strictAtomicArrays:r=!0}){f(this,"_seq",0);f(this,"table",new Bt);f(this,"latest",new ao);f(this,"hierarchy");f(this,"sortedArrayCache");f(this,"minIndexCache",new co({maxSize:1e3}));f(this,"client");f(this,"user");f(this,"strictAtomicArrays");f(this,"getIdFromObject");f(this,"batchStartIdx");f(this,"batchNo",0);f(this,"readTransactionLevel",0);f(this,"foundIds",new Set);this.client=t,this.user=e,this.strictAtomicArrays=r,this.reset()}reset(){this._seq=0,this.batchNo=0,this.batchStartIdx=void 0,this.table=new Bt,this.latest.clear(),this.minIndexCache.clear(),this.hierarchy=new Kr(this,this.table,this.latest),this.sortedArrayCache=new lo(this.table,this.latest)}fromBuffer(t){this.reset(),this.table.fromBuffer(t),this.indexRowsOptimized(),this.hierarchy.resolveCycles(0)}toBuffer(t){return(t?.compact?this.compact():this).table.toBuffer()}setRoot(t){this.setObjectKey(vr,br.ROOT_ID,t)}getRoot(){return this.getCurrentValue(vr,br.ROOT_ID)}getVersion(){return this.getCurrentValue(vr,br.VERSION)}setVersion(t){this.setObjectKey(vr,br.VERSION,t)}isRoot(t){return this.getCurrentValue(vr,br.ROOT_ID)===t}get seq(){return this._seq}getSerializableRows(t,e){return this.table.getSerializableRows(t,e)}getRows(t,e){return this.table.getRows(t,e)}getRowsSorted(){return this.getRows().sort(su)}getFirstRowForSeq(t){return this.minIndexCache.get(t)}indexRowsOptimized(){let{client:t,id:e,key:r,seq:n,value:i,batch:s}=this.table.columns;for(let a=this.length-1;a>=0;a--)this.updateRowIndex(a,n.get(a),e.get(a),r.get(a),i.get(a),t.get(a),s.get(a))}clone(t){let e=new o({client:t??this.client,user:this.user,strictAtomicArrays:this.strictAtomicArrays});return e.fromBuffer(this.toBuffer()),e.getIdFromObject=this.getIdFromObject,e}merge(t){return this.mergeRows(t.getRows())}mergeRows(t){let e=new Set(this.getRows().map(i=>Pi(i))),r=1/0,n=!1;for(let i of t){i.key==="parentid"&&(n=!0);let s=Pi(i);e.has(s)||(e.add(s),this.addRowData(i.id,i.key,i.value,i.client,i.seq,i.user,i.batch),r=Math.min(r,i.seq))}return this.sortedArrayCache.clear(),n&&this.hierarchy.resolveCycles(r),r}append(t){return this.addRows(t.getRows())}addSerializableRows(t){let e=1/0,r=!1;for(let n of t){n.key==="parentid"&&(r=!0);let i=n.value;Me(i)&&(i=Ve(i)),this.addRowData(n.id,n.key,i,n.client,n.seq,n.user,n.batch),e=Math.min(e,n.seq)}this.sortedArrayCache.clear(),r&&this.hierarchy.resolveCycles(e)}addRows(t){let e=1/0,r=!1;for(let i of t)i.key==="parentid"&&(r=!0),this.addRowData(i.id,i.key,i.value,i.client,i.seq,i.user,i.batch),e=Math.min(e,i.seq);this.sortedArrayCache.clear();let n;return r&&(n=this.hierarchy.resolveCycles(e)),{minSeq:e,cycleResolutions:n}}batch(t){m(this.batchStartIdx===void 0,"You cannot nest batches");let e=this.table.columns;this.batchStartIdx=e.client.length;try{let r=t(),n=e.client.length-this.batchStartIdx;if(n===0)return r;this.batchNo++;let i=yr({batchNo:this.batchNo,rowCount:n});for(let s=this.batchStartIdx;s<this.batchStartIdx+n;s++)e.batch.add(i);return r}finally{this.batchStartIdx=void 0}}updateKeyValue(t,e,r){if(this.batchStartIdx===void 0){this.batch(()=>{this.updateKeyValue(t,e,r)});return}this.addRowData(t,e,r,this.client,this._seq,this.user)}addRowData(t,e,r,n,i,s,a){if(!this.shouldAddRow(t,e,r,i,n))return;let d=this.table.columns;d.client.add(n),d.seq.add(i),d.id.add(t),d.key.add(e),d.value.add(r),d.user.add(s),a&&d.batch.add(a);let c=d.client.length-1;this.updateRowIndex(c,i,t,e,r,n,a)}shouldAddRow(t,e,r,n,i){let s=e==="parentid"?this.hierarchy.getParentRowIdx(t):this.latest.get(t,e);if(s===void 0)return!0;let a=this.table.columns;if(a.value.get(s)!==r)return!0;let c=a.seq.get(s),u=a.client.get(s);return!(c===n&&u===i)}updateRowIndex(t,e,r,n,i,s,a){if(e>=this._seq&&(this._seq=e+1),a!==void 0&&s===this.client){let u=Ti(a);this.batchNo=Math.max(this.batchNo,u)}if(r===bt)return;let d=this.latest.get(r,n),c=this.table.columns;if(n==="parentid"){if(!ro(i))return;this.hierarchy.updateParentId(r,t)}else(d===void 0||io(e,s,c.seq.get(d),c.client.get(d)))&&(this.latest.set(r,n,t),this.hierarchy.updateLatestValue(r,n,i));this.sortedArrayCache.invalidate(r),this.minIndexCache.add(e,t)}getParentId(t){return this.hierarchy.getParentId(t)}getHierarchy(){return this.hierarchy}_getIdFromObject(t){return this.getIdFromObject?.(t)}createStoreId(t,e){return`${t}.${e}`}getReferenceValue(t,e,r){if(Array.isArray(t))return t.map(s=>this.getReferenceValue(s,e,r));let n=fc(t);if(n)return this.getMergeableArray(n,!0,e,r);let i=Ut(t);return i?this.getObjectInner(i,!0,e,r):t}getCurrentValue(t,e){if(e==="parentid")return this.hierarchy.getParentId(t);let r=this.latest.get(t,e);if(r!==void 0)return this.table.columns.value.get(r)}getParentIdSeq(t){return this.hierarchy.getParentIdSeq(t)}validateObjectUpdate(t,e){if(!uo(e))throw new Error("Store.setObject: object is not an object");let r=this._getIdFromObject(e);if(r&&r!==t)throw new Error(`Store.getIdFromObject mismatch: ${r} !== ${t}: The id that we got to update the object is not equal to the result of getIdFromObject. See Store.update.test.ts`);return t}deleteRemovedKeys(t,e){let r=this.latest.getLatest(t);if(r)for(let n of r.keys())n!==re&&(n in e||this.setObjectKey(t,n,N))}createHierarchyKey(t,e,r=-1){let n=this.hierarchy.getChildrenRowIndices(e),i=this.table.columns,s=n.findIndex(b=>i.id.get(b)===t);s>=0&&r>s&&(r+=1),r=r===-1?n.length:r;let a=r<0?Math.max(n.length+r,0):Math.min(r,n.length),d=a>0?n[a-1]:void 0,c=n[a],u=d!==void 0?i.id.get(d):void 0,l=c!==void 0?i.id.get(c):void 0,h=u?this.hierarchy.getChildPosition(u):void 0,g=l?this.hierarchy.getChildPosition(l):void 0,y=eo(h,g,this.client);return no(e,y)}ensureHasChildren(t){this.getCurrentValue(t,"children")!==ie&&this.setObjectKey(t,"children",ie)}insertNode(t,e,r){m(typeof t?.id=="string","inserting node without a valid id"),this.setObject(t.id,t),this.ensureHasChildren(e);let n=this.createHierarchyKey(t.id,e,r);this.setObjectKey(t.id,"parentid",n)}removeNode(t){m(this.latest.get(t,"id")!==void 0,"trying to remove a node that doesn't exist:",t),this.setObjectKey(t,"parentid",N)}updateNode(t,e){m(this.latest.get(t,"id")!==void 0,"trying to update a node that doesn't exist:",t);for(let r in e)r!=="parentid"&&this.setObjectKey(t,r,e[r])}updateNestedObject(t,e){let[r,...n]=t;m(this.latest.get(r,"id")!==void 0,"trying to update nested properties on node doesn't exist:",r);for(let i in e)i!=="parentid"&&this.setObjectKeyPath(r,[...n,i],e[i])}moveNode(t,e,r){m(this.latest.get(t,"id")!==void 0,"trying to move a node that doesn't exist:",t),this.ensureHasChildren(e);let n=this.createHierarchyKey(t,e,r);this.setObjectKey(t,"parentid",n)}setObject(t,e){let r=this.validateObjectUpdate(t,e);if(this.deleteRemovedKeys(r,e),Object.keys(e).length===0){this.setObjectKey(r,re,ie);return}for(let n in e)n==="children"||n==="parentid"||this.setObjectKey(r,n,e[n]);if(!(!("children"in e)||!Array.isArray(e.children))){this.setObjectKey(r,"children",ie);for(let n of e.children)this.insertNode(n,r)}}resolveObjectInArrayReference(t,e,r){let n=this._getIdFromObject(e);if(n===void 0){let i;typeof e.id=="string"?i=e.id:typeof e.identifier=="string"?i=e.identifier:i=`__${r}_${this.client.toString(36)}`,n=this.createStoreId(t,i)}return this.setObject(n,e),ki(n)}createAtomicArray(t,e){let r=[];for(let n=0;n<e.length;n++){let i=e[n];if(uo(i))r.push(this.resolveObjectInArrayReference(t,i,n));else if(uc(i)){let s=this.createStoreId(t,n.toString());this.setMergeableArray(s,i),r.push(mc(s))}else Array.isArray(i)?r.push(this.createAtomicArray(t+"."+n.toString(),i)):r.push(i)}return r}setObjectKey(t,e,r){let n=this.getCurrentValue(t,e);if(uo(r)){let a=Ut(n),d=a??this._getIdFromObject(r)??this.createStoreId(t,e);this.setObject(d,r),a||this.updateKeyValue(t,e,ki(d));return}if(!Array.isArray(r)){n!==r&&this.updateKeyValue(t,e,r);return}if(uc(r)||r.length===0&&hc(n)){let a=fc(n),d=a??this.createStoreId(t,e);this.setMergeableArray(d,r),a||this.updateKeyValue(t,e,mc(d));return}this.strictAtomicArrays&&lu(r);let i=this.createStoreId(t,e),s=this.createAtomicArray(i,r);this.updateKeyValue(t,e,s)}setObjectKeyPath(t,e,r){if(!e[0])return;let n=t;for(let s=0;s<e.length-1;++s){let a=e[s],d=this.getCurrentValue(n,a);if(d===N){let u=uu(e.slice(s+1),r);this.setObjectKey(n,a,u);return}d||(this.setObjectKey(n,a,{}),d=this.getCurrentValue(n,a));let c=Ut(d);if(!c){let u=e.slice(0,s+1);throw new Error(`${u.join(".")} is not an object`)}n=c}let i=e[e.length-1];this.setObjectKey(n,i,r)}getChildrenIds(t){return this.hierarchy.getChildrenIds(t)}getObjectKey(t,e){if(this.getCurrentValue(t,re)!==N)return this.getReferenceValue(this.getCurrentValue(t,e),1/0,0)}getNodeValueForRow(t,e,r){if(e==="parentid")return this.hierarchy.getParentId(t);let n=this.table.columns.value.get(r);return n===N?N:this.getReferenceValue(n,1/0,0)}getObject(t){return this.getObjectInner(t,!0)}getObjectWithShallowChildren(t,e){return this.getObjectInner(t,!0,e,0)}getObjectInner(t,e,r=1/0,n=0){this.readTransactionLevel++;let i=()=>{this.readTransactionLevel--,this.foundIds.delete(t)};if(this.foundIds.has(t)){i();return}this.foundIds.add(t);let s=this.latest.getLatest(t);if(!s&&this.hierarchy.getParentRowIdx(t)===void 0){i();return}let a={},d=this.table.columns;if(this.getCurrentValue(t,re)===N){i();return}if(n<r&&s?.has("children")){let c=this.getChildrenIds(t);a.children=e?c.map(u=>this.getObjectInner(u,!0,r,n+1)):c}if(this.isRoot(t))a.parentid=null;else{let c=this.getParentId(t);c&&(a.parentid=c)}if(s)for(let[c,u]of s.entries()){if(c===re||u===void 0)continue;let l=d.value.get(u);l!==N&&(c==="children"||c==="parentid"||(a[c]=e?this.getReferenceValue(l,r,n+1):l))}return i(),this.readTransactionLevel===0&&this.foundIds.clear(),a}applyArrayEdits(t,e,r){let n=new Set(r),i=0;for(let s of e){let a=Ut(s.value);switch(s.operation){case"delete":n.has(s.value)?this.sortedArrayCache.unsetItem(t,a,s.index+i):this.updateKeyValue(t,a,N),i--;break;case"insert":this.arrayInsert(t,a,s.index),i++;break}}}setMergeableArray(t,e){let r=this.getMergeableArray(t,!1);if(!r){let s=this.latest.getLatest(t)?.keys()??[];for(let a of s)this.updateKeyValue(t,a,N);this.updateKeyValue(t,re,ie),r=[]}let n=[];for(let s=0;s<e.length;s++)n.push(this.resolveObjectInArrayReference(t,e[s],s));let i=Li(r,n);this.applyArrayEdits(t,i,n)}getMergeableArray(t,e=!0,r=1/0,n=0){if(!this.sortedArrayCache.isSortableArray(t))return;let i=this.sortedArrayCache.getIndices(t),s=this.table.columns;if(e){let a=[];for(let d of i){let c=s.key.get(d),u=this.getObjectInner(c,!0,r,n+1);u&&a.push(u)}return a}else return i.map(a=>ki(s.key.get(a)))}arrayInsert(t,e,r){let n=this.sortedArrayCache.getIndices(t),i=r<0?Math.max(n.length+r,0):Math.min(r,n.length),s=this.table.columns,a=i>0?n[i-1]:void 0,d=a!==void 0?s.value.get(a):void 0,c=n[i],u=c!==void 0?s.value.get(c):void 0,l=eo(d,u,this.client);this.updateKeyValue(t,e,l)}get length(){return this.table.columns.client.length}static verifyBatches(t){let e=new Map,r=new Set;for(let n of t){let i=Pi(n);if(r.has(i))continue;r.add(i);let s=e.get(n.client);s||(s=new Map,e.set(n.client,s));let a=s.get(n.batch)??0;s.set(n.batch,a+1)}for(let[n,i]of e)for(let[s,a]of i){let{rowCount:d}=Ii(s);m(d===a,"Update row count does not match batch row count. Batch:",s,"Update count:",a,"Batch count:",d)}}compact(){let t=new o({user:this.user,client:this.client,strictAtomicArrays:this.strictAtomicArrays}),e=this.table.columns,r=[];for(let i=0;i<e.client.length;i++)e.key.get(i)==="parentid"&&r.push(i);for(let i of this.latest.values())for(let[s,a]of i.entries())s!=="parentid"&&r.push(a);let n=r.map(i=>({client:e.client.get(i),seq:e.seq.get(i),id:e.id.get(i),key:e.key.get(i),value:e.value.get(i),user:e.user.get(i),batch:e.batch.get(i)}));return t.addRows(n),t._seq=this._seq,t}};function Mi(o,t=!0){let e=Ja(t),r=new nt({client:e,user:o});return r.getIdFromObject=n=>n.__class&&Or(n.__class)?n.id:void 0,r}function fo(o){if(!o.children)return;let t=new Map;for(let e of o.children)Xt(e)&&t.set(e.id,{master:e,replicas:new Map});for(let e of o.children){if(!lt(e))continue;let r=t.get(e.replicaInfo.master);r&&r.replicas.set(e.id,e)}for(let{master:e,replicas:r}of t.values())fu(e,r)}function fu(o,t){for(let e of t.values()){let r=e.replicaInfo;m(r.master===o.id,"Replica must match master");let n=r.overrides;if(r.inheritsFrom){let l=t.get(r.inheritsFrom);l&&(n=Hs(n,l.replicaInfo.overrides))}let i=n[o.id],s=e.duplicatedFrom;tr.copyToNode(e,o,i),e.duplicatedFrom=s;let a=!1;Ds(e)&&(a=!0,Js(e,n,o),Wo(o,e));let d=e.id,c=o.children;if(!c)return;let u=new Array(c.length);for(let l=0,h=c.length;l<h;l++)u[l]=gc(d,n,c[l],d,a);e.children=u}}function gc(o,t,e,r,n){let i=pt({__class:e.__class,id:o+e.id,parentid:r});m(i,"Failed to create replica node");let s=t[e.id];if(tr.copyToNode(i,e,s),i.duplicatedFrom=null,n&&Wo(e,i),e.children){let a=e.children,d=new Array(a.length);for(let c=0,u=a.length;c<u;c++)d[c]=gc(o,t,a[c],i.id,n);i.children=d}return i}function yc(o,t){let e=new Set;for(let r of t){if(r.removed&&(o.removeNode(r.id),e.add(r.id)),r.added){let n={...r.to};n.id=r.id,n.__class=r.added;let i=Pa(n.__class);i&&Zs(i)&&(n.children=[]),o.insertNode(n,n.parentid,r.position);continue}if(r.to.parentid||r.position!==r.fromPosition){let n=r.to.parentid??o.getParentId(r.id);n&&n!==N&&o.moveNode(r.id,n,r.position)}}for(let r of t)if(!(r.added||r.removed||e.has(r.id)))if(Aa(r.id)){let{_deleted:n,...i}=r.to;for(let d of n??[])i[d]=N;let[s,a]=Fa(r.id);m(s&&a),o.updateNestedObject([s,"replicaInfo","overrides",a],i)}else{let{_deleted:n,...i}=r.to;for(let s of n??[])i[s]=void 0;delete i.parentid,Object.keys(i).length&&o.updateNode(r.id,i)}}function mo(o){return typeof o=="object"&&!Array.isArray(o)&&o!==null}function vc(o,t){if(!mo(o)&&mo(t))return Object.assign({},t);if(!mo(o)||!mo(t))return t;for(let e of Object.keys(t))o[e]=vc(o[e],t[e]);return o}function Vi(o,...t){let e=o;for(let r of t)e=vc(e,aa(r));return e}function bc(o){return o===void 0}function mu(o,t,e){let r=e.replicaInfo;if(r?.master){let s=o.get(r.master);if(!s||!Xt(s))return!0}if(r?.inheritsFrom){let s=o.get(r.inheritsFrom);if(!s||!(lt(s)||Xt(s)))return!0}let n=e.parentid;if(!n)return!1;let i=o.get(n);return i?o.isAncestorOfNode(i,t):!0}function pu(o,t,{children:e,...r}){if(m(!o.has(t),"Tree must not have node",t),!r.parentid)return null;let n=o.get(r.parentid);if(!n||kt(n)&&!n.isLoaded())return null;let i=r.__class;if(!i)throw new Error("Unknown node class for: "+t);let s=Or(i);if(!s)throw new Error("Unknown node class for: "+t);let a=r.replicaInfo;if(a){let c=o.get(a.master);if(!c||!Xt(c))throw Error("broken diff, replica without master: "+t+" "+a.master);let u=Va(a),l=Sn.create(o,c,{overrides:u?.overrides,owner:t,inheritsFrom:u?.inheritsFrom,duplicatedFrom:r.duplicatedFrom,fromDiff:!0});return l.parentid=r.parentid,o.insertNode(l,l.parentid),l}if(Ma(s)){m(ia(t),"Invalid EntityReferenceNode ID: "+t);let c=new s({...Xo(r),id:t});return o.insertNode(c,c.parentid),c}let d=new s({...Xo(r),id:t});return o.insertNode(d,d.parentid),d}function hu(o,t){o.has(t)&&o.remove(t)}function gu(o,t,{children:e,...r}){let n=o.get(t);if(!n)return null;if(r.parentid&&n.parentid!==r.parentid){if(!o.has(r.parentid))return o.remove(t),null;o.move(t,r.parentid)}let i=n.asDraft(o);for(let s in r){let a=i[s];s==="replicaInfo"||typeof a!="object"||Array.isArray(a)||a===null||(r[s]=Vi({},a,r[s]))}if(r.replicaInfo&&lt(n)){let{overrides:s,_deleted:a,...d}=r.replicaInfo;for(let u in s){let l=s[u],h=i.replicaInfo?.overrides[u];h!==null&&typeof h=="object"&&!Array.isArray(h)&&(l=Vi({},h,l)),l&&Ua(o,i,u,l)}let c=Object.assign(i.replicaInfo,d);return tr.updateNode(o,i,r),i.replicaInfo=c,i.cache.rebuildReplica=!0,i}else return tr.updateNode(o,n,r),i}function yu(o,t){if(o.length!==t.length)return!1;for(let e=0;e<o.length;e++)if(o[e].id!==t[e])return!1;return!0}function vu(o,t,e){if(yu(t.children,e))return;let r=[];for(let s=0,a=e.length;s<a;s++){let d=o.get(e[s]);d&&d.parentid===t.id&&r.push(d)}let n=new Set(e),i=t.children;for(let s=0,a=i.length;s<a;s++){let d=i[s];n.has(d.id)||r.push(d)}Ts(i,r)||(t.asDraft(o).children=r)}function Ai(o,t,e,r=!1){r||(o.applyingDiffs=!0);let n=Array.from(e.keys()),i=[...n];for(;i.length>0;){let s=[];for(let a of i){let d=e.get(a);bc(d)||(mu(o,a,d)?s.push(a):o.has(a)?gu(o,a,d):d.__class&&pu(o,a,d))}if(s.length===0||s.length===i.length)break;i=s}for(let s of n){let d=e.get(s)?.children;if(!d||d.length===0)continue;let c=o.get(s);if(c){if(!c.children)throw Error("assertion failure: node has no children");vu(o,c,d)}}for(let s of n){let a=e.get(s);bc(a)&&hu(o,s)}return r||(o.applyingDiffs=!1),r?o.commit(t):o.commitDiffs(t)}function Fi(o,t){let e=o.getParentId(t);for(;e&&e!==N;)e=o.getParentId(e);return e===N}function bu(o,t,e){let r=new Map;for(let[n,i]of t){if(Fi(o,n)){r.set(n,void 0);continue}let s=o.getObject(n);if(!s.__class||!Or(s.__class))continue;let a=o.isRoot(n),d={id:n,parentid:a?null:o.getParentId(n),children:o.getChildrenIds(n)??[]},c=e.has(n)?Object.keys(s).map(u=>[u]):i;for(let u of c){let l=d,h=s;for(let[g,y]of u.entries()){if(y==="parentid"||y==="children"||y===re)break;if(Array.isArray(l)){!l.length&&Array.isArray(h)&&l.push(...h);break}if(!(y in l))if(h?.[y]===void 0){l?._deleted||(l._deleted=[]),l._deleted.push(y);break}else if(g===u.length-1)l[y]=h[y];else{let v=Array.isArray(h[y]);l[y]=v?[]:{}}l=l[y],h=h[y]}}r.set(n,d),d.parentid&&(r.has(d.parentid)||r.set(d.parentid,{children:o.getChildrenIds(d.parentid)}))}return r}function Sc(o,t=0){let e=new Map,r=o.table.columns,n=o.getFirstRowForSeq(t);for(let i=n;i<r.client.length;++i){if(r.seq.get(i)<t)continue;let a=r.id.get(i),d=r.key.get(i),c=a.split("."),[u,...l]=c,h=e.get(u);h||(h=[],e.set(u,h)),l.push(d),h.push(l)}return e}function Su(o,t){let e=Sc(t),r=new Set;for(let[n,i]of e){let s=t.getParentIdSeq(n);if(s===void 0||t.getParentId(n)===N)continue;let d=o.getParentIdSeq(n);d!==void 0&&(d>s||Fi(o,n)&&r.add(n))}return r}function Cu(o,t){let e=[...t];for(let r of e)for(let n of o.getChildrenIds(r)??[])e.push(n);return new Set(e)}function Cc(o,t){if(t.length===0)return new Map;let e=Su(o,t),{minSeq:r,cycleResolutions:n}=o.append(t);if(n){for(let s of n.nextOverrides)e.add(s.nodeId);for(let s of n.prevOverrides)e.add(s.nodeId)}for(let s of Array.from(e))Fi(o,s)&&e.delete(s);e=Cu(o,e);let i=Sc(o,r);for(let s of e)i.has(s)||i.set(s,[]);return bu(o,i,e)}function Tc(o,t,e){let r=[];for(let n of e.keys()){let i=o.getNodeAtStart(n),s=t.getNodeAtStart(n);if(i===s)continue;let a=ht(i,s);a&&r.push(a),ir(r,i,s)}return r}var Qr=x("tree:crdt-committer"),Tu=6e4,Iu=6e4,Ui=class{constructor(t,e,r){this.tree=t;this.remoteVersion=e;this.containsLocalEdits=r}},po=class{constructor(t,e,r){this.componentLoader=e;f(this,"tree");f(this,"latestRemoteTree");f(this,"remoteTrees",[]);f(this,"lastSeqTaken",0);f(this,"hasLocalCommitSinceLastSync",!1);f(this,"oldestLocalCommitTime",0);f(this,"localOnlyChangesByChangeset",new Map);f(this,"store");f(this,"recorder");f(this,"remoteTreeVersion",0);f(this,"legacyMode",!1);f(this,"isPartialLoading",!1);f(this,"rollingDiff",null);f(this,"validationEnabled",!0);f(this,"onlineStartTime",0);f(this,"latestReversibleNodeChanges",null);f(this,"flagsForNextCommit");f(this,"extraChangesForNextCommit");f(this,"recentEditReasons",[]);f(this,"nodeChangesBuffers",new Set);f(this,"resetTime",0);f(this,"epoch",0);this.store=Mi(""),this.tree=t,this.latestRemoteTree=t,this.reset(t,r)}setOnline(t){this.onlineStartTime!==0!==t&&(this.onlineStartTime=t?performance.now():0)}get online(){return this.onlineStartTime!==0}reset(t,e){this.resetTime=performance.now(),Qr.debug("reset with tree:",t.root.id,"size:",t.size()),this.tree=t,this.latestRemoteTree=t,this.remoteTrees=[],this.recentEditReasons=[],this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,this.latestReversibleNodeChanges=null,this.remoteTreeVersion=0,this.hasLocalCommitSinceLastSync=!1,this.oldestLocalCommitTime=0,this.isPartialLoading=!!e?.isLoading,this.rollingDiff=this.isPartialLoading?new ur:null,this.rollingDiff?.addChanges(e?.initialChanges),this.invalidateAllCursors(),this.clearNodeChangesReader()}hasOnlyEmptyChangesForRemote(){if(!this.hasLocalCommitSinceLastSync)return!0;let t=this.store.getFirstRowForSeq(this.lastSeqTaken+1),e=this.store.getSerializableRows(t),r=this.lastSeqTaken;for(let n of e)if(n.client===this.store.client&&!(n.seq<=this.lastSeqTaken))return r<n.seq&&(r=n.seq),!1;return!0}resetLastSeqTaken(){this.lastSeqTaken=this.store.seq-1,Qr.debug("Reset last sent seq to current store length:",this.lastSeqTaken)}takePendingRows(t){if(this.oldestLocalCommitTime=0,!this.hasLocalCommitSinceLastSync)return[];this.hasLocalCommitSinceLastSync=!1;let e=this.store.getFirstRowForSeq(this.lastSeqTaken+1),r=this.store.getSerializableRows(e),n=this.lastSeqTaken,i=[];for(let s of r)s.client===this.store.client&&(s.seq<=this.lastSeqTaken||(n<s.seq&&(n=s.seq),i.push({...s,user:t})));return this.lastSeqTaken=n,i}getLastEntry(){let t=this.remoteTrees[this.remoteTrees.length-1];return m(t,"Timeline has no entries"),t}getEntry(t){return this.remoteTrees[t]}hasLocalEdits(){return this.hasLocalCommitSinceLastSync}getEditReasons(){let t=this.recentEditReasons.join(" ");return this.recentEditReasons=[],t}getTreeForVersion(t){return this.remoteTrees.findLast(e=>e.remoteVersion===t&&!e.containsLocalEdits)}recordHistoricTree(t,e){if(this.remoteTreeVersion=t,this.latestRemoteTree.getService("loader"))return;let r=this.hasLocalCommitSinceLastSync||e>0;this.remoteTrees.push(new Ui(this.latestRemoteTree,t,r));let n=120;if(this.remoteTrees.length>n){let i=this.remoteTrees.length-n,s=this.remoteTrees.splice(0,i);for(let a of s)a.tree.releaseMemory()}}handleRemotePatches(t,e,r){m(this.tree.isLatest(),"Tree must be latest");let n=this.tree,i=n.isViewOnly;n.editClosed=!1,n.isViewOnly=!1,n.beginAllowPartialScopeAccess();let s=Ai(n,this.componentLoader,t);s.beginAllowPartialScopeAccess();let a=Tc(n,s,t);for(let d of a)this.trackChange(d.id,d);for(let d of n.getNodesChangedByCommit())this.trackChange(d.id);if(this.tree=s,this.rollingDiff?.addChanges(a),this.latestRemoteTree!==n){this.latestRemoteTree.editClosed=!1,this.latestRemoteTree.isViewOnly=!1,this.latestRemoteTree.makeLatest(),this.latestRemoteTree.beginAllowPartialScopeAccess();let d=Ai(this.latestRemoteTree,this.componentLoader,t);this.latestRemoteTree.endAllowPartialScopeAccess(),this.latestRemoteTree=d,s.makeLatest()}else this.latestRemoteTree=s;return this.recordHistoricTree(e,r),n.endAllowPartialScopeAccess(),s.endAllowPartialScopeAccess(),m(!s.lineage.allowPartialNodeAccess,"Partial scope access should be disabled after commit"),s.isViewOnly=i,a}handleRemoteConfirm(t,e){this.recordHistoricTree(t,e),this.oldestLocalCommitTime=0}loadedAllScopes(t){m(this.isPartialLoading,"Must be in loading mode"),this.isPartialLoading=!1,this.rollingDiff=null,this.recordHistoricTree(this.remoteTreeVersion,t)}loadOneScope(t,e){Qr.debug("loadOneScope:",t.id);let r;this.latestRemoteTree!==this.tree&&(r=t.cloneWithIds()),m(this.isPartialLoading,"Must be loading"),m(!t.cache.isShallowLoad,"Scope must not be shallow"),m(this.tree.isLatest(),"Tree must be latest");let n=this.tree.isViewOnly;this.tree.editClosed=!1,this.tree.isViewOnly=!1,this.tree.inEditor=!1,this.tree.makeLatest();let i=new Set,s=this.tree.root.children.findIndex(c=>c.id===t.id);if(t.__class==="WebPageNode"||t.__class==="SmartComponentNode"){fo(t);let c=this.tree.commitWithLoadedScope(this.componentLoader,t);this.tree.inEditor=!0,this.tree=c;for(let u of t.walk())this.trackChange(u.id),i.add(u.id)}else this.tree.remove(t.id),this.tree.insertNode(t,this.tree.root.id,s);let a=this.rollingDiff?.getChanges()??[];i.size>0?sr(a,i)&&this.applyChanges(a):this.applyChanges(a),s===-1?m(!this.tree.get(t.id),"Scope must have been deleted by remote diffs"):this.tree.loadReplicasAndCodeComponents(t);let d=this.tree.commit(this.componentLoader,(c,u)=>{let l=c?.id??u?.id;l&&this.trackChange(l)});if(r){this.latestRemoteTree.editClosed=!1,this.latestRemoteTree.isViewOnly=!1,this.latestRemoteTree.makeLatest();let c=this.latestRemoteTree.root.children.findIndex(l=>l.id===r.id);t.__class==="WebPageNode"||t.__class==="SmartComponentNode"?this.latestRemoteTree=this.latestRemoteTree.commitWithLoadedScope(this.componentLoader,r):(this.latestRemoteTree.remove(t.id),this.latestRemoteTree.insertNode(r,this.tree.root.id,c)),this.latestRemoteTree.beginAllowPartialScopeAccess();let u=this.rollingDiff?.getChanges()??[];i.size>0?sr(u,i)&&Br(this.latestRemoteTree,u):Br(this.latestRemoteTree,u),c===-1?m(!this.latestRemoteTree.get(t.id),"Scope must have been deleted by remote diffs"):this.latestRemoteTree.loadReplicasAndCodeComponents(t),this.latestRemoteTree=this.latestRemoteTree.commit(this.componentLoader),this.latestRemoteTree.endAllowPartialScopeAccess(),d.makeLatest()}else this.latestRemoteTree=d;return this.tree.inEditor=!0,this.tree=d,this.tree.inEditor=!0,this.tree.isViewOnly=n,this.legacyMode&&this.invalidateAllCursors(),d}debugOverwriteCurrentTree(t){Qr.debug("debugOverwriteCurrentTree:",t.root.id),this.tree=t,this.remoteTrees.length>0&&(this.getLastEntry().tree=t),this.invalidateAllCursors()}saveTimelineDataForRecovery(){}setFlagsForNextCommit(t){this.flagsForNextCommit=t}setExtraChangesForNextCommit(t){this.extraChangesForNextCommit=t}recordEditReasons(t){t&&this.recentEditReasons.at(-1)!==t&&this.recentEditReasons.push(t)}getLatestChangesForUndo(){return this.latestReversibleNodeChanges}openNodeChangesReader(){return new lr(this.nodeChangesBuffers)}clearNodeChangesReader(){for(let t of this.nodeChangesBuffers)t.clear()}applyFlagsToChange(t){if(!t)return;let e=this.flagsForNextCommit;e&&(e.ignoreInUndo&&(t.ignoreInUndo=!0),e.ignoreInCodeGeneration&&(t.ignoreInCodeGeneration=!0))}updateLocalOnlyChanges(t){for(let e of t){let r=e.changesetId;if(!r)continue;let n=this.tree.lineage.getChangesetRecord(r);if(!n)continue;if(n.status==="discarded"||e.sync!==!1){this.localOnlyChangesByChangeset.delete(r);continue}if(!("from"in e))continue;let i=this.localOnlyChangesByChangeset.get(r)??[];i.push(e),this.localOnlyChangesByChangeset.set(r,i)}}syncChanges(t){this.localOnlyChangesByChangeset.size>0?(this.latestRemoteTree.makeLatest(),this.latestRemoteTree.editClosed=!1,Br(this.latestRemoteTree,t),this.latestRemoteTree=this.latestRemoteTree.commitDiffs(this.componentLoader),this.latestRemoteTree.editClosed=!0,this.tree.makeLatest()):this.latestRemoteTree=this.tree;let e=this.store.length;this.store.batch(()=>yc(this.store,t)),this.oldestLocalCommitTime===0&&e!==this.store.length&&(this.oldestLocalCommitTime=performance.now()),this.recorder&&this.recorder({source:"local",rows:this.store.getSerializableRows(e)})}trackChange(t,e=null){if(t)for(let r of this.nodeChangesBuffers)r.trackChange(t,e)}validateUpdatesAreSentToServer(){if(!this.validationEnabled||!this.online)return;let t=performance.now();if(t-this.onlineStartTime<Iu||this.oldestLocalCommitTime===0)return;let r=t-this.oldestLocalCommitTime;m(r<Tu,"Local changes not been processed in a while")}commitLocalTree(){this.validateUpdatesAreSentToServer();let t={},e=this.tree.lineage.getActiveChangeset(),r=this.tree.commit(this.componentLoader,(a,d)=>{if(!a&&!d)return;let c=ht(a,d,!0);this.trackChange(a?.id??d.id,null),c&&(t[c.id]=c);let u=[];ir(u,a,d);for(let l of u)t[l.id]=l}),n=[],i=new Map;for(let a of this.tree.hierarchyChanges){if(a.skip){a.type==="insert"?i.has(a.toParent)?i.delete(a.toParent):i.set(a.toParent,{offset:-1,position:a.toPosition}):a.type==="remove"?i.has(a.fromParent)?i.delete(a.fromParent):i.set(a.fromParent,{offset:1,position:a.fromPosition}):a.type==="move"&&i.set(a.toParent,{offset:-1,position:a.toPosition});continue}let d;if(a.type==="insert"){let c=t[a.node],u=0,l=i.get(a.toParent);l!==void 0&&a.toPosition>=l.position&&(u=l.offset),d={id:a.node,from:c.from,to:{...c.to,parentid:a.toParent},position:a.toPosition+u,added:c.added},delete t[a.node]}else if(a.type==="move"){let c=0,u=0,l=i.get(a.toParent);l!==void 0&&(c=a.toPosition>=l.position?l.offset:0,u=a.fromPosition>=l.position?l.offset:0),d={id:a.node,from:{parentid:a.fromParent},to:{parentid:a.toParent},fromPosition:a.fromPosition+u,position:a.toPosition+c}}else if(a.type==="remove"){let c=t[a.node],u=0,l=i.get(a.fromParent);l!==void 0&&a.fromPosition>=l.position&&(u=l.offset),d={id:a.node,from:{...c.from,parentid:a.fromParent},to:c.to,fromPosition:a.fromPosition+u,removed:c.removed},delete t[a.node]}else ae(a);n.push(d)}if(n.push(...Object.values(t)),this.extraChangesForNextCommit)for(let a of this.extraChangesForNextCommit)n.push(a);for(let a of n)this.applyFlagsToChange(a),this.trackChange(a.id,a),e&&this.tree.lineage.applyChangesetFlagsToChange(a,e.id);this.latestReversibleNodeChanges=n,this.updateLocalOnlyChanges(n),this.tree=r;let s=n[0]?.sync??!0;for(let a of n){let d=a.sync??!0;m(d===s,"All changes must either sync or not sync:",a.sync,"!=",s)}return this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,Qr.debug("commit local tree:",n.length,this.recentEditReasons,"should sync:",s),s&&this.syncChanges(n),this.hasLocalCommitSinceLastSync=!0,this.tree}invalidateAllCursors(){this.epoch+=1}getChangeTrackingCursor(){return{remoteTree:0,localTree:0,timeline:this,tree:this.tree,epoch:this.epoch}}fetchForwardChanges(t){if(!t)return;if(t.tree===this.tree)return[];if(t.tree.lineage!==this.tree.lineage||t.tree.root.id!==this.tree.root.id||t.timeline!==this)return;this.tree.beginAllowPartialScopeAccess();let e=Ba(t.tree,this.tree);return this.tree.endAllowPartialScopeAccess(),t.tree=this.tree,e.changes}invalidatedByLoadCompletedDocument(t){return!1}verifyTree(){wu(this.store.getHierarchy(),this.latestRemoteTree)}applyChanges(t){Br(this.tree,t)}applyReverseChanges(t){_a(this.tree,t)}discardChangeset(t){let e=this.tree.lineage.getChangesetRecord(t.id);m(e,"Unknown changeset"),e.status!=="discarded"&&(e.changes.length>0&&this.applyReverseChanges(e.changes),this.tree.lineage.setChangesetStatus(t.id,"discarded"))}};function wu(o,t){if(!t.getService("loader")){t.beginAllowPartialScopeAccess();try{let e=o.getRootId();m(e===t.root.id,"hierarchy root does not match tree root",e,t.root.id);let r=new Set,n=[],i=d=>n.length>0?`${n.join(" -> ")} -> ${d}`:d,s=d=>{let c=t.get(d);m(c,"Node missing in CanvasTree",d,"path:",i(d));let u=c.children;return u?u.filter(l=>!Zt(l)).map(l=>l.id):[]},a=d=>{m(!r.has(d),"cycle",d,"path:",i(d)),r.add(d),m(o.getNodeData(d),"node not in hierarchy",d,"path:",i(d)),m(o.has(d),"node not in hierarchy tree",d,"path:",i(d)),m(t.has(d),"node not in tree",d,"path:",i(d));let c=o.getChildrenIds(d),u=s(d);c.length!==u.length&&m(!1,"Child count mismatch","node:",d,"path:",i(d),"hierarchyChildren:",JSON.stringify(c),"treeChildren:",JSON.stringify(u));for(let l=0;l<c.length;l++){let h=c[l],g=u[l];m(h,"Missing hierarchy child id","node:",d,"path:",i(d),"index:",l),m(g,"Missing tree child id","node:",d,"path:",i(d),"index:",l),h!==g&&m(!1,"Child order mismatch","node:",d,"path:",i(d),"index:",l,"hierarchyChild:",h,"treeChild:",g)}n.push(d);for(let l of c)a(l);n.pop()};a(e)}finally{t.endAllowPartialScopeAccess()}}}var Nu={cache:!0,mutable:!0,update:!0,parentid:!0,originalid:!0,duplicatedFrom:!0,moduleSourceRevision:!0,moduleSourceRevisionHint:!0,moduleSourceRevisionCommittedHint:!0,kitSectionsStructure:!0,kitSectionHash:!0,kitSectionSource:!0,kitPageHTMLHash:!0,customizations:!0,customizationsDescription:!0,customizationsSectionId:!0,customizationsCategory:!0,customizationsRules:!0,isApplyingCustomizations:!0,layoutTemplateIdentifierOverride:!0,abTestingParentId:!0,abTestingDistributionWeightPpm:!0};function Ae(o,t){if(!U(t)&&!Nu[o]&&!o.startsWith("export")&&!qs(o))return t}function Ru(o,t){if(o!=="children")return Ae(o,t)}function xu(o,t,e,r,n){if(!Ms(o)||!zo(t))return t;if(t.type==="slot")return!Oo(t.value)||ut(e)&&e.slotsAreChildNodes?t:t.value.map(i=>{let s=n.get(i.reference);return Ln(r,s)?s:void 0});if(t.type==="componentinstance"){if(!Z(t.value))return t;let i=n.get(t.value);return Ln(r,i)?i:void 0}else if(t.type==="array"){if(!Oo(t.value))return t;let i=[],s=!1;for(let a of t.value){if(!zo(a)||a.type!=="componentinstance"||(s=!0,!Z(a.value)))continue;let d=n.get(a.value);Ln(r,d)&&i.push(d)}return s?i:t}return t}function Du(o,t){return(e,r,n)=>Ae(e,xu(e,r,n,t,o))}var Yr=x("ModuleSourceRevision");function xv(o){return Ce(K(o,Ae))}function Dv(o,t,e){let r=Ce(K(t,Ae));for(let n of e){let i=o.get(Ws(n.id,t.id));i&&(r+=Ce(K(i,Ae)))}return r}function Eu(o,t){switch(o.__class){case"CollectionItemNode":case"ImageStylePresetNode":case"InlineCodeStylePresetNode":case"LayoutTemplateNode":case"LinkStylePresetNode":case"SmartComponentNode":case"TableStylePresetNode":case"WebPageNode":return Ce(K(o,Ae));case"FrameNode":{let e=t.get(o.parentid);return!e||!pe(e)?void 0:Ce(K(o,Du(t,e.id)))}case"CollectionNode":{m(ee(o),"Expected collection node");let e=K(t.root.locales),r=K(t.root.webMetadata?.translatePagePaths),n=K(o,Ru),i=K(o.getUnsortedChildren()?.map(s=>s.moduleSourceRevision));return Ce(e+r+n+i)}case"PresetsListNode":{let e=o.children?.filter(r=>!ea(r,t))??[];return Ce(K(e,Ae))}case"TextStylePresetNode":case"BlockquoteStylePresetNode":{if(lt(o))return o.moduleSourceRevision;let e=K(o,Ae);return o.cache.replicaInstances?.forEach(r=>{let n=t.getNodeWithTrait(r,lt);n&&(e+=K(n,Ae))}),Ce(e)}case"VectorSetNode":{m(me(o),"Expected VectorSetNode");let e=o.getVectorSetItems().map(r=>{let n=Oe("vector",r.id,"default").localId,i=t.getNodeWithTrait(n,ga);return i?i.save.moduleId:""});return Ce(K(e)+o.name)}case"ShapeContainerNode":{if(!ze(o))return;let e=t.getScopeNodeFor(o);if(!me(e))return;let r=K(o,Ae);return Ce(r+K(e.variables))}case"CustomCodeScopeNode":{m(Lt(o),"Expected CustomCodeScopeNode");let e=o.loaded;m(e,"Expected CustomCodeScopeNode to be loaded");let r={};for(let i of e.children)if(!(!vs(i)||!i.pageIds))for(let s of i.pageIds){let a=t.getNodeWithTrait(s,vn);a&&(r[s]=a.dataIdentifier)}let n=K(o,Ae);return Ce(n+K(r))}case"CanvasPageNode":case"RootNode":return;case"ComponentPresetNode":return;case"AbTestsEntityTypeRootNode":case"AgentPanelTool":case"AgentDragSelectTool":case"AgentModalTool":case"AgentSelectTool":case"AnalyticsScopeNode":case"BlockquoteEntityTypeRootNode":case"BooleanShapeNode":case"BoxShadow":case"CanvasNode":case"CanvasScopeNode":case"CustomCodeNode":case"DesignPageNode":case"ChatTool":case"CMSEntityTypeRootNode":case"CodeComponentNode":case"CodeFileEntityTypeRootNode":case"CollectionReferenceVariableEditTool":case"Color":case"ColorEntityTypeRootNode":case"ColorStyleTokenListNode":case"ColorStyleTokenNode":case"ComponentEntityTypeRootNode":case"ConicGradient":case"ContentManagementNode":case"CreateCodeComponentBaseTool":case"CreateFrameBaseTool":case"CreateShapeBaseTool":case"CreateTextTool":case"EntityFolderNode":case"EntityReferenceNode":case"EntityRootNode":case"ErrorListNode":case"ErrorNode":case"ExportOptions":case"ExternalModuleNode":case"ExternalModulesListNode":case"FeedbackTool":case"FormBooleanInputNode":case"FormPlainTextInputNode":case"FormSelectNode":case"FunnelNode":case"FunnelsEntityTypeRootNode":case"FunnelStepActionNode":case"FunnelStepNode":case"GapTool":case"GradientColorStop":case"GradientToolManagerTool":case"GuideMoveTool":case"HeaderRouteNode":case"HighlightStackItemTool":case"HighlightTool":case"InitialTool":case"InlineCodeEntityTypeRootNode":case"LayoutTemplateEntityTypeRootNode":case"LineAnchorMoveTool":case"LinearGradient":case"LinkEntityTypeRootNode":case"LinkTool":case"LoadingShieldTool":case"LocalizationGlossaryItemNode":case"LocalizationGlossaryNode":case"LocalModuleNode":case"LocalModulesListNode":case"MoveTool":case"MutableNode":case"OvalShapeNode":case"OverlayNode":case"PaddingTool":case"PageLinkTool":case"PanTool":case"PathCurveBendTool":case"PathDefaultTool":case"PathNode":case"PathSegment":case"PathSegmentAdditionTool":case"PathSegmentHandleMoveTool":case"PathSegmentMoveTool":case"PathSegmentSelectTool":case"PolygonShapeNode":case"PreviewSettings":case"ProxyRouteNode":case"RadialGradient":case"RadiusTool":case"RecoveryTool":case"RectangleShapeNode":case"RedirectRouteNode":case"ResizeTool":case"RewriteRouteNode":case"RichTextEditTool":case"RichTextNode":case"RichTextVariableEditTool":case"RotateTool":case"RouteNode":case"RouteLocaleNode":case"RouteSegmentNode":case"RouteSegmentRootNode":case"RoutesNode":case"SampleColorTool":case"ScaleTool":case"ScopeNode":case"SelectTool":case"ShaderNode":case"Shadow":case"ShapeGroupNode":case"SlotConnectTool":case"SlotNode":case"SlotPropertyNode":case"StarShapeNode":case"StringVariableEditTool":case"DateVariableEditTool":case"EnumVariableEditTool":case"StyledTextDraft":case"SVGNode":case"TestTool":case"TextEditTool":case"TextEntityTypeRootNode":case"TextNode":case"VectorSetEntityTypeRootNode":case"VekterGradientTool":case"VekterPathEngine":case"VekterTool":case"ViewportResizeTool":case"ZoomSelectTool":case"ZoomTool":return;default:ae(o.__class,"getModuleRevision: node.__class must be a valid value")}}function Bi(o,t){let e=o.get(t);return!e||!Te(e,o)?!1:U(e.moduleSourceRevisionHint)||e.moduleSourceRevisionCommittedHint===e.moduleSourceRevisionHint?(Yr.debug(`Hint hasn't changed for ${e.id}.`),!1):(Yr.debug(`Initial Revision: ${e.moduleSourceRevision}`),!0)}function Oi(o,t){let e=o.get(t);if(!e||!Te(e,o))return;let r=performance.now(),n=Eu(e,o);Yr.debug(`Spent ${performance.now()-r}ms computing module revision for ${e.id}`);let i=B(n)&&n!==e.moduleSourceRevision;Yr.debug(`Revisions: ${e.moduleSourceRevision}, ${n}`);let s=e.moduleSourceRevisionHint,a=i?{moduleSourceRevision:n,moduleSourceRevisionCommittedHint:s}:{moduleSourceRevisionCommittedHint:s};return Yr.debug(i?`Updating moduleSourceRevision for ${e.id}.`:`Updating moduleSourceRevisionCommittedHint for ${e.id}.`),e.setIgnoringReplica(a,o),i?n:void 0}function Ic(o,t){return t(e=>{if(e.isViewOnly)return;let r=e.get(o);return ee(r)&&r.getUnsortedChildren()?.forEach(n=>{Bi(e,n.id)&&Oi(e,n.id)}),Oi(e,o)})}function wc(o,t){return t(e=>{if(!e.isViewOnly)return o.reduce((r,n)=>(r[n.id]=Oi(e,n.id)??1,r),{})})}var Lu=x("CodeGenerationStore"),ku="transform",Cr,_t,ho=class{constructor(t){this.sourceNode=t;X(this,Cr,[]);X(this,_t)}start(t){let e=performance.now();return{end:r=>{T(this,Cr).push([t,performance.now()-e]),Ze(this,_t,T(this,_t)??r),t===ku&&this.completeSession()}}}restartSession(){Ze(this,Cr,[]),Ze(this,_t,void 0)}completeSession(){T(this,_t)?.forEach(({type:t,source:e,artifacts:r})=>{let n=Pu(t,this.sourceNode);if(!n)return;let i={codeType:n,durationMs:0,updateCount:0,updateDurationMs:0,serializationDurationMs:0,compilationDurationMs:0,synchronizationDurationMs:0,size:e.length,id:this.sourceNode.id,nodes:r?.metrics?.nodes??1,variants:r?.metrics?.variants??0,svgBytes:r?.metrics?.svgBytes,textBytes:r?.metrics?.textBytes};for(let[a,d]of T(this,Cr))switch(i.durationMs+=d,a){case"update":i.updateCount++,i.updateDurationMs+=d;break;case"serialize":i.serializationDurationMs+=d;break;case"transform":i.compilationDurationMs+=d;break;case"synchronize":i.synchronizationDurationMs+=d;break;default:ae(a)}let s;for(s in i){let a=i[s];B(a)&&(i[s]=Math.round(a))}Lu.trace("Code Generation Metrics",i),ke("code_generation",i)}),this.restartSession()}};Cr=new WeakMap,_t=new WeakMap;function Pu(o,t){switch(o){case"canvasComponent":return"smart_component";case"css":return"styles_preset";case"collection":return"collection";case"draftCollection":return"draft_collection";case"componentPresets":return"component_presets";case"screen":return M(t)?"web_page":"prototype_screen";case"prototype":return"prototype";case"vector":return"vector";case"vectorSet":return"vector_set";case"snippets":return"snippets";case"codeFile":case"config":case"siteMetadata":case"webPageMetadata":case"layoutTemplate":case"localization":case"design":case"kit":case"shader":return;default:ae(o)}}function Mu(o,t){let e={};if(!t||Fs(o))return e;for(let r of o.cases)for(let n of t){let i=r.nameLocalized;if(!i)continue;let s=i[n.id]?.value;if(!Z(s))continue;let a=e[r.id]??{};e[r.id]=a,a[n.id]=s}return e}function Nc(o,t,e){if(o.cases.length===0)return p`(value) => value`;let r=Mu(o,t),n=p`value`,i=p`locale`,s=p`fallbackLocale`;return new I(A.lines(p`(${n}, ${i}) => {`,p`const ${s} = ${i}?.fallback;`,p`switch (${n}) {`,...o.cases.map(({id:a,name:d})=>{let c=r[a];return c?new I(A.lines(p`case ${a}:`,p`switch (${i}?.id) {`,...Object.entries(c).map(([u,l])=>p`case ${u}: return ${l};`),p`default:`,p`if (${s}) return ${I.fn(e,n,s)};`,p`return ${d};`,p`}`)):p`case ${a}: return ${d};`}),p`default: return "";`,p`}`,p`}`))}var _i="framercms";function Rc(o,t,e){return`${o}-${t}.${e}`}var go=class{constructor(t){this.componentSourceNodeId=t;f(this,"assets",{})}create(t,e,r){let n=Rc(this.componentSourceNodeId,t,e);return this.assets[n]=r,p`new URL(${`./${n}`}, import.meta.url).href`}};var xc=Dt(Uo(),1);function q(o,...t){if(!o)throw Error("Assertion Error"+(t.length>0?": "+t.join(" "):""))}function Xr(o){throw new Error(`Unexpected value: ${o}`)}var Vu=Dt(gn(),1);var Dc=`// src/code-generation/components/cms/bundled/getRichTextJsonResolver.tsx?bundle
import { AutoBreakpointVariant, ComponentPresetsConsumer, Link, motion } from "framer";

// ../../library/src/router/lazy.tsx
import { forwardRef, isValidElement, useEffect } from "react";

// ../../library/src/utils/utils.ts
var isWindow = typeof window !== "undefined";
var supportsRequestIdleCallback = isWindow && typeof window.requestIdleCallback === "function";

// ../../library/src/router/lazy.tsx
var preloadKey = "preload";
function isLazyComponentType(componentType) {
  return typeof componentType === "object" && componentType !== null && !isValidElement(componentType) && preloadKey in componentType;
}

// src/code-generation/components/cms/bundled/getRichTextJsonResolver.tsx?bundle
import { Fragment, createElement } from "react";

// src/code-generation/components/cms/bundled/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  throw Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
}

// src/code-generation/components/cms/bundled/getRichTextJsonResolver.tsx?bundle
var RichTextJsonType = /* @__PURE__ */ ((RichTextJsonType2) => {
  RichTextJsonType2[RichTextJsonType2["Fragment"] = 1] = "Fragment";
  RichTextJsonType2[RichTextJsonType2["Link"] = 2] = "Link";
  RichTextJsonType2[RichTextJsonType2["Module"] = 3] = "Module";
  RichTextJsonType2[RichTextJsonType2["Tag"] = 4] = "Tag";
  RichTextJsonType2[RichTextJsonType2["Text"] = 5] = "Text";
  return RichTextJsonType2;
})(RichTextJsonType || {});
function getRichTextJsonResolver(components) {
  const cache = /* @__PURE__ */ new Map();
  function deserializeChildren(children) {
    return children.map(deserializeNode);
  }
  function deserializeNode(node) {
    switch (node[0]) {
      case 1 /* Fragment */: {
        const [, ...children] = node;
        const childNodes = deserializeChildren(children);
        return createElement(Fragment, void 0, ...childNodes);
      }
      case 2 /* Link */: {
        const [, props, ...children] = node;
        const childNodes = deserializeChildren(children);
        return createElement(Link, props, ...childNodes);
      }
      case 3 /* Module */: {
        const [, identifier, props, richTextKeys] = node;
        for (const key of richTextKeys) {
          const value = props[key];
          if (!value) continue;
          props[key] = deserializeNode(value);
        }
        const Component = components[identifier];
        assert(Component, "Module not found");
        if (isLazyComponentType(Component)) {
          void Component.preload();
        }
        return <ComponentPresetsConsumer componentIdentifier={identifier}>
						{(presetProps) => <AutoBreakpointVariant component={Component} props={{ ...presetProps, ...props }} />}
					</ComponentPresetsConsumer>;
      }
      case 4 /* Tag */: {
        const [, tag, props, ...children] = node;
        const childNodes = deserializeChildren(children);
        if (tag === "a") {
          return createElement(motion.a, props, ...childNodes);
        }
        return createElement(tag, props, ...childNodes);
      }
      case 5 /* Text */: {
        const [, text] = node;
        return text;
      }
    }
  }
  return (pointer) => {
    const cached = cache.get(pointer);
    if (cached) return cached;
    const json = JSON.parse(pointer);
    const result = deserializeNode(json);
    cache.set(pointer, result);
    return result;
  };
}
export {
  RichTextJsonType,
  getRichTextJsonResolver
};
`;var yo=class{constructor(t,e,r,n,i,s,a,d,c){this.collectionNode=t;this.componentLoader=e;this.treeStore=r;this.imports=n;this.submodules=i;this.bindings=s;this.declarations=a;this.assets=d;this.links=c;f(this,"scopeNode");f(this,"cache",new Map);f(this,"components",{});f(this,"resolvers");f(this,"serializers",{fragment:t=>[1,...t],link:(t,e)=>[2,t,...e],module:(t,e)=>{if(!this.addModuleImport(t))return;let n=this.componentLoader.reactComponentForIdentifier(t);m(n,"Component must exist for module");let i=[];for(let s in n.properties){let a=n.properties[s];a&&a.type==="richtext"&&i.push(s)}return[3,t,e,i]},tag:(t,e,r)=>[4,t,e,...r],text:t=>[5,t]});f(this,"resolveRichTextBinding");this.resolveRichTextBinding=this.bindings.create("resolveRichText"),this.scopeNode=this.treeStore.tree.getScopeNodeFor(this.collectionNode),this.resolvers=Xa(this.assets,this.links,void 0,void 0)}addModuleImport(t){if(t in this.components)return!0;let e=Ee(t),r=this.imports.addModuleImport(e,{lazy:!0});return r?(this.components[t]=r,!0):!1}add(t){let e=this.cache.get(t);if(e)return e;let r=Ya(t,this.resolvers,this.serializers,{componentLoader:this.componentLoader,tree:this.treeStore.tree,nodeId:this.collectionNode.id,scopeId:this.scopeNode?.id}),n=JSON.stringify(r);return this.cache.set(t,n),n}serialize(){let t=this.imports.addImport(this.submodules.create(Dc).submoduleImport,{exportSpecifier:"getRichTextJsonResolver"}),e=this.declarations.dedupe("richTextComponents",this.components);this.declarations.create(p`const ${this.resolveRichTextBinding} = ${I.fn(t,e)}`)}};var vo=class{constructor(){f(this,"values",new Map)}add(t){let e=this.values.get(t);if(B(e))return e;let r=this.values.size;return this.values.set(t,r),r}serialize(t,e,r){let n=[];for(let[s,a]of this.values){let d=Ee(s),{importSpecifier:c}=fa(d,"collection",t,e);m(c,"Import specifier must be defined"),n[a]=p`() => import(${c})`}let i=r.dedupe("vectors",n);return r.dedupe("resolveVectorSetItem",p`(pointer: number) => {${p.joinLines(p`const vector = ${i}[pointer]`,p`if (vector) return vector().then(v => v.default)`)}}`)}};var W={Uint8:1,Uint16:2,Uint32:4,BigUint64:8,Int8:1,Int16:2,Int32:4,BigInt64:8,Float32:4,Float64:8},bo=class{constructor(t){this.bytes=t;f(this,"offset",0);f(this,"view");f(this,"decoder",new TextDecoder);this.view=Tr(this.bytes)}getOffset(){return this.offset}ensureLength(t){let e=this.bytes.length;if(!(this.offset+t<=e))throw new Error("Reading out of bounds")}readUint8(){let t=W.Uint8;this.ensureLength(t);let e=this.view.getUint8(this.offset);return this.offset+=t,e}readUint16(){let t=W.Uint16;this.ensureLength(t);let e=this.view.getUint16(this.offset);return this.offset+=t,e}readUint32(){let t=W.Uint32;this.ensureLength(t);let e=this.view.getUint32(this.offset);return this.offset+=t,e}readUint64(){let t=this.readBigUint64();return Number(t)}readBigUint64(){let t=W.BigUint64;this.ensureLength(t);let e=this.view.getBigUint64(this.offset);return this.offset+=t,e}readInt8(){let t=W.Int8;this.ensureLength(t);let e=this.view.getInt8(this.offset);return this.offset+=t,e}readInt16(){let t=W.Int16;this.ensureLength(t);let e=this.view.getInt16(this.offset);return this.offset+=t,e}readInt32(){let t=W.Int32;this.ensureLength(t);let e=this.view.getInt32(this.offset);return this.offset+=t,e}readInt64(){let t=this.readBigInt64();return Number(t)}readBigInt64(){let t=W.BigInt64;this.ensureLength(t);let e=this.view.getBigInt64(this.offset);return this.offset+=t,e}readFloat32(){let t=W.Float32;this.ensureLength(t);let e=this.view.getFloat32(this.offset);return this.offset+=t,e}readFloat64(){let t=W.Float64;this.ensureLength(t);let e=this.view.getFloat64(this.offset);return this.offset+=t,e}readBytes(t){let e=this.offset,r=e+t,n=this.bytes.subarray(e,r);return this.offset=r,n}readString(){let t=this.readUint32(),e=this.readBytes(t);return this.decoder.decode(e)}readJson(){let t=this.readString();return JSON.parse(t)}};function Tr(o){return new DataView(o.buffer,o.byteOffset,o.byteLength)}var Au=1024,Fu=1.5,zi=o=>2**o-1,ji=o=>-(2**(o-1)),$i=o=>2**(o-1)-1,qe={Uint8:0,Uint16:0,Uint32:0,Uint64:0,BigUint64:0,Int8:ji(8),Int16:ji(16),Int32:ji(32),Int64:Number.MIN_SAFE_INTEGER,BigInt64:-(BigInt(2)**BigInt(63))},We={Uint8:zi(8),Uint16:zi(16),Uint32:zi(32),Uint64:Number.MAX_SAFE_INTEGER,BigUint64:BigInt(2)**BigInt(64)-BigInt(1),Int8:$i(8),Int16:$i(16),Int32:$i(32),Int64:Number.MAX_SAFE_INTEGER,BigInt64:BigInt(2)**BigInt(63)-BigInt(1)};function He(o,t,e,r){q(o>=t,o,"outside lower bound for",r),q(o<=e,o,"outside upper bound for",r)}var zt=class{constructor(){f(this,"offset",0);f(this,"bytes",new Uint8Array(Au));f(this,"view",Tr(this.bytes));f(this,"encoder",new TextEncoder);f(this,"encodedStrings",new Map)}getOffset(){return this.offset}slice(t=0,e=this.offset){return this.bytes.slice(t,e)}subarray(t=0,e=this.offset){return this.bytes.subarray(t,e)}ensureLength(t){let e=this.bytes.length;if(this.offset+t<=e)return;let r=Math.ceil(e*Fu)+t,n=new Uint8Array(r);n.set(this.bytes),this.bytes=n,this.view=Tr(n)}writeUint8(t){He(t,qe.Uint8,We.Uint8,"Uint8");let e=W.Uint8;this.ensureLength(e),this.view.setUint8(this.offset,t),this.offset+=e}writeUint16(t){He(t,qe.Uint16,We.Uint16,"Uint16");let e=W.Uint16;this.ensureLength(e),this.view.setUint16(this.offset,t),this.offset+=e}writeUint32(t){He(t,qe.Uint32,We.Uint32,"Uint32");let e=W.Uint32;this.ensureLength(e),this.view.setUint32(this.offset,t),this.offset+=e}writeUint64(t){He(t,qe.Uint64,We.Uint64,"Uint64");let e=BigInt(t);this.writeBigUint64(e)}writeBigUint64(t){He(t,qe.BigUint64,We.BigUint64,"BigUint64");let e=W.BigUint64;this.ensureLength(e),this.view.setBigUint64(this.offset,t),this.offset+=e}writeInt8(t){He(t,qe.Int8,We.Int8,"Int8");let e=W.Int8;this.ensureLength(e),this.view.setInt8(this.offset,t),this.offset+=e}writeInt16(t){He(t,qe.Int16,We.Int16,"Int16");let e=W.Int16;this.ensureLength(e),this.view.setInt16(this.offset,t),this.offset+=e}writeInt32(t){He(t,qe.Int32,We.Int32,"Int32");let e=W.Int32;this.ensureLength(e),this.view.setInt32(this.offset,t),this.offset+=e}writeInt64(t){He(t,qe.Int64,We.Int64,"Int64");let e=BigInt(t);this.writeBigInt64(e)}writeBigInt64(t){He(t,qe.BigInt64,We.BigInt64,"BigInt64");let e=W.BigInt64;this.ensureLength(e),this.view.setBigInt64(this.offset,t),this.offset+=e}writeFloat32(t){let e=W.Float32;this.ensureLength(e),this.view.setFloat32(this.offset,t),this.offset+=e}writeFloat64(t){let e=W.Float64;this.ensureLength(e),this.view.setFloat64(this.offset,t),this.offset+=e}writeBytes(t){let e=t.length;this.ensureLength(e),this.bytes.set(t,this.offset),this.offset+=e}encodeString(t){let e=this.encodedStrings.get(t);if(e)return e;let r=this.encoder.encode(t);return this.encodedStrings.set(t,r),r}writeString(t){let e=this.encodeString(t),r=e.length;this.writeUint32(r),this.writeBytes(e)}writeJson(t){let e=JSON.stringify(t);this.writeString(e)}};var Ec=`var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../../node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "../../../node_modules/dataloader/index.js"(exports, module) {
    "use strict";
    var DataLoader2 = /* @__PURE__ */ function() {
      function DataLoader3(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
      }
      var _proto = DataLoader3.prototype;
      _proto.load = function load(key) {
        if (key === null || key === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys) {
        if (!isArrayLike(keys)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys.length; i++) {
          loadPromises.push(this.load(keys[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader3;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise;
      try {
        batchPromise = loader._batchLoadFn(batch.keys);
      } catch (e) {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
      }
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\\n\\nKeys:\\n" + String(batch.keys)) + ("\\n\\nValues:\\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key) {
          return key;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function getValidName(options) {
      if (options && options.name) {
        return options.name;
      }
      return null;
    }
    function isArrayLike(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    module.exports = DataLoader2;
  }
});

// src/code-generation/components/cms/bundled/DatabaseCollection.ts?bundle
var import_dataloader = __toESM(require_dataloader(), 1);

// src/code-generation/components/cms/bundled/BufferReader.ts
var BYTE_LENGTH = {
  Uint8: 1,
  Uint16: 2,
  Uint32: 4,
  BigUint64: 8,
  Int8: 1,
  Int16: 2,
  Int32: 4,
  BigInt64: 8,
  Float32: 4,
  Float64: 8
};
var BufferReader = class {
  constructor(bytes) {
    this.bytes = bytes;
    __publicField(this, "offset", 0);
    __publicField(this, "view");
    __publicField(this, "decoder", new TextDecoder());
    this.view = getDataView(this.bytes);
  }
  getOffset() {
    return this.offset;
  }
  ensureLength(requiredBytes) {
    const oldLength = this.bytes.length;
    if (this.offset + requiredBytes <= oldLength) return;
    throw new Error("Reading out of bounds");
  }
  readUint8() {
    const size = BYTE_LENGTH.Uint8;
    this.ensureLength(size);
    const value = this.view.getUint8(this.offset);
    this.offset += size;
    return value;
  }
  readUint16() {
    const size = BYTE_LENGTH.Uint16;
    this.ensureLength(size);
    const value = this.view.getUint16(this.offset);
    this.offset += size;
    return value;
  }
  readUint32() {
    const size = BYTE_LENGTH.Uint32;
    this.ensureLength(size);
    const value = this.view.getUint32(this.offset);
    this.offset += size;
    return value;
  }
  readUint64() {
    const bigint = this.readBigUint64();
    return Number(bigint);
  }
  readBigUint64() {
    const size = BYTE_LENGTH.BigUint64;
    this.ensureLength(size);
    const value = this.view.getBigUint64(this.offset);
    this.offset += size;
    return value;
  }
  readInt8() {
    const size = BYTE_LENGTH.Int8;
    this.ensureLength(size);
    const value = this.view.getInt8(this.offset);
    this.offset += size;
    return value;
  }
  readInt16() {
    const size = BYTE_LENGTH.Int16;
    this.ensureLength(size);
    const value = this.view.getInt16(this.offset);
    this.offset += size;
    return value;
  }
  readInt32() {
    const size = BYTE_LENGTH.Int32;
    this.ensureLength(size);
    const value = this.view.getInt32(this.offset);
    this.offset += size;
    return value;
  }
  readInt64() {
    const bigint = this.readBigInt64();
    return Number(bigint);
  }
  readBigInt64() {
    const size = BYTE_LENGTH.BigInt64;
    this.ensureLength(size);
    const value = this.view.getBigInt64(this.offset);
    this.offset += size;
    return value;
  }
  readFloat32() {
    const size = BYTE_LENGTH.Float32;
    this.ensureLength(size);
    const value = this.view.getFloat32(this.offset);
    this.offset += size;
    return value;
  }
  readFloat64() {
    const size = BYTE_LENGTH.Float64;
    this.ensureLength(size);
    const value = this.view.getFloat64(this.offset);
    this.offset += size;
    return value;
  }
  readBytes(length) {
    const start = this.offset;
    const end = start + length;
    const value = this.bytes.subarray(start, end);
    this.offset = end;
    return value;
  }
  readString() {
    const length = this.readUint32();
    const bytes = this.readBytes(length);
    return this.decoder.decode(bytes);
  }
  readJson() {
    const string = this.readString();
    return JSON.parse(string);
  }
};
function getDataView(bytes) {
  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}

// src/code-generation/components/cms/bundled/DatabaseDictionaryIndex.ts
import { ControlType as ControlType2 } from "framer";

// ../../library/src/utils/utils.ts
var isWindow = typeof window !== "undefined";
var supportsRequestIdleCallback = isWindow && typeof window.requestIdleCallback === "function";

// src/code-generation/components/cms/bundled/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  throw Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
}
function assertNever(condition) {
  throw new Error(\`Unexpected value: \${condition}\`);
}

// src/code-generation/components/cms/bundled/BufferWriter.ts
var INITIAL_BUFFER_SIZE = 1024;
var GROWTH_FACTOR = 1.5;
var maxUnsignedNumber = (bits) => 2 ** bits - 1;
var minSignedNumber = (bits) => -(2 ** (bits - 1));
var maxSignedNumber = (bits) => 2 ** (bits - 1) - 1;
var MIN_VALUE = {
  Uint8: 0,
  Uint16: 0,
  Uint32: 0,
  Uint64: 0,
  BigUint64: 0,
  Int8: minSignedNumber(8),
  Int16: minSignedNumber(16),
  Int32: minSignedNumber(32),
  Int64: Number.MIN_SAFE_INTEGER,
  BigInt64: -(BigInt(2) ** BigInt(63))
};
var MAX_VALUE = {
  Uint8: maxUnsignedNumber(8),
  Uint16: maxUnsignedNumber(16),
  Uint32: maxUnsignedNumber(32),
  Uint64: Number.MAX_SAFE_INTEGER,
  BigUint64: BigInt(2) ** BigInt(64) - BigInt(1),
  Int8: maxSignedNumber(8),
  Int16: maxSignedNumber(16),
  Int32: maxSignedNumber(32),
  Int64: Number.MAX_SAFE_INTEGER,
  BigInt64: BigInt(2) ** BigInt(63) - BigInt(1)
};
function assertRange(value, min, max, dataType) {
  assert(value >= min, value, "outside lower bound for", dataType);
  assert(value <= max, value, "outside upper bound for", dataType);
}
var BufferWriter = class {
  constructor() {
    __publicField(this, "offset", 0);
    __publicField(this, "bytes", new Uint8Array(INITIAL_BUFFER_SIZE));
    __publicField(this, "view", getDataView(this.bytes));
    __publicField(this, "encoder", new TextEncoder());
    __publicField(this, "encodedStrings", /* @__PURE__ */ new Map());
  }
  getOffset() {
    return this.offset;
  }
  slice(start = 0, end = this.offset) {
    return this.bytes.slice(start, end);
  }
  subarray(start = 0, end = this.offset) {
    return this.bytes.subarray(start, end);
  }
  ensureLength(requiredBytes) {
    const oldLength = this.bytes.length;
    if (this.offset + requiredBytes <= oldLength) return;
    const newLength = Math.ceil(oldLength * GROWTH_FACTOR) + requiredBytes;
    const newBytes = new Uint8Array(newLength);
    newBytes.set(this.bytes);
    this.bytes = newBytes;
    this.view = getDataView(newBytes);
  }
  writeUint8(value) {
    assertRange(value, MIN_VALUE.Uint8, MAX_VALUE.Uint8, "Uint8");
    const size = BYTE_LENGTH.Uint8;
    this.ensureLength(size);
    this.view.setUint8(this.offset, value);
    this.offset += size;
  }
  writeUint16(value) {
    assertRange(value, MIN_VALUE.Uint16, MAX_VALUE.Uint16, "Uint16");
    const size = BYTE_LENGTH.Uint16;
    this.ensureLength(size);
    this.view.setUint16(this.offset, value);
    this.offset += size;
  }
  writeUint32(value) {
    assertRange(value, MIN_VALUE.Uint32, MAX_VALUE.Uint32, "Uint32");
    const size = BYTE_LENGTH.Uint32;
    this.ensureLength(size);
    this.view.setUint32(this.offset, value);
    this.offset += size;
  }
  writeUint64(value) {
    assertRange(value, MIN_VALUE.Uint64, MAX_VALUE.Uint64, "Uint64");
    const bigint = BigInt(value);
    this.writeBigUint64(bigint);
  }
  writeBigUint64(value) {
    assertRange(value, MIN_VALUE.BigUint64, MAX_VALUE.BigUint64, "BigUint64");
    const size = BYTE_LENGTH.BigUint64;
    this.ensureLength(size);
    this.view.setBigUint64(this.offset, value);
    this.offset += size;
  }
  writeInt8(value) {
    assertRange(value, MIN_VALUE.Int8, MAX_VALUE.Int8, "Int8");
    const size = BYTE_LENGTH.Int8;
    this.ensureLength(size);
    this.view.setInt8(this.offset, value);
    this.offset += size;
  }
  writeInt16(value) {
    assertRange(value, MIN_VALUE.Int16, MAX_VALUE.Int16, "Int16");
    const size = BYTE_LENGTH.Int16;
    this.ensureLength(size);
    this.view.setInt16(this.offset, value);
    this.offset += size;
  }
  writeInt32(value) {
    assertRange(value, MIN_VALUE.Int32, MAX_VALUE.Int32, "Int32");
    const size = BYTE_LENGTH.Int32;
    this.ensureLength(size);
    this.view.setInt32(this.offset, value);
    this.offset += size;
  }
  writeInt64(value) {
    assertRange(value, MIN_VALUE.Int64, MAX_VALUE.Int64, "Int64");
    const bigint = BigInt(value);
    this.writeBigInt64(bigint);
  }
  writeBigInt64(value) {
    assertRange(value, MIN_VALUE.BigInt64, MAX_VALUE.BigInt64, "BigInt64");
    const size = BYTE_LENGTH.BigInt64;
    this.ensureLength(size);
    this.view.setBigInt64(this.offset, value);
    this.offset += size;
  }
  writeFloat32(value) {
    const size = BYTE_LENGTH.Float32;
    this.ensureLength(size);
    this.view.setFloat32(this.offset, value);
    this.offset += size;
  }
  writeFloat64(value) {
    const size = BYTE_LENGTH.Float64;
    this.ensureLength(size);
    this.view.setFloat64(this.offset, value);
    this.offset += size;
  }
  writeBytes(value) {
    const size = value.length;
    this.ensureLength(size);
    this.bytes.set(value, this.offset);
    this.offset += size;
  }
  encodeString(value) {
    const cached = this.encodedStrings.get(value);
    if (cached) return cached;
    const bytes = this.encoder.encode(value);
    this.encodedStrings.set(value, bytes);
    return bytes;
  }
  writeString(value) {
    const bytes = this.encodeString(value);
    const size = bytes.length;
    this.writeUint32(size);
    this.writeBytes(bytes);
  }
  writeJson(value) {
    const json = JSON.stringify(value);
    this.writeString(json);
  }
};

// src/utils/typeChecks.ts
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return Number.isFinite(value);
}
function isNull(value) {
  return value === null;
}

// src/code-generation/components/cms/bundled/models/DatabaseItemPointerModel.ts
var DatabaseItemPointerModel = class _DatabaseItemPointerModel {
  constructor(chunkId, offset, length) {
    this.chunkId = chunkId;
    this.offset = offset;
    this.length = length;
  }
  static fromString(value) {
    const [chunkId, offset, length] = value.split("/").map(Number);
    assert(isNumber(chunkId), "Invalid chunkId");
    assert(isNumber(offset), "Invalid offset");
    assert(isNumber(length), "Invalid length");
    return new _DatabaseItemPointerModel(chunkId, offset, length);
  }
  toString() {
    return \`\${this.chunkId}/\${this.offset}/\${this.length}\`;
  }
  static read(reader) {
    const chunkId = reader.readUint16();
    const offset = reader.readUint32();
    const length = reader.readUint32();
    return new _DatabaseItemPointerModel(chunkId, offset, length);
  }
  write(writer) {
    writer.writeUint16(this.chunkId);
    writer.writeUint32(this.offset);
    writer.writeUint32(this.length);
  }
  compare(other) {
    if (this.chunkId < other.chunkId) return -1;
    if (this.chunkId > other.chunkId) return 1;
    if (this.offset < other.offset) return -1;
    if (this.offset > other.offset) return 1;
    assert(this.length === other.length);
    return 0;
  }
};

// src/code-generation/components/cms/bundled/models/DatabaseValueModel.ts
import { ControlType } from "framer";
function getValueType(value) {
  if (isNull(value)) {
    return 0 /* Null */;
  }
  switch (value.type) {
    case ControlType.Array:
      return 1 /* Array */;
    case ControlType.Boolean:
      return 2 /* Boolean */;
    case ControlType.Color:
      return 3 /* Color */;
    case ControlType.Date:
      return 4 /* Date */;
    case ControlType.Enum:
      return 5 /* Enum */;
    case ControlType.File:
      return 6 /* File */;
    case ControlType.ResponsiveImage:
      return 10 /* ResponsiveImage */;
    case ControlType.Link:
      return 7 /* Link */;
    case ControlType.Number:
      return 8 /* Number */;
    case ControlType.Object:
      return 9 /* Object */;
    case ControlType.RichText:
      return 11 /* RichText */;
    case ControlType.String:
      return 12 /* String */;
    case ControlType.VectorSetItem:
      return 13 /* VectorSetItem */;
    default:
      assertNever(value);
  }
}
var DatabaseValueModel;
((DatabaseValueModel2) => {
  function read(reader) {
    const type = reader.readUint8();
    switch (type) {
      case 0 /* Null */:
        return null;
      case 1 /* Array */:
        return readArray(reader);
      case 2 /* Boolean */:
        return readBoolean(reader);
      case 3 /* Color */:
        return readColor(reader);
      case 4 /* Date */:
        return readDate(reader);
      case 5 /* Enum */:
        return readEnum(reader);
      case 6 /* File */:
        return readFile(reader);
      case 7 /* Link */:
        return readLink(reader);
      case 8 /* Number */:
        return readNumber(reader);
      case 9 /* Object */:
        return readObject(reader);
      case 10 /* ResponsiveImage */:
        return readResponsiveImage(reader);
      case 11 /* RichText */:
        return readRichText(reader);
      case 12 /* String */:
        return readString(reader);
      case 13 /* VectorSetItem */:
        return readVectorSetItem(reader);
      default:
        assertNever(type);
    }
  }
  DatabaseValueModel2.read = read;
  function write(writer, value) {
    const type = getValueType(value);
    writer.writeUint8(type);
    if (isNull(value)) return;
    switch (value.type) {
      case ControlType.Array:
        return writeArray(writer, value);
      case ControlType.Boolean:
        return writeBoolean(writer, value);
      case ControlType.Color:
        return writeColor(writer, value);
      case ControlType.Date:
        return writeDate(writer, value);
      case ControlType.Enum:
        return writeEnum(writer, value);
      case ControlType.File:
        return writeFile(writer, value);
      case ControlType.Link:
        return writeLink(writer, value);
      case ControlType.Number:
        return writeNumber(writer, value);
      case ControlType.Object:
        return writeObject(writer, value);
      case ControlType.ResponsiveImage:
        return writeResponsiveImage(writer, value);
      case ControlType.RichText:
        return writeRichText(writer, value);
      case ControlType.VectorSetItem:
        return writeVectorSetItem(writer, value);
      case ControlType.String:
        return writeString(writer, value);
      default:
        assertNever(value);
    }
  }
  DatabaseValueModel2.write = write;
  function compare(left, right, collation) {
    const leftType = getValueType(left);
    const rightType = getValueType(right);
    if (leftType < rightType) return -1;
    if (leftType > rightType) return 1;
    if (isNull(left) || isNull(right)) return 0;
    switch (left.type) {
      case ControlType.Array:
        assert(right.type === ControlType.Array);
        return compareArray(left, right, collation);
      case ControlType.Boolean:
        assert(right.type === ControlType.Boolean);
        return compareBoolean(left, right);
      case ControlType.Color:
        assert(right.type === ControlType.Color);
        return compareColor(left, right);
      case ControlType.Date:
        assert(right.type === ControlType.Date);
        return compareDate(left, right);
      case ControlType.Enum:
        assert(right.type === ControlType.Enum);
        return compareEnum(left, right);
      case ControlType.File:
        assert(right.type === ControlType.File);
        return compareFile(left, right);
      case ControlType.Link:
        assert(right.type === ControlType.Link);
        return compareLink(left, right);
      case ControlType.Number:
        assert(right.type === ControlType.Number);
        return compareNumber(left, right);
      case ControlType.Object:
        assert(right.type === ControlType.Object);
        return compareObject(left, right, collation);
      case ControlType.ResponsiveImage:
        assert(right.type === ControlType.ResponsiveImage);
        return compareResponsiveImage(left, right);
      case ControlType.RichText:
        assert(right.type === ControlType.RichText);
        return compareRichText(left, right);
      case ControlType.VectorSetItem:
        assert(right.type === ControlType.VectorSetItem);
        return compareVectorSetItem(left, right);
      case ControlType.String:
        assert(right.type === ControlType.String);
        return compareString(left, right, collation);
      default:
        assertNever(left);
    }
  }
  DatabaseValueModel2.compare = compare;
})(DatabaseValueModel || (DatabaseValueModel = {}));
function readArray(reader) {
  const length = reader.readUint16();
  const value = [];
  for (let i = 0; i < length; i++) {
    const item = DatabaseValueModel.read(reader);
    value.push(item);
  }
  return {
    type: ControlType.Array,
    value
  };
}
function writeArray(writer, value) {
  writer.writeUint16(value.value.length);
  for (const item of value.value) {
    DatabaseValueModel.write(writer, item);
  }
}
function compareArray(left, right, collation) {
  const leftLength = left.value.length;
  const rightLength = right.value.length;
  if (leftLength < rightLength) return -1;
  if (leftLength > rightLength) return 1;
  for (let i = 0; i < leftLength; i++) {
    const leftItem = left.value[i];
    const rightItem = right.value[i];
    const result = DatabaseValueModel.compare(leftItem, rightItem, collation);
    if (result !== 0) return result;
  }
  return 0;
}
function readBoolean(reader) {
  return {
    type: ControlType.Boolean,
    value: reader.readUint8() !== 0
  };
}
function writeBoolean(writer, value) {
  writer.writeUint8(value.value ? 1 : 0);
}
function compareBoolean(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readColor(reader) {
  return {
    type: ControlType.Color,
    value: reader.readString()
  };
}
function writeColor(writer, value) {
  writer.writeString(value.value);
}
function compareColor(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readDate(reader) {
  const timestamp = reader.readInt64();
  const date = new Date(timestamp);
  return {
    type: ControlType.Date,
    value: date.toISOString()
  };
}
function writeDate(writer, value) {
  const date = new Date(value.value);
  const timestamp = date.getTime();
  writer.writeInt64(timestamp);
}
function compareDate(left, right) {
  const leftDate = new Date(left.value);
  const rightDate = new Date(right.value);
  if (leftDate < rightDate) return -1;
  if (leftDate > rightDate) return 1;
  return 0;
}
function readEnum(reader) {
  return {
    type: ControlType.Enum,
    value: reader.readString()
  };
}
function writeEnum(writer, value) {
  writer.writeString(value.value);
}
function compareEnum(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readFile(reader) {
  return {
    type: ControlType.File,
    value: reader.readString()
  };
}
function writeFile(writer, value) {
  writer.writeString(value.value);
}
function compareFile(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readLink(reader) {
  return {
    type: ControlType.Link,
    value: reader.readJson()
  };
}
function writeLink(writer, value) {
  writer.writeJson(value.value);
}
function compareLink(left, right) {
  const leftEncoded = JSON.stringify(left.value);
  const rightEncoded = JSON.stringify(right.value);
  if (leftEncoded < rightEncoded) return -1;
  if (leftEncoded > rightEncoded) return 1;
  return 0;
}
function readNumber(reader) {
  return {
    type: ControlType.Number,
    value: reader.readFloat64()
  };
}
function writeNumber(writer, value) {
  writer.writeFloat64(value.value);
}
function compareNumber(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readObject(reader) {
  const length = reader.readUint16();
  const result = {};
  for (let i = 0; i < length; i++) {
    const key = reader.readString();
    result[key] = DatabaseValueModel.read(reader);
  }
  return {
    type: ControlType.Object,
    value: result
  };
}
function writeObject(writer, value) {
  const entries = Object.entries(value.value);
  writer.writeUint16(entries.length);
  for (const [key, item] of entries) {
    writer.writeString(key);
    DatabaseValueModel.write(writer, item);
  }
}
function compareObject(left, right, collation) {
  const leftKeys = Object.keys(left.value).sort();
  const rightKeys = Object.keys(right.value).sort();
  if (leftKeys.length < rightKeys.length) return -1;
  if (leftKeys.length > rightKeys.length) return 1;
  for (let i = 0; i < leftKeys.length; i++) {
    const leftKey = leftKeys[i];
    const rightKey = rightKeys[i];
    if (leftKey < rightKey) return -1;
    if (leftKey > rightKey) return 1;
    const leftValue = left.value[leftKey] ?? null;
    const rightValue = right.value[rightKey] ?? null;
    const result = DatabaseValueModel.compare(leftValue, rightValue, collation);
    if (result !== 0) return result;
  }
  return 0;
}
function readResponsiveImage(reader) {
  return {
    type: ControlType.ResponsiveImage,
    value: reader.readJson()
  };
}
function writeResponsiveImage(writer, value) {
  writer.writeJson(value.value);
}
function compareResponsiveImage(left, right) {
  const leftEncoded = JSON.stringify(left.value);
  const rightEncoded = JSON.stringify(right.value);
  if (leftEncoded < rightEncoded) return -1;
  if (leftEncoded > rightEncoded) return 1;
  return 0;
}
function readRichText(reader) {
  const type = reader.readInt8();
  if (type === 0) {
    return {
      type: ControlType.RichText,
      value: reader.readUint32()
    };
  }
  if (type === 1) {
    return {
      type: ControlType.RichText,
      value: reader.readString()
    };
  }
  throw new Error(\`Invalid rich text pointer\`);
}
function writeRichText(writer, value) {
  if (isNumber(value.value)) {
    writer.writeInt8(0);
    writer.writeUint32(value.value);
    return;
  }
  if (isString(value.value)) {
    writer.writeInt8(1);
    writer.writeString(value.value);
    return;
  }
  throw new Error(\`Invalid rich text pointer\`);
}
function compareRichText(left, right) {
  const leftValue = left.value;
  const rightValue = right.value;
  if (isNumber(leftValue) && isNumber(rightValue)) {
    if (leftValue < rightValue) return -1;
    if (leftValue > rightValue) return 1;
    return 0;
  }
  if (isString(leftValue) && isString(rightValue)) {
    if (leftValue < rightValue) return -1;
    if (leftValue > rightValue) return 1;
    return 0;
  }
  throw new Error(\`Invalid rich text pointer\`);
}
function readString(reader) {
  return {
    type: ControlType.String,
    value: reader.readString()
  };
}
function writeString(writer, value) {
  writer.writeString(value.value);
}
function compareString(left, right, collation) {
  let leftValue = left.value;
  let rightValue = right.value;
  if (collation.type === 0 /* CaseInsensitive */) {
    leftValue = left.value.toLowerCase();
    rightValue = right.value.toLowerCase();
  }
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}
function readVectorSetItem(reader) {
  return {
    type: ControlType.VectorSetItem,
    value: reader.readUint32()
  };
}
function writeVectorSetItem(writer, value) {
  writer.writeUint32(value.value);
}
function compareVectorSetItem(left, right) {
  const leftValue = left.value;
  const rightValue = right.value;
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}

// src/code-generation/components/cms/bundled/models/DatabaseDictionaryIndexModel.ts
var DatabaseDictionaryIndexModel = class _DatabaseDictionaryIndexModel {
  constructor(fieldNames, options) {
    this.fieldNames = fieldNames;
    this.options = options;
    __publicField(this, "entries", []);
  }
  sortEntries() {
    this.entries.sort((left, right) => {
      for (let i = 0; i < this.fieldNames.length; i++) {
        const leftValue = left.values[i];
        const rightValue = right.values[i];
        const result = DatabaseValueModel.compare(leftValue, rightValue, this.options.collation);
        if (result !== 0) return result;
      }
      return left.pointer.compare(right.pointer);
    });
  }
  static deserialize(bytes) {
    const reader = new BufferReader(bytes);
    const collation = reader.readJson();
    const fieldCount = reader.readUint8();
    const fieldNames = [];
    for (let i = 0; i < fieldCount; i++) {
      const fieldName = reader.readString();
      fieldNames.push(fieldName);
    }
    const index = new _DatabaseDictionaryIndexModel(fieldNames, {
      collation
    });
    const entryCount = reader.readUint32();
    for (let i = 0; i < entryCount; i++) {
      const values = [];
      for (let j = 0; j < fieldCount; j++) {
        const fieldValue = DatabaseValueModel.read(reader);
        values.push(fieldValue);
      }
      const pointer = DatabaseItemPointerModel.read(reader);
      index.entries.push({ values, pointer });
    }
    return index;
  }
  serialize() {
    const writer = new BufferWriter();
    writer.writeJson(this.options.collation);
    writer.writeUint8(this.fieldNames.length);
    for (const fieldName of this.fieldNames) {
      writer.writeString(fieldName);
    }
    this.sortEntries();
    writer.writeUint32(this.entries.length);
    for (const entry of this.entries) {
      const { values, pointer } = entry;
      for (const value of values) {
        DatabaseValueModel.write(writer, value);
      }
      pointer.write(writer);
    }
    return writer.subarray();
  }
  addItem(item, pointer) {
    const values = this.fieldNames.map((fieldName) => {
      return item.getField(fieldName) ?? null;
    });
    this.entries.push({ values, pointer });
  }
};

// src/code-generation/components/cms/bundled/fetchWithRetries.ts
var maxRetries = 3;
var baseDelay = 250;
var retriableHTTPCodes = [
  408,
  // Request Timeout
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
var fetchWithRetries = async (input, init) => {
  let retryCount = 0;
  while (true) {
    try {
      const res = await fetch(input, init);
      if (!retriableHTTPCodes.includes(res.status) || ++retryCount > maxRetries) {
        return res;
      }
    } catch (error) {
      if (init?.signal?.aborted || ++retryCount > maxRetries) {
        throw error;
      }
    }
    await retryDelay(retryCount);
  }
};
async function retryDelay(retryCount) {
  const backoffExponent = retryCount - 1;
  const jitter = Math.random() + 1;
  const timeout = Math.floor(baseDelay * jitter * 2 ** backoffExponent);
  await new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}

// src/code-generation/components/cms/bundled/rangeRequest.ts
async function rangeRequest(url, ranges) {
  const collapsedRanges = collapseRanges(ranges);
  const rangeStrings = [];
  let expectedLength = 0;
  for (const range of collapsedRanges) {
    rangeStrings.push(\`\${range.from}-\${range.to - 1}\`);
    expectedLength += range.to - range.from;
  }
  const rangeUrl = new URL(url);
  const rangeQuery = rangeStrings.join(",");
  rangeUrl.searchParams.set("range", rangeQuery);
  const response = await fetchWithRetries(rangeUrl);
  if (response.status !== 200) {
    throw new Error(\`Request failed: \${response.status} \${response.statusText}\`);
  }
  const buffer = await response.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  if (bytes.length !== expectedLength) {
    throw new Error("Request failed: Unexpected response length");
  }
  const file = new PartialFile();
  let start = 0;
  for (const range of collapsedRanges) {
    const length = range.to - range.from;
    const end = start + length;
    const part = bytes.subarray(start, end);
    file.write(range.from, part);
    start = end;
  }
  return ranges.map((range) => {
    return file.read(range.from, range.to - range.from);
  });
}
var PartialFile = class {
  constructor() {
    __publicField(this, "chunks", []);
  }
  read(position, length) {
    for (const chunk of this.chunks) {
      if (position < chunk.start) {
        throw new Error("Missing data");
      }
      if (position > chunk.end) {
        continue;
      }
      if (position + length > chunk.end) {
        throw new Error("Missing data");
      }
      const from = position - chunk.start;
      const to = from + length;
      return chunk.data.slice(from, to);
    }
    throw new Error("Missing data");
  }
  write(position, data) {
    let start = position;
    let end = start + data.length;
    let fromIndex = 0;
    let toIndex = this.chunks.length;
    for (; fromIndex < toIndex; fromIndex++) {
      const chunk2 = this.chunks[fromIndex];
      assert(chunk2, "Missing chunk");
      if (start > chunk2.end) {
        continue;
      }
      if (start > chunk2.start) {
        const offset = start - chunk2.start;
        const prefix = chunk2.data.subarray(0, offset);
        data = join(prefix, data);
        start = chunk2.start;
      }
      break;
    }
    for (; toIndex > fromIndex; toIndex--) {
      const chunk2 = this.chunks[toIndex - 1];
      assert(chunk2, "Missing chunk");
      if (end < chunk2.start) {
        continue;
      }
      if (end < chunk2.end) {
        const offset = end - chunk2.start;
        const suffix = chunk2.data.subarray(offset);
        data = join(data, suffix);
        end = chunk2.end;
      }
      break;
    }
    const chunk = {
      start,
      end,
      data
    };
    const deleteCount = toIndex - fromIndex;
    this.chunks.splice(fromIndex, deleteCount, chunk);
  }
};
function join(left, right) {
  const length = left.length + right.length;
  const result = new Uint8Array(length);
  result.set(left, 0);
  result.set(right, left.length);
  return result;
}
function collapseRanges(ranges) {
  assert(ranges.length > 0, "Must have at least one range");
  const sorted = [...ranges].sort((a, b) => a.from - b.from);
  const collapsed = [];
  for (const range of sorted) {
    const index = collapsed.length - 1;
    const previous = collapsed[index];
    if (previous && range.from <= previous.to) {
      collapsed[index] = {
        from: previous.from,
        to: Math.max(previous.to, range.to)
      };
    } else {
      collapsed.push(range);
    }
  }
  return collapsed;
}

// src/code-generation/components/cms/bundled/DatabaseDictionaryIndex.ts
var DatabaseDictionaryIndex = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "schema");
    __publicField(this, "fields");
    __publicField(this, "supportedLookupTypes", [
      "All" /* All */,
      "Equals" /* Equals */,
      "NotEquals" /* NotEquals */,
      "LessThan" /* LessThan */,
      "GreaterThan" /* GreaterThan */,
      "Contains" /* Contains */,
      "StartsWith" /* StartsWith */,
      "EndsWith" /* EndsWith */
    ]);
    __publicField(this, "modelPromise");
    __publicField(this, "model");
    __publicField(this, "collation");
    const schema = {};
    const fields = [];
    for (const fieldName of this.options.fieldNames) {
      const definition = this.options.collectionSchema[fieldName];
      assert(definition, "Missing definition for field", fieldName);
      schema[fieldName] = definition;
      fields.push({ type: "Identifier", name: fieldName });
    }
    this.schema = schema;
    this.fields = fields;
    this.collation = this.options.collation;
  }
  async loadModel() {
    const [bytes] = await rangeRequest(this.options.url, [this.options.range]);
    assert(bytes, "Failed to load model");
    return DatabaseDictionaryIndexModel.deserialize(bytes);
  }
  async getModel() {
    this.modelPromise ??= this.loadModel();
    this.model ??= await this.modelPromise;
    return this.model;
  }
  async lookupItems(queries) {
    assert(queries.length === this.fields.length, "Invalid query length");
    const model = await this.getModel();
    const chunks = queries.reduce(
      (memo, query, position) => memo.flatMap((entries) => {
        switch (query.type) {
          case "All" /* All */:
            return [entries];
          case "Equals" /* Equals */:
            return this.queryEquals(entries, query, position);
          case "NotEquals" /* NotEquals */:
            return this.queryNotEquals(entries, query, position);
          case "LessThan" /* LessThan */:
            return this.queryLessThan(entries, query, position);
          case "GreaterThan" /* GreaterThan */:
            return this.queryGreaterThan(entries, query, position);
          case "Contains" /* Contains */:
            return this.queryContains(entries, query, position);
          case "StartsWith" /* StartsWith */:
            return this.queryStartsWith(entries, query, position);
          case "EndsWith" /* EndsWith */:
            return this.queryEndsWith(entries, query, position);
          default:
            assertNever(query);
        }
      }),
      [model.entries]
    );
    const result = [];
    for (const entries of chunks) {
      for (const entry of entries) {
        const data = {};
        for (let i = 0; i < this.options.fieldNames.length; i++) {
          const fieldName = this.options.fieldNames[i];
          const fieldValue = entry.values[i];
          data[fieldName] = fieldValue;
        }
        result.push({ pointer: entry.pointer.toString(), data });
      }
    }
    return result;
  }
  queryEquals(entries, query, position) {
    const leftMost = this.getLeftMost(entries, position, query.value);
    const rightMost = this.getRightMost(entries, position, query.value);
    const slice = entries.slice(leftMost, rightMost + 1);
    return slice.length > 0 ? [slice] : [];
  }
  queryNotEquals(entries, query, position) {
    const leftMost = this.getLeftMost(entries, position, query.value);
    const rightMost = this.getRightMost(entries, position, query.value);
    const result = [];
    const before = entries.slice(0, leftMost);
    if (before.length > 0) result.push(before);
    const after = entries.slice(rightMost + 1);
    if (after.length > 0) result.push(after);
    return result;
  }
  queryLessThan(entries, query, position) {
    const nullBound = this.getRightMost(entries, position, null);
    entries = entries.slice(nullBound + 1);
    if (query.inclusive) {
      const rightMost = this.getRightMost(entries, position, query.value);
      const slice2 = entries.slice(0, rightMost + 1);
      return slice2.length > 0 ? [slice2] : [];
    }
    const leftMost = this.getLeftMost(entries, position, query.value);
    const slice = entries.slice(0, leftMost);
    return slice.length > 0 ? [slice] : [];
  }
  queryGreaterThan(entries, query, position) {
    const nullBound = this.getRightMost(entries, position, null);
    entries = entries.slice(nullBound + 1);
    if (query.inclusive) {
      const leftMost = this.getLeftMost(entries, position, query.value);
      const slice2 = entries.slice(leftMost);
      return slice2.length > 0 ? [slice2] : [];
    }
    const rightMost = this.getRightMost(entries, position, query.value);
    const slice = entries.slice(rightMost + 1);
    return slice.length > 0 ? [slice] : [];
  }
  queryContains(entries, query, position) {
    return this.findItems(entries, position, (current) => {
      if (current?.type !== ControlType2.String) return false;
      if (query.value?.type !== ControlType2.String) return false;
      let source = current.value;
      let target = query.value.value;
      if (this.collation.type === 0 /* CaseInsensitive */) {
        source = source.toLowerCase();
        target = target.toLowerCase();
      }
      return source.includes(target);
    });
  }
  queryStartsWith(entries, query, position) {
    return this.findItems(entries, position, (current) => {
      if (current?.type !== ControlType2.String) return false;
      if (query.value?.type !== ControlType2.String) return false;
      let source = current.value;
      let target = query.value.value;
      if (this.collation.type === 0 /* CaseInsensitive */) {
        source = source.toLowerCase();
        target = target.toLowerCase();
      }
      return source.startsWith(target);
    });
  }
  queryEndsWith(entries, query, position) {
    return this.findItems(entries, position, (current) => {
      if (current?.type !== ControlType2.String) return false;
      if (query.value?.type !== ControlType2.String) return false;
      let source = current.value;
      let target = query.value.value;
      if (this.collation.type === 0 /* CaseInsensitive */) {
        source = source.toLowerCase();
        target = target.toLowerCase();
      }
      return source.endsWith(target);
    });
  }
  /**
   * Returns the index of the left most entry that is equal to the target.
   *
   * \`\`\`text
   *   Left most
   *       \u2193
   * \u250C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2510
   * \u2502 1 \u2502 2 \u2502 2 \u2502 2 \u2502 2 \u2502 3 \u2502
   * \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518
   * \`\`\`
   *
   * @param entries The entries array to search in.
   * @param position The position of the value in the entry.
   * @param target The target value to search for.
   * @returns The index of the left most entry that is equal to the target.
   */
  getLeftMost(entries, position, target) {
    let left = 0;
    let right = entries.length;
    while (left < right) {
      const middle = left + right >> 1;
      const entry = entries[middle];
      const value = entry.values[position];
      if (DatabaseValueModel.compare(value, target, this.collation) < 0) {
        left = middle + 1;
      } else {
        right = middle;
      }
    }
    return left;
  }
  /**
   * Returns the index of the right most entry that is equal to the target.
   *
   * \`\`\`text
   *              Right most
   *                   \u2193
   * \u250C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2510
   * \u2502 1 \u2502 2 \u2502 2 \u2502 2 \u2502 2 \u2502 3 \u2502
   * \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518
   * \`\`\`
   *
   * @param entries The entries array to search in.
   * @param position The position of the value in the entry.
   * @param target The target value to search for.
   * @returns The index of the right most entry that is equal to the target.
   */
  getRightMost(entries, position, target) {
    let left = 0;
    let right = entries.length;
    while (left < right) {
      const middle = left + right >> 1;
      const entry = entries[middle];
      const value = entry.values[position];
      if (DatabaseValueModel.compare(value, target, this.collation) > 0) {
        right = middle;
      } else {
        left = middle + 1;
      }
    }
    return right - 1;
  }
  /**
   * Finds all items that are matching the predicate and groups adjacent items together.
   *
   * @param entries The entries array to search in.
   * @param position The position of the value in the entry.
   * @param predicate The predicate to match the values against.
   * @returns An array of chunks that match the predicate.
   */
  findItems(entries, position, predicate) {
    const result = [];
    let start = 0;
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const value = entry.values[position];
      const isMatching = predicate(value);
      if (isMatching) continue;
      if (start < i) {
        const slice = entries.slice(start, i);
        result.push(slice);
      }
      start = i + 1;
    }
    if (start < entries.length) {
      const slice = entries.slice(start);
      result.push(slice);
    }
    return result;
  }
};

// src/code-generation/components/cms/bundled/models/DatabaseItemModel.ts
var DatabaseItemModel = class _DatabaseItemModel {
  constructor() {
    __publicField(this, "fields", /* @__PURE__ */ new Map());
  }
  static read(reader) {
    const item = new _DatabaseItemModel();
    const fieldCount = reader.readUint16();
    for (let i = 0; i < fieldCount; i++) {
      const key = reader.readString();
      const value = DatabaseValueModel.read(reader);
      item.setField(key, value);
    }
    return item;
  }
  write(writer) {
    writer.writeUint16(this.fields.size);
    for (const [key, value] of this.fields) {
      writer.writeString(key);
      DatabaseValueModel.write(writer, value);
    }
  }
  getData() {
    const data = {};
    for (const [key, value] of this.fields) {
      data[key] = value;
    }
    return data;
  }
  setField(key, value) {
    this.fields.set(key, value);
  }
  getField(key) {
    return this.fields.get(key);
  }
};

// src/code-generation/components/cms/bundled/DatabaseCollection.ts?bundle
var DatabaseChunk = class {
  constructor(id, url) {
    this.id = id;
    this.url = url;
    __publicField(this, "itemsPromise");
    __publicField(this, "itemLoader", new import_dataloader.default(
      async (pointers) => {
        const ranges = pointers.map((pointer) => {
          const pointerModel = DatabaseItemPointerModel.fromString(pointer);
          return { from: pointerModel.offset, to: pointerModel.offset + pointerModel.length };
        });
        const rangeBytes = await rangeRequest(this.url, ranges);
        return rangeBytes.map((bytes, index) => {
          const reader = new BufferReader(bytes);
          const itemModel = DatabaseItemModel.read(reader);
          const pointer = pointers[index];
          assert(pointer, "Missing pointer");
          return {
            pointer,
            data: itemModel.getData()
          };
        });
      },
      { maxBatchSize: 500 }
    ));
  }
  scanItems() {
    this.itemsPromise ??= fetchWithRetries(this.url).then(async (response) => {
      if (!response.ok) {
        throw new Error(\`Request failed: \${response.status} \${response.statusText}\`);
      }
      const buffer = await response.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      const reader = new BufferReader(bytes);
      const items = [];
      const itemCount = reader.readUint32();
      for (let i = 0; i < itemCount; i++) {
        const offset = reader.getOffset();
        const itemModel = DatabaseItemModel.read(reader);
        const length = reader.getOffset() - offset;
        const pointerModel = new DatabaseItemPointerModel(this.id, offset, length);
        const pointer = pointerModel.toString();
        const item = {
          pointer,
          data: itemModel.getData()
        };
        this.itemLoader.prime(pointer, item);
        items.push(item);
      }
      return items;
    });
    return this.itemsPromise;
  }
  resolveItem(pointer) {
    return this.itemLoader.load(pointer);
  }
};
var DatabaseCollection = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "id");
    __publicField(this, "schema");
    __publicField(this, "indexes");
    __publicField(this, "resolveRichText");
    __publicField(this, "resolveVectorSetItem");
    __publicField(this, "chunks");
    this.chunks = this.options.chunks.map((url, id) => {
      return new DatabaseChunk(id, url);
    });
    this.schema = options.schema;
    this.indexes = options.indexes;
    this.resolveRichText = options.resolveRichText;
    this.resolveVectorSetItem = options.resolveVectorSetItem;
    this.id = options.id;
  }
  async scanItems() {
    const chunkedItems = await Promise.all(
      this.chunks.map(async (chunk) => {
        return chunk.scanItems();
      })
    );
    return chunkedItems.flat();
  }
  resolveItems(pointers) {
    return Promise.all(
      pointers.map((pointer) => {
        const pointerModel = DatabaseItemPointerModel.fromString(pointer);
        const chunk = this.chunks[pointerModel.chunkId];
        assert(chunk, "Missing chunk");
        return chunk.resolveItem(pointer);
      })
    );
  }
  compareItems(left, right) {
    const leftModel = DatabaseItemPointerModel.fromString(left.pointer);
    const rightModel = DatabaseItemPointerModel.fromString(right.pointer);
    return leftModel.compare(rightModel);
  }
  compareValues(left, right, collation) {
    return DatabaseValueModel.compare(left, right, collation);
  }
};
export {
  DatabaseCollection,
  DatabaseDictionaryIndex
};
`;var Lc=`var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/code-generation/components/cms/bundled/DraftDatabaseCollection.ts?bundle
import { ControlType } from "framer";

// src/utils/typeChecks.ts
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return Number.isFinite(value);
}

// src/code-generation/components/cms/bundled/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  throw Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
}

// src/code-generation/components/cms/bundled/DraftDatabaseCollection.ts?bundle
var DraftDatabaseCollection = class {
  constructor(draftCollection, originalCollection, previousItemId, nextItemId) {
    this.draftCollection = draftCollection;
    this.originalCollection = originalCollection;
    this.previousItemId = previousItemId;
    this.nextItemId = nextItemId;
    __publicField(this, "schema");
    // We cannot use the original indexes because the draft items
    // are not in the original collection.
    // Having no indexes means that we perform a full collection scan for every query.
    __publicField(this, "indexes", []);
    __publicField(this, "itemsPromise");
    this.schema = originalCollection.schema;
    this.itemsPromise = this.getItems();
  }
  async getItems() {
    const [[...draftItems], [...originalItems]] = await Promise.all([
      this.draftCollection.scanItems(),
      this.originalCollection.scanItems()
    ]);
    const lastDraftItem = draftItems.pop();
    const firstOriginalItem = originalItems.shift();
    if (lastDraftItem) {
      draftItems.push({
        ...lastDraftItem,
        data: {
          ...lastDraftItem.data,
          [this.nextItemId]: firstOriginalItem?.data.id ?? null
        }
      });
    }
    if (firstOriginalItem) {
      originalItems.unshift({
        ...firstOriginalItem,
        data: {
          ...firstOriginalItem.data,
          [this.previousItemId]: lastDraftItem?.data.id ?? null
        }
      });
    }
    return draftItems.map(draftItem).concat(...originalItems);
  }
  /**
   * Get all items, updating pointers for draft items.
   */
  scanItems() {
    return this.itemsPromise;
  }
  /**
   * Depending on the pointer, resolve draft rich text from the draft
   * collection, and original rich text from the original collection.
   */
  resolveRichText(pointer) {
    if (isDraftRichTextPointer(pointer)) {
      const originalPointer = undraftRichTextPointer(pointer);
      return this.draftCollection.resolveRichText(originalPointer);
    }
    return this.originalCollection.resolveRichText(pointer);
  }
  resolveVectorSetItem(pointer) {
    if (isDraftVectorSetItemPointer(pointer)) {
      const originalPointer = undraftVectorSetItemPointer(pointer);
      return this.draftCollection.resolveVectorSetItem?.(originalPointer);
    }
    return this.originalCollection.resolveVectorSetItem?.(pointer);
  }
  async resolveItems(pointers) {
    const items = await this.itemsPromise;
    return pointers.map((pointer) => {
      const item = items.find((current) => current.pointer === pointer);
      assert(item, "Item must exist");
      return item;
    });
  }
  /**
   * Compare two items, the draft items should come first.
   */
  compareItems(left, right) {
    const leftIsDraft = isDraftPointer(left.pointer);
    const rightIsDraft = isDraftPointer(right.pointer);
    if (leftIsDraft && rightIsDraft) {
      const originalLeft = undraftItem(left);
      const originalRight = undraftItem(right);
      return this.draftCollection.compareItems(originalLeft, originalRight);
    }
    if (leftIsDraft) return -1;
    if (rightIsDraft) return 1;
    return this.originalCollection.compareItems(left, right);
  }
};
var draftPrefix = "draft:";
function isDraftPointer(pointer) {
  return pointer.startsWith(draftPrefix);
}
function draftPointer(pointer) {
  assert(!isDraftPointer(pointer), "Should be a non-draft pointer");
  return draftPrefix + pointer;
}
function undraftPointer(pointer) {
  assert(isDraftPointer(pointer), "Should be a draft pointer");
  return pointer.slice(draftPrefix.length);
}
function isDraftRichTextPointer(pointer) {
  if (isNumber(pointer)) {
    return pointer < 0;
  }
  if (isString(pointer)) {
    return pointer.startsWith(draftPrefix);
  }
  throw new Error("Invalid rich text pointer");
}
function draftRichTextPointer(pointer) {
  assert(!isDraftRichTextPointer(pointer), "Should be a non-draft rich text pointer");
  if (isNumber(pointer)) {
    return -pointer - 1;
  }
  if (isString(pointer)) {
    return draftPrefix + pointer;
  }
  throw new Error("Invalid rich text pointer");
}
function undraftRichTextPointer(pointer) {
  assert(isDraftRichTextPointer(pointer), "Should be a draft rich text pointer");
  if (isNumber(pointer)) {
    return -pointer - 1;
  }
  if (isString(pointer)) {
    return pointer.slice(draftPrefix.length);
  }
  throw new Error("Invalid rich text pointer");
}
function isDraftVectorSetItemPointer(pointer) {
  assert(isNumber(pointer), "Invalid vector set item pointer");
  return pointer < 0;
}
function draftVectorSetItemPointer(pointer) {
  assert(isNumber(pointer), "Invalid vector set item pointer");
  assert(!isDraftVectorSetItemPointer(pointer), "Should be a non-draft vector set item pointer");
  return -pointer - 1;
}
function undraftVectorSetItemPointer(pointer) {
  assert(isNumber(pointer), "Invalid vector set item pointer");
  assert(isDraftVectorSetItemPointer(pointer), "Should be a draft vector set item pointer");
  return -pointer - 1;
}
function draftItem(item) {
  const data = {};
  for (const [key, value] of Object.entries(item.data)) {
    if (value?.type === ControlType.RichText) {
      data[key] = {
        type: ControlType.RichText,
        value: draftRichTextPointer(value.value)
      };
    } else if (value?.type === ControlType.VectorSetItem) {
      data[key] = {
        type: ControlType.VectorSetItem,
        value: draftVectorSetItemPointer(value.value)
      };
    } else {
      data[key] = value;
    }
  }
  return {
    pointer: draftPointer(item.pointer),
    data
  };
}
function undraftItem(item) {
  const data = {};
  for (const [key, value] of Object.entries(item.data)) {
    if (value?.type === ControlType.RichText) {
      data[key] = {
        type: ControlType.RichText,
        value: undraftRichTextPointer(value.value)
      };
    } else if (value?.type === ControlType.VectorSetItem) {
      data[key] = {
        type: ControlType.VectorSetItem,
        value: undraftVectorSetItemPointer(value.value)
      };
    } else {
      data[key] = value;
    }
  }
  return {
    pointer: undraftPointer(item.pointer),
    data
  };
}
export {
  DraftDatabaseCollection
};
`;var Ir=class o{constructor(t,e,r){this.chunkId=t;this.offset=e;this.length=r}static fromString(t){let[e,r,n]=t.split("/").map(Number);return q(B(e),"Invalid chunkId"),q(B(r),"Invalid offset"),q(B(n),"Invalid length"),new o(e,r,n)}toString(){return`${this.chunkId}/${this.offset}/${this.length}`}static read(t){let e=t.readUint16(),r=t.readUint32(),n=t.readUint32();return new o(e,r,n)}write(t){t.writeUint16(this.chunkId),t.writeUint32(this.offset),t.writeUint32(this.length)}compare(t){return this.chunkId<t.chunkId?-1:this.chunkId>t.chunkId?1:this.offset<t.offset?-1:this.offset>t.offset?1:(q(this.length===t.length),0)}};function qi(o){if(Ar(o))return 0;switch(o.type){case"array":return 1;case"boolean":return 2;case"color":return 3;case"date":return 4;case"enum":return 5;case"file":return 6;case"responsiveimage":return 10;case"link":return 7;case"number":return 8;case"object":return 9;case"richtext":return 11;case"string":return 12;case"vectorsetitem":return 13;default:Xr(o)}}var ce;(r=>{function o(n){let i=n.readUint8();switch(i){case 0:return null;case 1:return Ou(n);case 2:return zu(n);case 3:return qu(n);case 4:return Ju(n);case 5:return Qu(n);case 6:return Zu(n);case 7:return rf(n);case 8:return sf(n);case 9:return cf(n);case 10:return ff(n);case 11:return hf(n);case 12:return vf(n);case 13:return Cf(n);default:Xr(i)}}r.read=o;function t(n,i){let s=qi(i);if(n.writeUint8(s),!Ar(i))switch(i.type){case"array":return Bu(n,i);case"boolean":return ju(n,i);case"color":return Wu(n,i);case"date":return Gu(n,i);case"enum":return Yu(n,i);case"file":return ef(n,i);case"link":return nf(n,i);case"number":return af(n,i);case"object":return lf(n,i);case"responsiveimage":return mf(n,i);case"richtext":return gf(n,i);case"vectorsetitem":return Tf(n,i);case"string":return bf(n,i);default:Xr(i)}}r.write=t;function e(n,i,s){let a=qi(n),d=qi(i);if(a<d)return-1;if(a>d)return 1;if(Ar(n)||Ar(i))return 0;switch(n.type){case"array":return q(i.type==="array"),_u(n,i,s);case"boolean":return q(i.type==="boolean"),$u(n,i);case"color":return q(i.type==="color"),Hu(n,i);case"date":return q(i.type==="date"),Ku(n,i);case"enum":return q(i.type==="enum"),Xu(n,i);case"file":return q(i.type==="file"),tf(n,i);case"link":return q(i.type==="link"),of(n,i);case"number":return q(i.type==="number"),df(n,i);case"object":return q(i.type==="object"),uf(n,i,s);case"responsiveimage":return q(i.type==="responsiveimage"),pf(n,i);case"richtext":return q(i.type==="richtext"),yf(n,i);case"vectorsetitem":return q(i.type==="vectorsetitem"),If(n,i);case"string":return q(i.type==="string"),Sf(n,i,s);default:Xr(n)}}r.compare=e})(ce||={});function Ou(o){let t=o.readUint16(),e=[];for(let r=0;r<t;r++){let n=ce.read(o);e.push(n)}return{type:"array",value:e}}function Bu(o,t){o.writeUint16(t.value.length);for(let e of t.value)ce.write(o,e)}function _u(o,t,e){let r=o.value.length,n=t.value.length;if(r<n)return-1;if(r>n)return 1;for(let i=0;i<r;i++){let s=o.value[i],a=t.value[i],d=ce.compare(s,a,e);if(d!==0)return d}return 0}function zu(o){return{type:"boolean",value:o.readUint8()!==0}}function ju(o,t){o.writeUint8(t.value?1:0)}function $u(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function qu(o){return{type:"color",value:o.readString()}}function Wu(o,t){o.writeString(t.value)}function Hu(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function Ju(o){let t=o.readInt64(),e=new Date(t);return{type:"date",value:e.toISOString()}}function Gu(o,t){let r=new Date(t.value).getTime();o.writeInt64(r)}function Ku(o,t){let e=new Date(o.value),r=new Date(t.value);return e<r?-1:e>r?1:0}function Qu(o){return{type:"enum",value:o.readString()}}function Yu(o,t){o.writeString(t.value)}function Xu(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function Zu(o){return{type:"file",value:o.readString()}}function ef(o,t){o.writeString(t.value)}function tf(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function rf(o){return{type:"link",value:o.readJson()}}function nf(o,t){o.writeJson(t.value)}function of(o,t){let e=JSON.stringify(o.value),r=JSON.stringify(t.value);return e<r?-1:e>r?1:0}function sf(o){return{type:"number",value:o.readFloat64()}}function af(o,t){o.writeFloat64(t.value)}function df(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function cf(o){let t=o.readUint16(),e={};for(let r=0;r<t;r++){let n=o.readString();e[n]=ce.read(o)}return{type:"object",value:e}}function lf(o,t){let e=Object.entries(t.value);o.writeUint16(e.length);for(let[r,n]of e)o.writeString(r),ce.write(o,n)}function uf(o,t,e){let r=Object.keys(o.value).sort(),n=Object.keys(t.value).sort();if(r.length<n.length)return-1;if(r.length>n.length)return 1;for(let i=0;i<r.length;i++){let s=r[i],a=n[i];if(s<a)return-1;if(s>a)return 1;let d=o.value[s]??null,c=t.value[a]??null,u=ce.compare(d,c,e);if(u!==0)return u}return 0}function ff(o){return{type:"responsiveimage",value:o.readJson()}}function mf(o,t){o.writeJson(t.value)}function pf(o,t){let e=JSON.stringify(o.value),r=JSON.stringify(t.value);return e<r?-1:e>r?1:0}function hf(o){let t=o.readInt8();if(t===0)return{type:"richtext",value:o.readUint32()};if(t===1)return{type:"richtext",value:o.readString()};throw new Error("Invalid rich text pointer")}function gf(o,t){if(B(t.value)){o.writeInt8(0),o.writeUint32(t.value);return}if(Z(t.value)){o.writeInt8(1),o.writeString(t.value);return}throw new Error("Invalid rich text pointer")}function yf(o,t){let e=o.value,r=t.value;if(B(e)&&B(r)||Z(e)&&Z(r))return e<r?-1:e>r?1:0;throw new Error("Invalid rich text pointer")}function vf(o){return{type:"string",value:o.readString()}}function bf(o,t){o.writeString(t.value)}function Sf(o,t,e){let r=o.value,n=t.value;return e.type===0&&(r=o.value.toLowerCase(),n=t.value.toLowerCase()),r<n?-1:r>n?1:0}function Cf(o){return{type:"vectorsetitem",value:o.readUint32()}}function Tf(o,t){o.writeUint32(t.value)}function If(o,t){let e=o.value,r=t.value;return e<r?-1:e>r?1:0}var Je=class o{constructor(t,e){this.fieldNames=t;this.options=e;f(this,"entries",[])}sortEntries(){this.entries.sort((t,e)=>{for(let r=0;r<this.fieldNames.length;r++){let n=t.values[r],i=e.values[r],s=ce.compare(n,i,this.options.collation);if(s!==0)return s}return t.pointer.compare(e.pointer)})}static deserialize(t){let e=new bo(t),r=e.readJson(),n=e.readUint8(),i=[];for(let d=0;d<n;d++){let c=e.readString();i.push(c)}let s=new o(i,{collation:r}),a=e.readUint32();for(let d=0;d<a;d++){let c=[];for(let l=0;l<n;l++){let h=ce.read(e);c.push(h)}let u=Ir.read(e);s.entries.push({values:c,pointer:u})}return s}serialize(){let t=new zt;t.writeJson(this.options.collation),t.writeUint8(this.fieldNames.length);for(let e of this.fieldNames)t.writeString(e);this.sortEntries(),t.writeUint32(this.entries.length);for(let e of this.entries){let{values:r,pointer:n}=e;for(let i of r)ce.write(t,i);n.write(t)}return t.subarray()}addItem(t,e){let r=this.fieldNames.map(n=>t.getField(n)??null);this.entries.push({values:r,pointer:e})}};var So=class o{constructor(){f(this,"fields",new Map)}static read(t){let e=new o,r=t.readUint16();for(let n=0;n<r;n++){let i=t.readString(),s=ce.read(t);e.setField(i,s)}return e}write(t){t.writeUint16(this.fields.size);for(let[e,r]of this.fields)t.writeString(e),ce.write(t,r)}getData(){let t={};for(let[e,r]of this.fields)t[e]=r;return t}setField(t,e){this.fields.set(t,e)}getField(t){return this.fields.get(t)}};function Wi(o){return p`${o}.replace("/modules/", "/cms/")`}var wf=x("serializeDatabase"),Hi=4*1024*1024,Nf=5e3;async function kc(o,t,e,r,n,i,s,a,d,c,u,l,h){let g=new yo(o,t,e,s,n,c,u,a,d),y=o.getPropertyControls(e.tree,t),b=Object.entries(y),v=$s(e.tree,"includeDrafts"),C={[tt]:{type:Vt("string",s),isNullable:!1},[Ho]:{type:Vt("date",s),isNullable:!0},[Jo]:{type:Vt("date",s),isNullable:!0},[Fr]:{type:Vt("string",s),isNullable:!0},[Ur]:{type:Vt("string",s),isNullable:!0}};function w(O){return Vt(O,s)}for(let[O,xe]of b){let Ue=Od(xe,w);Ue&&(C[O]=Ue)}let R=u.dedupe("schema",new $(C,0)),E=Ad(o.variables),D=o.getSlugVariable(),L=n.create(Ec),V,F,se=h?!0:void 0,ue=o.getSortedChildren().filter(O=>O.isDraft===se),Qe=crypto.randomUUID();if(h){let O=Q("collection",o.id);if(V=p`${s.addImport(`../${O}`,{exportSpecifier:"default",importBinding:"originalCollection"})}.collectionByLocaleId`,ue.length===0){let Ue={id:Qe,displayName:o.resolveValue("name")??"Unknown",collectionByLocaleId:V};return p`${Ue}`}let xe=n.create(Lc);F=s.addImport(xe.submoduleImport,{exportSpecifier:"DraftDatabaseCollection"})}let st=s.addImport(L.submoduleImport,{exportSpecifier:"DatabaseCollection"}),at={};for(let O of v){let kr=function(){let k=new zt;return k.writeUint32(0),k},qt=function(k){let P=Se.subarray(0,k);Tr(P).setUint32(0,Pr),Rt.push(P)};var Ye=kr,Lr=qt;let xe=[new Je([tt],{collation:{type:1}}),new Je([Fr],{collation:{type:1}}),new Je([Ur],{collation:{type:1}})];D&&xe.push(new Je([tt,D.id],{collation:{type:1}}),new Je([D.id,tt],{collation:{type:1}}));for(let[k]of b)xe.push(new Je([k],{collation:{type:0}}));let Ue=new vo,$t=ue.filter(k=>{let P=xd(e.tree,k);return P?P.includes(O.id):!0}),sn=[];for(let k=0;k<$t.length;k++){let P=$t[k];m(P,"Node must exist");let J=new So;J.setField(tt,{type:"string",value:P.id});let Xe=P.createdAt;Xe&&J.setField(Ho,{type:"date",value:new Date(Xe).toISOString()});let De=P.updatedAt;De&&J.setField(Jo,{type:"date",value:new Date(De).toISOString()});let Jt=$t[k-1];Jt&&J.setField(Fr,{type:"string",value:Jt.id});let ln=$t[k+1];ln&&J.setField(Ur,{type:"string",value:ln.id});let xt={resolveColor(G){return l.addColor(G)},resolveFile(G){return a.resolve(G)?.src},resolveImage(G,fe){return a.resolveResponsiveImage(G,{focalPoint:fe})},resolveLink(G){let fe=d.create(G);if(!U(fe)&&!xs(fe))return fe},resolveRichTextPointer(G){return g.add(G)},resolveVectorSetItemPointer(G){return Ue.add(G)}};for(let[G,fe]of b){let un=Fd(G,fe,E,y,P);if(U(un))continue;let os=Ud({control:fe,controlProp:un,resolvers:xt,locale:O});U(os)||J.setField(G,os)}sn.push(J)}let Rt=[],Pr=0,Se=kr();for(let k of sn){let P=Se.getOffset();k.write(Se),Se.getOffset()>Hi&&(qt(P),Se=kr(),P=Se.getOffset(),Pr=0,k.write(Se)),Pr++;let J=Se.getOffset()-P,Xe=new Ir(Rt.length,P,J);for(let De of xe)De.addItem(k,Xe)}Se.getOffset()>0&&qt();let Ao=s.addImport(L.submoduleImport,{exportSpecifier:"DatabaseDictionaryIndex"}),an=Rt.map((k,P)=>Wi(i.create(`chunk-${O.id}-${P}`,_i,k)));Rt.reduce((k,P)=>k+P.length,0)<Nf&&(xe.length=0);let Wt=[],Ht=1/0;for(let k of xe){let P=k.serialize();if(P.length>=Hi){wf.warn("Skipping index:",P.length);continue}Ht+P.length>Hi&&(Wt.push([]),Ht=0);let J=Wt.at(-1);m(J,"Chunk must exist"),J.push({model:k,bytes:P}),Ht+=P.length}let dn=[];for(let k=0;k<Wt.length;k++){let P=Wt[k];m(P,"Chunk must exist");let J=new zt,Xe=[];for(let{bytes:xt}of P){let G=J.getOffset();J.writeBytes(xt);let fe=J.getOffset();Xe.push({from:G,to:fe})}let De=J.subarray(),Jt=Wi(i.create(`indexes-${O.id}-${k}`,_i,De)),ln=P.map(({model:xt},G)=>{if(xt instanceof Je){let fe=Xe[G];m(fe,"Can't find range for index");let un={url:Jt,range:fe,fieldNames:u.dedupe("fieldNames",xt.fieldNames),collation:u.dedupe("collation",xt.options.collation),collectionSchema:R};return p`new ${Ao}(${un})`}throw new Error("Unsupported index type")});dn.push(...ln)}let Fo=Ue.serialize(t,r,u),cn={id:Qe+O.id,schema:R,chunks:an,indexes:dn,resolveRichText:g.resolveRichTextBinding,resolveVectorSetItem:Fo};if(V&&F){let k=p`new ${st}(${cn})`,P=p`${V}[${O.id}]`;at[O.id]=p`new ${F}(${k}, ${P}, ${Fr}, ${Ur})`}else at[O.id]=p`new ${st}(${cn})`}g.serialize();let oe={id:Qe,displayName:o.resolveValue("name")??"Unknown",collectionByLocaleId:at};return p`${oe}`}var Mc=te(async(o,t,e)=>Promise.all([Pc(o.id,t,!1),Pc(o.id,t,!0)]));async function Pc(o,t,e){let{componentLoader:r,modulesStore:n,treeStore:i,assetMap:s}=t,{tree:a}=i,d=e?"draftCollection":"collection",c=new Fn(s),u=new go(o),l=new sd(d,r,n,o),h=a.getNodeWithTrait(o,ee);m(h,"Must have a source node to serialize");let g=h.moduleSourceRevision,y=Ea(h);await Mn(y,n,r);let{module:b}=Da(r,n,h);ke("collection_update",{moduleId:b?.id,recordCount:h.getItemCount(),source:"unknown"});let v=h.getSlugVariable()?.id,C=new Pt,w=new rr(d,r,n,C),R=new Tn(C),E=new xn(h,r,w,C,void 0,i,n),D=new Cn,L=await kc(h,r,i,n,l,u,w,c,E,C,R,D,e),V=mt("",{framerRecordIdKey:tt,framerSlug:v,framerEnumToDisplayNameUtils:"2",framerCollectionUtils:"1",framerCollectionId:h.id,framerColorSyntax:D.hasColorsOfType("wideGamut"),framerAutoSizeImages:!0,framerData:!0}),F=C.create("data"),se=kf(h,F,i,r,w,d),ue=Df(w,R,F,tt,v),Qe=p.joinLines(...w.statements,...R.list(),V,p`const ${F} = ${L}`,p`export default ${F}`,se,...xf(h.variables,a.root.locales),ue);return{type:d,revision:g,source:Qe,artifacts:{assets:new Set(c.keys),binaryAssets:u.assets,submodules:l.serialize(),metrics:{nodes:h.getItemCount()}}}}function xf(o,t){let e=[],r=new $;for(let n of o){if(n.type!=="enum")continue;let i=new I(La(n.id));e.push(p`export const ${i} = ${Nc(n,t,i)};`),r[n.id]=i}return e.push(p`export const ${new I(En)} = ${r};`),e}function Df(o,t,e,r,n){return p.joinLines(p`export const utils = {`,p`async getSlugByRecordId(id, locale) {`,n?Ef(o,t,e,r,n):void 0,p`},`,p`async getRecordIdBySlug(slug, locale) {`,n?Lf(o,t,e,r,n):void 0,p`},`,p`}`)}function Vc(o,t){let e=o.addImport("framer",{exportSpecifier:"QueryEngine"});return t.dedupe("queryEngine",p`new ${e}()`)}function Ef(o,t,e,r,n){let i=Vc(o,t),s={from:{type:"Collection",data:e},select:[{type:"Identifier",name:n}],where:{type:"BinaryOperation",operator:"==",left:{type:"Identifier",name:r},right:{type:"LiteralValue",value:p`id`}},limit:{type:"LiteralValue",value:1}};return p.joinLines(p`const [item] = await ${i}.query(${s}, locale)`,p`return item?.[${n}]`)}function Lf(o,t,e,r,n){let i=Vc(o,t),s={from:{type:"Collection",data:e},select:[{type:"Identifier",name:r}],where:{type:"BinaryOperation",operator:"==",left:{type:"Identifier",name:n},right:{type:"LiteralValue",value:p`slug`}},limit:{type:"LiteralValue",value:1}};return p.joinLines(p`const [item] = await ${i}.query(${s}, locale)`,p`return item?.[${r}]`)}function kf(o,t,e,r,n,i){let s=Vd(o,r,e,n,void 0,i,"ContentManagement");if(U(s))return;let a=n.addImport("framer",{exportSpecifier:"addPropertyControls"});return I.fn(a,t,s)}function Co({componentName:o,fontObjects:t,fontReferences:e,imports:r,declarations:n,sharedFontArrays:i=[]}){return p.joinLines(...n.list(),I.fn(r.addImport("framer",{exportSpecifier:"addFonts"}),o,Zr({fontObjects:t,fontReferences:e,sharedFontArrays:i}),{supportsExplicitInterCodegen:!0}))}function Zr({fontObjects:o,fontReferences:t,sharedFontArrays:e=[]}){let r=[],n={explicitInter:!0,fonts:[]};for(let i of o){try{new URL(i.url)}catch(s){throw new Error(`Expected URL for font "${i.uiFamilyName}" to be a valid, absolute URL, but got: ${i.url}`,{cause:s})}n.fonts.push(i)}r.push(n);for(let i of t.values())r.push(p`...${i}`);for(let i of e)r.push(p`...${i}`);return r}var Ac=te(async(o,{componentLoader:t,assetMap:e,treeStore:r,modulesStore:n})=>{let i=new Pt,s=new Fn(e),a=new rr("componentPresets",t,n,i),d=new xn(o,t,a,i,void 0,r,n),c=new Tn(i),u=new ma(o,i),l=new ed(o,r,u,c,i,a,s),h=new id(i,u,l,s,d),g=o.moduleSourceRevision,y={},b={},v=o.getComponentPresets();await Mn(v.map(R=>R.componentIdentifier),n,t);let C=new Pt,w=new In(C);for(let R of v){let E=t.reactComponentForIdentifier(R.componentIdentifier);m(E,"Can't find react component for preset");let D=R.getFontsForCodeGeneration(t);await us.loadFonts(D);let L=new On(w),V=zs(ya(E,"onlyPresets"),R.getRawControlProps()),F=Za(R,E.properties,V,{context:{assets:s,imports:a,links:d,fonts:L,fetches:h}});y[R.id]=new $(F),(L.fontObjects.size>0||L.fontReferences.size>0)&&(b[R.id]=Zr({fontObjects:L.fontObjects,fontReferences:L.fontReferences}))}return[{revision:g,type:"componentPresets",source:p.joinLines(...a.statements,p`export const props = ${y}`,...w.list(),p`export const fonts = ${b}`),artifacts:{assets:s.keys,metrics:{nodes:Object.keys(y).length}}}]});var Pf=x("CodeGenerationStore");function Fc(o,t,e){return e.add(o),t[o]?.forEach(r=>{e.has(r)||Fc(r,t,e)}),e}function Mf(o,t){let e={};for(let{fromNode:r,toNode:n}of t){let i=e[r]??new Set;i.add(n),e[r]=i}return Fc(o,e,new Set([o]))}var Uc=te(async(o,{componentLoader:t,treeStore:e,modulesStore:r})=>{let n=_(`Prototype/${o.name||"Generated Prototype"}`),i=e.tree.get(o.homeNodeId);m(i,"Can't serialize",n,": home node must exist.");let s=e.tree.getRect(i),a=new rr("prototype",t,r);a.addImport("react",{exportSpecifier:"*",importBinding:"React"}),a.addImport("framer-motion",{exportSpecifier:"LayoutGroup"}),a.addImport("framer",{exportSpecifier:"PageRoot"}),a.addImport("framer",{exportSpecifier:"useInitialRouteComponent"});let d={};for(let g of Mf(i.id,e.treeIndex.getPrototypeScreenLinks(e.tree,o.id))){let b=`../${Q("screen",g)}`;try{await Wa(t,[Oe("screen",g,"default").value],r);let v=a.addImport(b,{exportSpecifier:"default",importBinding:"Screen",lazy:g!==o.homeNodeId});d[g]={page:v,path:g}}catch{Pf.error("Missing module for prototype screen",{screenId:g})}}let c=_(o.homeNodeId),u=_(d),l=p`${a.addImport("react",{exportSpecifier:"*",importBinding:"React"})}.useId`,h=new I(A.sections(A.linesFrom(a.statements),`const routes = ${u}`,A.lines("function Prototype({ layoutId }: { layoutId?: string }): JSX.Element {",`  const InitialRouteComponent = useInitialRouteComponent(routes, "${o.homeNodeId}")`,`  const defaultLayoutId = ${I.fn(l)};`,"  if (!InitialRouteComponent) return null","  return (","    <LayoutGroup id={layoutId ?? defaultLayoutId} inherit={false}>",`      <PageRoot RootComponent={InitialRouteComponent} isWebsite={false} routeId={${c}} routes={routes} />`,"    </LayoutGroup>","  )","}"),A.lines(mt("This is a generated Framer component.",{framerIntrinsicHeight:s?.height,framerIntrinsicWidth:s?.width,framerSupportedLayoutWidth:"fixed",framerSupportedLayoutHeight:"fixed",framerPrototype:!0}),"const Component: React.ComponentType<{}> = React.memo(Prototype)","export default Component;"),`Component.displayName = ${n};`));return[{type:"prototype",source:h,revision:void 0}]});async function To(o,t,e,r,n,i){return _s(t)&&t.usesDOMRectCached()&&!t.getDOMRect()&&(await Vf(t,r,e,n),!t.cache.getRawDOMRect(t.id)&&i)?hn.atOrigin(i):o.getRect(t)}async function Vf(o,t,e,r){if(t){let s=(await t([o.id]))?.[0];if(s){let{layoutMetrics:a}=s,d=hn.from(a);o.cache.setRawDOMRect(o.id,d);return}}if(!e)return;let n=Af(e,r);if(n){let i=hn.atOrigin(n);o.cache.setRawDOMRect(o.id,i)}}function Af(o,t){if(!Vr(o))return;let e=t.getPersistedModuleByLocalIdentifier(o);if(!e)return;let{intrinsicWidth:r,intrinsicHeight:n}=e.metadata;if(B(r)&&B(n))return{width:r,height:n}}var be={Screen:p`Screen`,activeVariantCallback:S.activeVariantCallback,css:S.css,delay:S.delay,ref:S.ref,serializationHash:S.serializationHash,sharedStyleClassNames:S.sharedStyleClassNames,restProps:S.restProps,refBinding:S.refBinding},Ff=new Set(Object.values(be).map(o=>_(o))),Oc=te(async(o,t,{serializationId:e,initialIntrinsicSize:r})=>{let{modulesStore:n,treeStore:i}=t,s=i.tree.getScopeNodeFor(o);if(!he(s))return[];let a=i.tree.get(o.id);m(a,"Must have a source node to serialize. This should be a primary variant."),m(he(s),"Must have a scope node to serialize. This should be a CanvasPage Node.");let d=`FramerScreen${ft(o.id)}`,c=Oe("screen",o.id,"default").value,{jsx:u,ctx:l}=await Bn(a,s,t,new Set(Ff).add(d),e);m(u,"There must be JSX to serialize.");let h=l.imports,g=await To(i.tree,a,c,t.measureNodes,n,r),y=l.events.navigationTargets.size>0,b=l.events.handlers.size>0,v=l.events.variantOnAppearId.get(o.id),C=l.events.keyBindHooks.size>0,w=[];for(let oe of l.events.navigationTargets)oe!==nd&&w.push(oe);let R=l.fonts.fontObjects,E=new Map(l.fonts.fontReferences),D=[],L=new Set(l.css.sharedStyleIds),V=[];for(let oe of L){let Ye=Q("css",oe),Lr=h.addImport(`../${Ye}`,{exportSpecifier:"*",importBinding:"sharedStyle"});V.push(Lr),D.push(I.fn(h.addImport("framer",{exportSpecifier:"getFontsFromSharedStyle"}),p`${Lr}.fonts`))}let F;for(let oe of l.componentPresetIds){F??=h.addImport(`../${An}`,{exportSpecifier:"*",importBinding:"componentPresets"});let Ye=p`${F}.fonts?.[${oe}]`;D.push(p`(${Ye} ? ${I.fn(l.imports.addImport("framer",{exportSpecifier:"getFontsFromComponentPreset"}),Ye)} : [])`)}let se=new Map;nr(l.css.get(),se);let ue=new I(d),Qe=h.addImport("react",{exportSpecifier:"useRef"}),st=s.resolveValue("name"),at=A.lines(y&&`const preload = ${_(w)};`,...l.variables.fallbackDeclarations(),...l.declarations.file.list(),p`const ${be.serializationHash} = ${e}`,p`const ${be.Screen} = ${Uf({props:p`style, className`},p`const fallbackRef = ${I.fn(p`${Qe}<HTMLElement>`,p`null`)}`,p`const ${be.refBinding} = ${be.ref} ?? fallbackRef`,y?p`const navigate = ${I.fn(h.addImport("framer",{exportSpecifier:"usePrototypeNavigate"}),{preload:p`preload`})}`:void 0,b&&p`const { ${be.activeVariantCallback}, ${be.delay} } = ${I.fn(h.addImport("framer",{exportSpecifier:"useActiveVariantCallback"}))}`,...l.events.handlers.values(),p`const ${be.sharedStyleClassNames} = ${V.map(oe=>p`${oe}.className`)}`,...l.declarations.component.list(),C&&A.linesFrom(l.events.keyBindHooks),v&&I.fn(h.addImport("framer",{exportSpecifier:"useOnAppear"}),v),p`return ${u}`)}`,p`const ${be.css} = ${[...l.css.conditionalRules(e),Nn,...or(se),...V.map(oe=>p`...${oe}.css`)]}`,Rn(ue,e,be.Screen,be.css,{framerIntrinsicHeight:g.height,framerIntrinsicWidth:g.width,framerSupportedLayoutWidth:"fixed",framerSupportedLayoutHeight:"fixed",framerScreen:void 0,framerDisplayContentsDiv:!1},h),p`${ue}.displayName = ${`Screens/${st?st.trim():"Generated Component"}`};`,p`${ue}.defaultProps = ${{width:g.width,height:g.height}};`,Co({componentName:ue,fontObjects:R,fontReferences:E,imports:h,declarations:l.declarations.font,sharedFontArrays:D}));return[{type:"screen",revision:void 0,source:new I(A.sections(A.linesFrom(h.statements),at)),artifacts:{assets:l.assets.keys,packageDependencies:l.packages.dependencies,metrics:l.metrics.get()}}]});function Uf({props:o},...t){return new I(A.lines(p`React.forwardRef(function({ ${o}, ...${be.restProps} }, ${be.ref}) {`,...t,p`});`))}var _c="{serializationId}";function Bc(o){return`.${_c} ${o}`}var zc=te(async(o,{componentLoader:t,treeStore:e},{serializationId:r})=>{let n=new Pt,i=new In(n),s=new On(i),a=o.getFontsForCodeGeneration(),d=o.moduleSourceRevision,c=Rs(o);for(let w of a)s.addFontObjectBySelector(w,c);let u=[],l=new Cn,h={componentLoader:t,colors:l};for(let{selectors:w,declarations:R}of o.getCSS(h)){let E=w.map(Bc);u.push(`${E.join(", ")} { ${R} }`)}let g=e.tree.getNodesWithTrait(o.cache.replicaInstances??[],ba).filter(ra).sort((w,R)=>(R.breakpointWidth??0)-(w.breakpointWidth??0));for(let w=0;w<g.length;w++){let R=g[w];if(U(R))continue;let E=g[w+1],D=R.breakpointWidth-1,L=E?.breakpointWidth??0;for(let{selectors:V,declarations:F}of R.getCSS(h)){let ue=`${V.map(Bc).join(", ")} { ${F} }`;u.push(`@media (max-width: ${D}px) and (min-width: ${L}px) { ${ue} }`)}}let y=l.getWideGamutColorRules(`.${r}`);y.length&&u.push(`@supports (color: color(display-p3 1 1 1)) { ${y.join(" ")} }`);let b=u.map(w=>w.replaceAll(_c,r)),v=Zr({fontObjects:s.fontObjects,fontReferences:s.fontReferences}),C=p.joinLines(p`import { fontStore } from "framer";`,p`fontStore.loadFonts(${a});`,...i.list(),p`export const fonts = ${v};`,p`export const css = ${b};`,p`export const className = ${r};`);return[{revision:d,type:"css",source:C,artifacts:{metrics:{nodes:u.length}}}]});function Gi(o){if(bs(o))return{widthType:o.widthType,heightType:o.heightType,...Ks(o)?{minHeight:o.minHeight,maxHeight:o.maxHeight,minWidth:o.minWidth,maxWidth:o.maxWidth}:Gs}}function Ki(o,t){if(Ls(t))return{min:o.getRect(t).width}}var Of=new Set(Object.values(S).map(o=>_(o)));function Bf(o,t){if(bn(o)){let e=t.get(o.parentid);return!pe(e)||!e.isLoaded()?null:e}return t.current(o)}var Qi=te(async(o,t,{serializationId:e,initialIntrinsicSize:r})=>{let{modulesStore:n,treeStore:i,aiGenerationStore:s,measureNodes:a}=t,d=Te(o,i.tree)?o.moduleSourceRevision:void 0,c=Bf(o,i.tree);m(c?.isLoaded(),"The scope node must be valid.");let u=dd(c),l=et(c)?c.baseVariantId:o.id,h=i.tree.get(l);m(h,"Must have a source node to serialize. This should be a primary variant.");let g=`Framer${o.id}`,y=new I(g),{jsx:b,ctx:v}=await Bn(h,c,t,new Set(Of).add(g),e);m(b,"There must be JSX to serialize.");let C=v.imports,w=pe(c),R=w?void 0:c.instanceIdentifier,E=await To(i.tree,h,R,a,n,r),D=et(c)?c.getReplicaVariants():[],{variants:L,hook:V}=v.preload.getHook(),{gestures:F,breakpoints:se,classNames:ue,sizes:Qe,appearEventMap:st}=tm(h,D,v,L),at=Le(c)?[c.baseVariantId,...c.getTopLevelReplicaVariants().map(Wn)]:[],oe=at.length>1,Ye=!Mr(F),Lr=!Mr(st),O=!Mr(se),xe=p`${C.addImport("react",{exportSpecifier:"*",importBinding:"React"})}.useId`,{mediaQueries:Ue,sharedStyleImports:$t,sharedFontArrays:sn,css:kr}=Yf(e,v,D,se,c),Rt=em(c,v.componentLoader,v.declarations),Pr=_e.applyTransforms(b,rm(c,v,Qf(c,h,D,Ue,i,v),O?S.baseVariant:void 0,Rt)),Se=$f(c,t,C,v.preload,v.variables),qt=Yt.isOn("autobahnNavigation")?v.preload.getRouteLoaderCode():void 0,Ao=M(c)?ii(c,Se?.controlMap):new Set,an={};for(let De of Ao){let Jt=Bo(De,c.id);an[De]=v.variables.create(Jt)}let{props:ns,types:Wt,propertyControls:Ht,variableMap:dn}=Hn(c,v,rd(c),u,Rt),Fo=!O&&p`const ${S.layoutDependency} = ${I.fn(v.declarations.file.dedupe("createLayoutDependency",p`(props, variants) => {${p.joinLines(p`if (props.layoutDependency) return variants.join('-') + props.layoutDependency`,p`return variants.join('-')`)}}`),S.props,S.variants)}`,{cursors:cn}=v.customCursors,k=C.addImport("react",{exportSpecifier:"useRef"}),P=Kf(c),J=A.sections(Ye&&p`const ${S.enabledGestures} = ${F};`,oe&&`const ${S.cycleOrder} = ${_(at)};`,O&&`const ${S.breakpoints} = ${_(Ue)}`,O&&`const ${S.isBrowser} = () => typeof document !== "undefined";`,w&&p`const ${S.variant} = undefined;`,w&&p`const ${S.breakpoints} = undefined;`,w&&p`const ${S.layoutId} = undefined;`,w&&p`const ${S.className} = undefined;`,w&&p`const ${S.style} = undefined;`,M(c)&&p`export const ${S.queryParamNames} = ${P}`,p`const ${S.serializationHash} = ${e}`,`const ${S.variantClassNames} = ${_(ue)};`,!O&&qf,p.linesFrom(v.variables.fallbackDeclarations()),...v.declarations.file.list(),`export interface Props extends React.HTMLAttributes<HTMLDivElement> { ${Wt} }`,`const ${S.Component} = ${zf(p`const fallbackRef = ${I.fn(p`${k}<HTMLElement>`,p`null`)}`,p`const ${S.refBinding} = ${S.ref} ?? fallbackRef`,p`const ${S.defaultLayoutId} = ${I.fn(xe)}`,`const { ${S.activeLocale}, ${S.setLocale} } = ${I.fn(C.addImport("framer",{exportSpecifier:"useLocaleInfo"}))}`,v.variables.shouldProvideLayoutDirection?p`const ${S.layoutDirection} = ${I.fn(C.addImport("framer",{exportSpecifier:"useLayoutDirection"}))}`:void 0,Le(c)||M(c)?p`const ${S.componentViewport} = ${I.fn(v.imports.addImport("framer",{exportSpecifier:"useComponentViewport"}))}`:void 0,Jf({data:Se,imports:C,preload:v.preload}),M(c)&&Gf(i.tree,t.componentLoader,c,C,v.variables),ns,M(c)&&Wf({webPageNodeId:o.id,metadataDependencies:an,imports:C,bindings:v.bindings}),O?p.joinLines(p`const [${S.baseVariant}, ${S.hydratedBaseVariant}] = ${I.fn(C.addImport("framer",{exportSpecifier:"useHydratedBreakpointVariants"}),S.variant,S.breakpoints,p`false`)};`,p`const ${S.gestureVariant} = undefined;`):_f(h.id,Ye,oe,C),Fo,Zf(v),...v.events.routeHandlers.values(),v.events.handlers.size>0&&p`const { ${S.activeVariantCallback}, ${S.delay} } = ${I.fn(C.addImport("framer",{exportSpecifier:"useActiveVariantCallback"}),O?p`undefined`:S.baseVariant)}`,...v.events.handlers.values(),Lr&&I.fn(C.addImport("framer",{exportSpecifier:"useOnVariantChange"}),O?S.hydratedBaseVariant:S.baseVariant,st),p`const ${S.sharedStyleClassNames} = ${$t.map(De=>p`${De}.className`)}`,...v.declarations.component.list(),cn,V?.(Ye?S.enabledGestures:p`undefined`),p`return (${Pr})`)}`,kr,Rn(y,e,S.Component,S.css,jf(c,v,E,Qe,dn),C),`${g}.displayName = ${_(c.resolveValue("name")?.trim()||"Generated Component")};`,`${g}.defaultProps = ${_({width:E.width,height:E.height})};`,Ht&&I.fn(C.addImport("framer",{exportSpecifier:"addPropertyControls"}),y,new I(`${_(Ht)} as any`)),Co({componentName:y,fontObjects:v.fonts.fontObjects,fontReferences:v.fonts.fontReferences,imports:C,declarations:v.declarations.font,sharedFontArrays:sn}),qt&&p`${y}.loader = ${qt}`),[Xe]=M(c)?await Nd(c,t,{serializationId:e}):[];return jn([{type:u,revision:d,source:new I(A.sections(A.linesFrom(C.statements),J)),artifacts:{packageDependencies:v.packages.dependencies,errors:v.errors.errors,assets:v.assets.keys,metrics:v.metrics.get(),kitSectionsStructure:s.cacheKitSectionsStructure(o.id,v.kitSectionsStructure.structure)}},Xe,v.localizedValues.module(d)])});function _f(o,t,e,r){let n=$.fromEntries([[S.defaultVariant,o],[S.variant,S.variant],[S.variantClassNames,S.variantClassNames],[S.enabledGestures,t?S.enabledGestures:void 0],[S.cycleOrder,e?S.cycleOrder:void 0],[S.ref,S.refBinding]]),i=I.fn(r.addImport("framer",{exportSpecifier:"useVariantState"}),n),s=S.variants,a=S.baseVariant,d=p`setVariant`,c=S.gestureVariant,u=S.classNames,l=S.setGestureState,h=S.gestureHandlers,g=S.clearLoadingGesture,y=S.isLoading;return A.lines(p`const ${{variants:s,baseVariant:a,setVariant:d,gestureVariant:c,classNames:u,setGestureState:l,gestureHandlers:h,clearLoadingGesture:g,isLoading:y}} = ${i}`)}function zf(...o){return A.sections(p`React.forwardRef<HTMLDivElement, Props>(function(${S.props}, ${S.ref}) {`,...o,p`});`)}function jf(o,t,e,r,n){let{height:i,width:s}=e,a={propertyName:"variant",data:Object.fromEntries(Object.entries(r).map(([c,u])=>[c,sa(u)]))},d={framerIntrinsicHeight:i,framerIntrinsicWidth:s,framerRootFontSize:Bs(o)?o.getPrimaryVariant()?.rootFontSize:void 0,framerCanvasComponentVariantDetails:JSON.stringify(a),framerVariables:n&&JSON.stringify(n),framerImmutableVariables:!0,framerDisplayContentsDiv:!1,framerAutoSizeImages:!0,framerComponentViewportWidth:!0,framerColorSyntax:!0,framerVectorSets:t.vectorSets.annotation()};if(de(o)){let c={},u=o.getBreakpointValues();for(let l in u){let h=t.treeStore.tree.get(l);c[l]={...u[l],canvasClassName:Wc(l),minHeight:h?.height,viewportHeight:h?.viewportHeight,name:h?.resolveValue("name")??void 0,width:h?.widthType===0?h?.width:void 0,rootFontSize:h?.rootFontSize??Is}}d.framerHitTargets=t.hitTargets.annotation(),d.framerBreakpoints=JSON.stringify(c),d.framerDefaultVariant=o.baseVariantId,d.framerTrackingIds=t.trackingIds.annotation(),d.framerLayoutTemplate=!0}else M(o)?(d.framerAcceptsLayoutTemplate=t.acceptsLayoutTemplate,d.framerTrackingIds=t.trackingIds.annotation(),d.framerScrollSections=t.elementIds.annotation()??!1,d.framerResponsiveScreen=!0,d.framerLayoutTemplateFlowEffect=!0):Le(o)?d.framerTrackingIds=t.trackingIds.annotation():pe(o)?d.framerDesign=!0:Le(o)||(d.framerScreen=!0);return d}function $f(o,t,e,r,n){if(!M(o)||!vn(o)||!ha(t.treeStore.tree,o))return;let s=o.getProvidedControlMap(t.treeStore.tree,void 0,t.componentLoader,t.componentLoader.activeBundleHash)??new Map,a=cd(o),d={defaultCollectionAlias:a,identifier:o.dataIdentifier,controlMap:s},c=ii(o,s);for(let v of c){let C=Bo(v,o.id);n.create(C)}let u=n.getBindings(o.id),l=new Set;for(let[v]of s)u.has(v)&&l.add(v);function h(v){let C=e.addModuleImport(v);return m(C,"Can't import collection"),C}let g=new Set,y=ud(s,l,g,a,h),b=ld(o.dataIdentifier,s,g,a,h);return r.addDetailPageQuery(b,y,a),d}var qf=A.lines("function addPropertyOverrides(overrides, ...variants) {","const nextOverrides = {}","variants?.forEach(variant => variant && Object.assign(nextOverrides, overrides[variant]))","return nextOverrides","}");function Wf({webPageNodeId:o,metadataDependencies:t,imports:e,bindings:r}){let n=e.addImport(`../${Id(o).localId}`,{exportSpecifier:"default",importBinding:"metadataProvider"}),i=r.create("metadata"),s=e.addImport("framer",{exportSpecifier:"useMetadata"}),a=I.fn(n,t,S.activeLocale),d=Object.values(t).concat(S.activeLocale);return A.lines(p`const ${i} = React.useMemo(() => ${a}, ${d})`,I.fn(s,i))}function Hf(o){if(Es(o))return{type:o.gesture,topLevel:o.replicaInfo.inheritsFrom}}function Jf({data:o,imports:t,preload:e}){if(!o)return;let r=t.addImport("framer",{exportSpecifier:"useCurrentPathVariables"}),n=t.addImport("framer",{exportSpecifier:"NotFoundError"}),i=t.addImport("framer",{exportSpecifier:"useQueryData"}),s=t.addImport("framer",{exportSpecifier:"getWhereExpressionFromPathVariables"}),a=e.getDetailPageQueryConstant();m(a,"Detail page query constant should be registered before createDataRecordBinding");let d=I.fn(s,S.currentPathVariables,o.defaultCollectionAlias),c=p`const [${S.currentRouteData}] = ${I.fn(i,p`${a}(${d})`)};`;return p.joinLines(p`const ${S.currentPathVariables} = ${I.fn(r)};`,c,p`const ${S.getFromCurrentRouteData} = (key) => {
            if (!${S.currentRouteData}) throw new ${n}(\`No data matches path variables: \${JSON.stringify(${S.currentPathVariables})}\`);
            return ${S.currentRouteData}[key];
        };`)}function Gf(o,t,e,r,n){let i=e.variables.filter($o);if(i.length===0)return;let s=n.getBindings(e.id),a=[];for(let d of i){if(!jo(d))continue;let c=oi(d),u;switch(d.type){case"boolean":{let y=r.addImport("framer",{exportSpecifier:"useBooleanQueryParam"}),b=new $({initialValue:d.optional?void 0:d.initialValue,parameterName:c,optional:d.optional?!0:void 0});u=I.fn(y,b);break}case"string":{let y=r.addImport("framer",{exportSpecifier:"useStringQueryParam"}),b=new $({initialValue:d.optional?void 0:d.initialValue,parameterName:c,optional:d.optional===!0?!0:void 0});u=I.fn(y,b);break}case"number":{let y=r.addImport("framer",{exportSpecifier:"useNumberQueryParam"}),b=new $({initialValue:d.optional?void 0:d.initialValue,parameterName:c,optional:d.optional===!0?!0:void 0});u=I.fn(y,b);break}case"date":{let y=r.addImport("framer",{exportSpecifier:"useDateQueryParam"}),b=new $({initialValue:d.optional?void 0:d.initialValue,parameterName:c,displayTime:d.options?.displayTime===!0?!0:void 0,optional:d.optional===!0?!0:void 0});u=I.fn(y,b);break}case"collectionreference":{let y=r.addImport("framer",{exportSpecifier:"useCollectionReferenceQueryParam"}),b=new $({collectionId:qo(d.dataIdentifier),initialValue:d.optional?void 0:d.initialValue,parameterName:c,optional:d.optional===!0?!0:void 0});u=I.fn(y,b);break}case"multicollectionreference":{let y=r.addImport("framer",{exportSpecifier:"useMultiCollectionReferenceQueryParam"}),b=new $({collectionId:qo(d.dataIdentifier),initialValue:d.optional?void 0:d.initialValue,parameterName:c,optional:d.optional===!0?!0:void 0});u=I.fn(y,b);break}case"controlReference":{if(d.expectedType!=="enum")continue;let y=Us(o,t,d);if(!y||y.type!=="enum")continue;let b=r.addImport("framer",{exportSpecifier:"useEnumQueryParam"}),v=d.entityIdentifier,C=Ee(v);if(!fn(C))continue;let w=d.controlKey,E=t.dataForIdentifier(v)?.annotations?.framerEnumToDisplayNameUtils;m(Z(E)&&Number.parseInt(E,10)===2,"Unexpected FramerEnumToDisplayNameUtils version");let D=r.addModuleImport(C,{exportSpecifier:En});if(!D)continue;let L=r.addModuleImport(C,{importBinding:`${Ps(w)}CollectionData`});if(!L)continue;let V=Z(d.initialValue)?d.initialValue:Vs("enum"),F;d.optional===!0||!V?F=new $({getOptionTitle:p`${D}?.[${w}]`,initialValue:void 0,optional:!0,options:p`${L}.propertyControls?.[${w}]?.options`,parameterName:c}):F=new $({getOptionTitle:p`${D}?.[${w}]`,initialValue:V,options:p`${L}.propertyControls?.[${w}]?.options`,parameterName:c}),u=I.fn(b,F);break}default:ae(d)}let l=s.get(d.id);if(!l)continue;let h=n.getSetterBinding(d.id),g=[l];h&&g.push(h),a.push(p`const ${g} = ${u};`)}return p.joinLines(...a)}function Kf(o){return M(o)?o.variables.flatMap(t=>$o(t)?jo(t)?[oi(t)]:[]:[]):[]}function Wc(o){return`framer-${ft(o)}-override`}function jc(o,t){if(!(!Qs(o)||Ys(o)&&!o.fillEnabled))return o.fillType==="color"&&ms(o.fillColor)?t(o.fillColor,o,"fill"):na(o)}function $c(o){if(!ws(o))return;let t=o.rootFontSize/16*100;return Ns(t,"%")}function qc(o,t){return Z(o)?o:I.fn(t.imports.addImport("framer",{exportSpecifier:"safeCSSValue"}),o)}function Qf(o,t,e,r,n,i){if(!de(o)&&!M(o))return;let s=ad(n,i.declarations,i.variables,i.valueTransforms),a=de(o)?":root":"html",d=`${a} body`,c=$c(t),u=jc(t,s)??"none",l=[Be`${d} { background: ${qc(u,i)}; }`];Z(c)&&l.push(`${a} { font-size: ${c}; }`);for(let h of e){let g=r[h.id];if(g){let y=jc(h,s)??"none",b=$c(h),v=[];if(ni(u,y)||v.push(Be`${d} { background: ${qc(y,i)}; }`),ni(c,b)||v.push(`${a} { font-size: ${b}; }`),v.length===0)continue;l.push(Be`@media ${g} { ${Be.join(v," ")} }`)}}return Be.join(l," ")}function Yf(o,t,e,r,n){let i=Ia(Ta(r)),s=[],a=new Map;if(de(n)){let b=n.getPrimaryVariant(),v={marginBottom:Yo(b,t)};t.css.createRule(`[${ri}="true"] > #overlay`,Go(v));for(let C of e){let w={marginBottom:Yo(C,t)},R=Qa(w,v);!R||Mr(R)||t.css.createRule(`[${ri}="true"] > #overlay`,Go(R),C.id)}}nr(t.css.get(),a);let d={},c={};for(let b of e){let v=i[b.id];if(v){let C=new Map;if(nr(t.css.get(b.id),C),!C.size)continue;de(n)?(d[b.id]=or(C),c[b.id]=`.${Wc(b.id)}`):s.push(Be`@media ${v} { ${Be.join(or(C)," ")}}`)}else nr(t.css.get(b.id),a)}let u=[],l=[];for(let b of t.css.sharedStyleIds){let v=Q("css",b),C=t.imports.addImport(`../${v}`,{exportSpecifier:"*",importBinding:"sharedStyle"});l.push(C),u.push(I.fn(t.imports.addImport("framer",{exportSpecifier:"getFontsFromSharedStyle"}),p`${C}.fonts`))}let h;for(let b of t.componentPresetIds){h??=t.imports.addImport(`../${An}`,{exportSpecifier:"*",importBinding:"componentPresets"});let v=p`${h}.fonts?.[${b}]`;u.push(p`(${v} ? ${I.fn(t.imports.addImport("framer",{exportSpecifier:"getFontsFromComponentPreset"}),v)} : [])`)}let g=[Nn,...or(a),...l.map(b=>p`...${b}.css`),...t.css.conditionalRules(o)],y=Xf(n,t,g,s,d,c,i);return{sharedStyleImports:l,sharedFontArrays:u,mediaQueries:i,css:p`const ${S.css} = ${y}`}}function Xf(o,t,e,r,n,i,s){if(Le(o)||pe(o))return e;if(M(o))return[...e,...r];if(de(o)){let a=t.declarations.file.dedupe("breakpointRules",n),d=t.declarations.file.dedupe("breakpointKeys",p`Object.keys(${a})`),c=t.declarations.file.dedupe("selectors",i),u=t.declarations.file.dedupe("rules",e),l=t.declarations.file.dedupe("mediaQueries",s),h=t.bindings.create("target"),g=t.bindings.create("query"),y=t.bindings.create("selector"),b=t.bindings.create("rule"),v=t.imports.addImport("framer",{exportSpecifier:"RenderTarget"});return p`(target) => {${p.joinLines(p`const isStaticRenderer = ${h} === ${v}.canvas || ${h} === ${v}.export`,p`if (!isStaticRenderer) {${p.joinLines(p`return [...${u}, ...${d}.map(key => {${p.joinLines(p`const ${g} = ${l}[key]`,p`return ${Be`@media ${g} { ${p`${a}[key].join(" ")`} }`}`)}})]`)}}`,p`return [...${u}, ...${d}.flatMap(key => {${p.joinLines(p`const ${y} = ${c}[key]`,p`return ${a}[key].map(${b} => ${Be`${y} {${b}}`})`)}})]`)}}`}ae(o)}function Zf(o){if(o.events.needsPathVariables)return`const ${od} = React.useContext(${o.imports.addImport("framer",{exportSpecifier:"PathVariablesContext"})});`}function em(o,t,e){let r=et(o)?o.getTopLevelVariants():[];if(r.length<2)return;let n=new $;for(let i of r){let s=i.resolveValue("name")??Dn(t,i);n[s]=i.id}return e.file.dedupe("humanReadableVariantMap",n)}function tm(o,t,e,r){let n=Gi(o);m(n,"The primary variant should have a default size as it must be a FrameNode.");let i={default:n},s={[o.id]:`framer-v-${ft(o.id)}`},a={},d={},c={},u=Ki(e.treeStore.tree,o);u&&(c[o.id]=u);let l=e.events.variantOnAppearId.get(o.id),h={};!U(l)&&!I.isUndefined(l)&&(h.default=l);for(let g of t){e.metrics.count("variants");let y=Hf(g);if(y){let R=a[y.topLevel]??{};R[y.type]=y.type==="loading"?r?.has(y.topLevel):!0,a[y.topLevel]=R,d[y.topLevel]=[...d[y.topLevel]??[],g.id]}else s[g.id]=`framer-v-${ft(g.id)}`;let b=Gi(g);b&&(i[g.id]=b);let v=Ki(e.treeStore.tree,g);v&&(c[g.id]=v);let C=e.events.variantOnAppearId.get(g.id),w=_(h[g.replicaInfo.inheritsFrom??""]??l);!U(C)&&_(C)!==w&&(h[g.id]=C)}return{gestures:a,breakpoints:c,classNames:s,sizes:i,appearEventMap:h}}function rm(o,t,e,r,n){let i=[];if((de(o)||M(o))&&e){let a=t.declarations.file.dedupe("HTMLStyle",p`({value}) => {${p.joinLines(p`const onCanvas = ${I.fn(t.imports.addImport("framer",{exportSpecifier:"useIsOnFramerCanvas"}))}`,p`if (onCanvas) return null`,p`return ${_e.tag("style",new $({"data-framer-html-style":"",dangerouslySetInnerHTML:{__html:p`value`}}))}`)}}`);i.push(d=>_e`${p.joinLines(_e.tag(a,new $({value:e})),d)}`)}if(Le(o)){let a=t.imports.addImport("react",{exportSpecifier:"*",importBinding:"React"}),d=t.imports.addImport("framer-motion",{exportSpecifier:"motion.create"}),c=t.declarations.file.dedupe("Variants",I.fn(d,p`${a}.Fragment`));i.push(u=>_e.tag(c,new $({initial:!1,animate:S.variants}),u))}if(M(o)||de(o)||pe(o)){let a=new $({id:de(o)?Cs:Ss});i.push(d=>_e`${p.joinLines(d,_e.tag("div",a))}`)}let s=t.imports.addImport("framer-motion",{exportSpecifier:"LayoutGroup"});if(i.push(a=>_e.tag(s,new $({id:p`layoutId ?? ${S.defaultLayoutId}`}),a)),M(o)||de(o)){let a=t.imports.addImport("framer",{exportSpecifier:"GeneratedComponentContext"});i.push(d=>_e.tag(p`${a}.Provider`,new $({value:{primaryVariantId:o.baseVariantId,variantClassNames:S.variantClassNames,activeVariantId:r,humanReadableVariantMap:n,isLayoutTemplate:de(o)?!0:void 0}}),d))}return i}function Hc(){let o=new I("bbed9c4");return p`// Generated by Framer (${o})`}var Yi={ref:S.ref,restProps:S.restProps,style:S.style,props:S.props,className:S.className,layoutId:S.layoutId},Xi=p`css`,en=p`Icon`,Io=p`Component`,tn=p`Props`,nm=[...Object.values(Yi),Xi,en,Io,tn].map(o=>_(o)),Jc=te(async(o,t,e)=>{let{serializationId:r}=e,{modulesStore:n,treeStore:i,vectorsStore:s}=t,a=i.tree.getScopeNodeFor(o);m(me(a),"Vector set item must be in a VectorSetNode.");let d=i.tree.get(o.id);m(d,"Must have a source node to serialize");let{ctx:c,jsx:u,svg:l,type:h}=pa(d,a,t,r,nm),g=Oe("vectorSet",a.id,"default").localId,y=n.getPersistedModuleByLocalId(g);m(y,"VectorSet must be persisted.");let b=i.tree.getRect(o),{propertyControls:v,variableMap:C,types:w,props:R}=Hn(a,{...t,...c,cssVariableDefinitions:void 0},"VectorSet","vector",void 0),E=om(c),D={name:d.resolveValue("name")??"Vector",empty:im(d)?!0:void 0,color:E,set:{localId:g,id:a.id,moduleId:y.id}},L=c.imports.addImport("react",{exportSpecifier:"*",importBinding:"React"}),V=c.imports.addImport("framer",{exportSpecifier:"withCSS"}),F=sm[h],se=A.lines(...c.variables.fallbackDeclarations(),...c.declarations.file.list(),p`interface ${tn} extends ${L}.HTMLAttributes<${L}.${F}> { ${w??p``} }`,p`const ${Io}: ${L}.ComponentType<${tn}> = ${L}.forwardRef<${L}.${F}, ${tn}>(function(${Yi.props}, ${Yi.ref}) {${p.joinLines(R,...c.declarations.component.list(),p`return (${u})`)}})`,p`const ${Xi} = ${c.css.rules}`,mt("This is a generated Framer component.",{framerIntrinsicWidth:b.width,framerIntrinsicHeight:b.height,framerSupportedLayoutWidth:"any-prefer-fixed",framerSupportedLayoutHeight:"any-prefer-fixed",framerVariables:C&&JSON.stringify(C),framerImmutableVariables:!0,framerVector:JSON.stringify(D),framerDisableUnlink:Ha.has(D.set.moduleId)?!0:void 0}),p`const ${en}: ${L}.ComponentType<${tn}> = ${I.fn(V,Io,Xi,r)} as typeof ${Io};`,p`${en}.displayName = ${d.resolveValue("name")??"Vector"};`,p`export default ${en}`,v&&I.fn(c.imports.addImport("framer",{exportSpecifier:"addPropertyControls"}),en,new I(`${_(v)} as any`)));return s.cache(o.id,{svg:_(l),color:E}),jn([{revision:d.moduleSourceRevision,type:"vector",source:new I(A.sections(A.linesFrom(c.imports.statements),se)),artifacts:{files:[{name:"icon.svg",type:"svgIcon",content:_(l)}]}}])});function om(o){if(o.colors.uniqueColorCount!==1)return;let t=o.colors.singleColor;if(t)return{type:"static",value:t};let e=o.colors.singleVariableColor;if(e)return{type:"variable",value:ft(e)}}function im(o){return!o.children||o.children.length===0?!0:o.children.every(t=>t.visible===!1)}var sm={0:p`HTMLImageElement`,1:p`HTMLDivElement`,3:p`HTMLSVGElement`,2:p`HTMLSVGElement`};var Gc=te(async(o,{modulesStore:t},e)=>{let r=[];for(let s of o.getVectorSetItems()){let a=Oe("vector",s.id,"default").localId,d=t.getPersistedModuleByLocalId(a);d&&r.push({id:s.id,name:s.resolveValue("name")??"Vector",moduleId:d.id,saveId:e.includeVectorSetSaveIds?d.saveId:void 0})}let n={framerVectorSet:JSON.stringify({name:o.resolveValue("name")??"Set",items:r})},i=new I(A.lines(mt("This is a generated Framer component.",n),p`const VectorSet: React.ComponentType<unknown> = function VectorSet() { return null; };`,p`export default VectorSet;`));return[{revision:o.moduleSourceRevision,type:"vectorSet",source:i}]});function Yc(o){return Math.ceil(o/Math.ceil(o/100))}var Kc=class{constructor(t,e){f(this,"status",null);f(this,"results");f(this,"reportProgress");f(this,"onDone");this.reportProgress=t,this.onDone=e}async import(t,e,r){this.status="importing",this.results={scopeId:e,vectors:[],targetLayout:r};let n=r?{left:r.x+r.width*2,top:r.y}:{left:0,top:0};for(let i=0;i<t.length;i++){let s=t[i];if(!s)continue;let a=await dm(s,e,n);if(this.status!=="importing")return;a&&this.results.vectors.push(a),this.reportProgress?.({status:this.status,finishedCount:i+1})}await this.done()}cancel(){this.status="canceled"}async done(){this.results&&await this.onDone?.(this.results),this.status="done"}},Qc="run-svgo",am=1e6;async function dm(o,t,e){if(o.size>am){_r({type:"add",variant:"error",key:Qc,primaryText:"SVG is too large.",secondaryText:"You may need a PNG.",icon:"error",duration:5e3});return}try{let r=await o.text(),n=Td(r),i=lm(o.name),s=qa(r,kn.createEmpty,n);return s?(s.parentid=t,s.set({name:i,isVectorSetItem:!0,...e}),{node:s,size:n}):void 0}catch(r){console.error("Failed to insert SVG:",r),_r({type:"add",variant:"error",key:Qc,primaryText:"Failed to insert",secondaryText:"your SVG.",icon:"error"});return}}var cm=/[_-]/gu;function lm(o){let[t]=Os(o);return fs(t.replace(cm," "))}var um=2;function Zi(o){if(M(o))return um}function cw(o,t,e){if(t.type==="siteMetadata"||t.type==="webPageMetadata")return!0;let r=zr(o,e).includes(t.type);if(m(o.id===t.name&&r,"sourceNode and module must match"),$n(t))return!1;let n=Zi(o);if(U(n))return!0;let i=t.metadata.codeGenVersion;return B(i)&&i>=n}var es=1;function fm(o){let t=o.metadata.compatibleTextStyleVersion;return B(t)?t:0}function mw(o){return fm(o)<es}var Tt=Dt(gn(),1);function Zc(o,t){if(Le(o))return"Smart Component";if(M(o))return"web page";if(he(t.get(o.parentid)))return"prototype screen";if(he(o))return"prototype";if(ee(o))return"CMS collection"}function el(o,t,e){return M(e)?Rd(o,t,e):e.resolveValue("name")??void 0}function tl(o,t="module",e){let r="is too large and will not update";_r({type:"add",variant:"warning",text:e?(0,Tt.jsxs)(Tt.Fragment,{children:[(0,Tt.jsxs)(Pn,{children:["The ",t]})," \u201C",e,"\u201D ",(0,Tt.jsx)(Pn,{children:r})]}):(0,Tt.jsxs)(Pn,{children:["A ",t," ",r]}),key:`module-too-large-${o}`,duration:1/0,extraAction:{title:"Learn more",onClick(){ke("ui_interaction",{page:"module-too-large-toast",id:"learn_more"}),ja("https://www.framer.com/help/articles/how-to-fix-module-too-large-warning/")}}});let i=`module-too-large-toast-${t.split(" ").join("-")}`;ke("ui_impression",{page:i})}var wo=class{constructor(){f(this,"queue",[]);f(this,"synchronize",async()=>{for(let t of this.snapshot())await t.task()});f(this,"synchronizeWithProgress",async t=>{let e=this.snapshot(),r=e.length,n=0;for(let i of e)await i.task(),n++,t(n,r)})}snapshot(t){return this.queue=this.queue.filter(t??(e=>!e.promise.isResolved())),Array.from(this.queue)}isScheduled(t){for(let e of this.queue)if(!e.promise.isResolved()&&e.id===t)return e.promise.state==="initial";return!1}await(t){for(let e of this.queue)if(!e.promise.isResolved()&&e.id===t)return e.promise;return Promise.resolve()}get size(){return this.snapshot().length}async request(t,e){let r=new Qt;this.queue.push({id:e?.id,promise:r,task:()=>(r.state!=="initial"||(r.pending(),(t()??Promise.resolve()).finally(()=>r.resolve())),r)}),e?.synchronize!==!1&&await this.synchronize()}};var pm=1e4,hm=1e3,rn=x("CodeGenerationStore");function gm(o){return!(ee(o)||he(o)||Et(o)||bn(o)||er(o)||me(o))}function ym(o,t){if(!ze(t))return;let e=o.getScopeNodeFor(t);return m(me(e),"Vector set item must be in a VectorSetNode."),e.variables}function vm(o,t){let e=t.resolveValue("name")?.trim();return e||(oa(t)?"Text":Dn(o,t,t.__class))}function rl(o,t,e,r,n,i){let s={},a=vm(t,e);s.metadata||(s.metadata={});let d=[...i?.files??[]];gm(e)&&d.push({name:"tree.json",type:"nodeTree",content:JSON.stringify(Object.assign(e.toJS(),{__treeSerializationVersion:o.serializationVersion,__vectorSetVariables:ym(o,e)}))});let c=Zi(e);c&&(s.metadata.codeGenVersion=c);let u=i?.packageDependencies;return u&&(s.metadata.packageDependencies=Array.from(u)),Ld(r)&&(s.metadata.compatibleCmsVersion=Ed),ys(e)&&(s.metadata.compatibleTextStyleVersion=es),s.assets=i?.assets?Array.from(i.assets):[],{...s,title:a,files:d,errors:i?.errors??[],type:r,name:n}}async function bm(o,t,e,r,n){if(o&&t instanceof cs&&t.code===1001){let i=Sa(o,a=>r.treeIndex.getScopeIdFor(a))??void 0,s=new Ca({type:"CodeGeneration",nodeId:et(o)?o.baseVariantId:o.id,reason:"FileTooLarge",sourceNodeId:o.id,scopeId:i});tl(o.id,Zc(o,r.tree),el(r.tree,e,o)),await n(a=>{if(a.isViewOnly)return;a.lineage.setEditReason("codegeneration");let d=va.ensure(a);rn.debug("Writing ClientFileTooLarge error to tree for",o.id),a.insertNode(s,d.id)})}else rn.reportError(t)}var le,nn,No=class{constructor(t,e,r,n,i){this.componentLoader=t;this.treeStore=e;this.modulesStore=r;this.runWhenIdle=n;this.scheduleDocumentUpdateIgnoringUndo=i;X(this,le,new wo);X(this,nn,new pn({delay:pm,task:()=>this.runWhenIdle(()=>void T(this,le).synchronize())}));f(this,"process",T(this,le).synchronize);f(this,"processWithProgress",T(this,le).synchronizeWithProgress);f(this,"changeScope",()=>T(this,nn).debounce(hm));f(this,"isIdle",()=>T(this,le).size===0);f(this,"isBlocking",()=>T(this,le).snapshot().some(t=>t.promise.state==="pending"))}enqueue(t,e){T(this,le).snapshot(s=>s.promise.isResolved()?!1:s.id===t?s.promise.state!=="initial":!0);let r=this.treeStore.tree.get(t);if(!r||!Md(r,this.treeStore.tree))return;let n=yt(r),i={};for(let{type:s,artifacts:a}of e){let d=rl(this.treeStore.tree,this.componentLoader,r,s,n,a);i[Q(s,n)]=d}T(this,le).request(async()=>{try{rn.debug("Persisting transient modules for",t),await this.modulesStore.upsertBatch(i)}catch(s){await bm(r,s,this.componentLoader,this.treeStore,this.scheduleDocumentUpdateIgnoringUndo)}},{id:t,synchronize:!1})}async persist(t,e,r){let n=this.treeStore.tree.get(t);if(n)return this.enqueue(t,e),r?T(this,nn).debounce():(await T(this,le).synchronize(),qn(n,this.treeStore.tree).map(i=>this.modulesStore.getPersistedModuleByLocalId(i)))}async persistBatch(t){let e={},r="batch";for(let n in t){let i=this.treeStore.tree.get(n),s=t[n];if(!i||!s)continue;let a=yt(i),d=new Set;for(let{type:c,artifacts:u}of s){let l=Q(c,a);m(!d.has(l),"Duplicate local module id",l),d.add(l),e[l]=rl(this.treeStore.tree,this.componentLoader,i,c,a,u),r+=`-${l}`}}T(this,le).snapshot(n=>n.promise.isResolved()?!1:n.id===r?n.promise.state!=="initial":!0),await T(this,le).request(async()=>{rn.debug("Persisting transient modules for batch: ",r);try{await this.modulesStore.upsertBatch(e)}catch(n){rn.reportError(n)}},{id:r,synchronize:!0})}get size(){return T(this,le).size}};le=new WeakMap,nn=new WeakMap;var Sm=()=>({stylePresets:[],componentPresets:[],collections:[],smartComponents:[],screens:[],prototypes:[],webpages:[],metadata:[],layoutTemplates:[],snippets:[]}),j=x("CodeGenerationStore");var Cm=500,ol=1500,Tm=6e4;function Im(o){for(let t in o.to)if(t in wa)return!0;return!1}function wm(o){return me(o)?Cm:ol}var It,H,ot,Nr,on,Rr,xr,Y,Ro,il,nl=class extends wn{constructor(e,r,n,i,s,a,d,c,u,l,h,g=new Map){super();this.componentLoader=e;this.treeStore=r;this.modulesStore=n;this.vectorsStore=i;this.aiGenerationStore=s;this.assetMap=a;this.timeline=d;this.engineChanges=c;this.scheduleDocumentUpdateIgnoringUndo=u;this.updateTreeCache=l;this.measureNodes=h;X(this,Ro);X(this,It,new Set);X(this,H);X(this,ot,new Map);X(this,Nr);X(this,on,new pn({delay:ol,maxDelay:Tm,task:()=>this.scheduler.runWhenIdle(()=>{this.generateAndUpdateQueuedComponents()})}));X(this,Rr,new Map);X(this,xr);f(this,"testing",{setComponentGenerationQueue:e=>{Ze(this,H,e)},flushQueuedCallbacks:()=>{T(this,ot).forEach(e=>e.forEach(r=>r()))},generateAndUpdateQueuedComponents:e=>this.generateAndUpdateQueuedComponents(e),setSerializationId:e=>{Ze(this,xr,e)},setModulesStore:e=>{Object.assign(this,{modulesStore:e}),Object.assign(this.persistence,{modulesStore:e})},waitForProcessing:async e=>{await this.serialization.promise(e)}});f(this,"persistence");f(this,"moduleTypeOrder",{localization:0,webPageMetadata:1,siteMetadata:2,collection:3,draftCollection:4,css:5,componentPresets:6,vector:7,vectorSet:8,canvasComponent:9,screen:10,["prototype"]:11,codeFile:12,config:13,layoutTemplate:14,design:15,kit:16,snippets:17,shader:18});X(this,Y,new Map);f(this,"serialization",{idle:async()=>{let e=[];for(let r of T(this,Y).keys())e.push(this.serialization.promise(r)?.then(()=>this.untilCompiled(r)));await Promise.all(e)},isIdle:()=>T(this,Y).size===0,prepare:e=>{T(this,H).delete(e);let r=T(this,Y).get(e)??new Qt;T(this,Y).set(e,r)},cancel:e=>{T(this,H).delete(e),T(this,Y).get(e)?.resolve(),T(this,Y).delete(e)},preparing:e=>T(this,Y).has(e),promise:e=>T(this,Y).get(e),commit:async(e,r,n,i)=>{let s=()=>{T(this,Y).get(e.id)?.reject(),T(this,Y).delete(e.id)};try{let a=await is(this,Ro,il).call(this,e,r,n,i);return a||s(),a}catch(a){throw j.reportError(a),s(),a}}});Ze(this,H,g),Ze(this,Nr,this.timeline.openNodeChangesReader()),this.persistence=new No(this.componentLoader,this.treeStore,this.modulesStore,y=>this.scheduler.runWhenIdle(y),y=>this.scheduleDocumentUpdateIgnoringUndo(y)),Dd(()=>{if(dt.isTest||this.treeStore.tree.isViewOnly)return!1;if(this.hasBlockingUpdates()){if(j.debug("Showing Unsaved Changes dialog (generation queue #: ",T(this,H).size,", component ids to generate: ",[...T(this,H).keys()],")"),!dt.isTest){let y=this.getMetrics();y.paused>1?j.reportError("Tab closed with paused code generations",y):(y.persisting>5||y.serializing>5||y.queue>5)&&j.reportError("Tab closed with multiple code generations in progress",y)}return T(this,It).clear(),this.generateAndUpdateQueuedComponents().then(()=>{this.persistence.process()}).catch(y=>j.reportError(y)),!0}return!1}),window.addEventListener("blur",async()=>{try{await this.generateAndPersistAllQueuedComponents()}catch(y){j.reportError(y)}})}isIdle(){return T(this,H).size===0&&this.serialization.isIdle()&&this.persistence.isIdle()}getMetrics(){return{queue:T(this,H).size,paused:T(this,It).size,serializing:T(this,Y).size,persisting:this.persistence.size}}documentDidLoad(){T(this,H).clear(),T(this,ot).clear(),T(this,Rr).clear()}telemetrySession(e){let r=T(this,Rr).get(e);if(r)return r;let n=this.treeStore.tree.get(e);m(n,"TelemetrySession: source node must exist");let i=new ho(n);return T(this,Rr).set(e,i),i}getSerializationId(){return T(this,xr)?`framer-${T(this,xr)}`:`framer-${Ka(5)}`}async generateAndPersistAllQueuedComponents(){await this.ensureSiteMetadataModule(),await this.ensureSnippetsModule(),await this.generateAndUpdateQueuedComponents(),await this.serialization.idle(),await this.persistence.process()}debugGetComponentSourceNodes(){let e=Sm();m(!1,"This method should only be used in tests.");for(let{node:r,skipChildren:n}of this.treeStore.tree.root.walkWithSkipChildren())M(r)?(e.webpages.push(r),e.metadata.push(r),n()):Le(r)?(e.smartComponents.push(r),n()):ee(r)?(e.collections.push(r),n()):Ko(r)?(e.stylePresets.push(r),n()):er(r)?e.componentPresets.push(r):Pd(r,this.treeStore.tree)?(e.screens.push(r),n()):he(r)?e.prototypes.push(r):Et(r)?e.metadata.push(r):de(r)?e.layoutTemplates.push(r):Lt(r)&&e.snippets.push(r);return e}postProcess(e,r,n){if(!this.treeStore.tree.isViewOnly){if(n){T(this,Nr).clear();return}this.ingestChanges(e),T(this,on).debounce(wm(r))}}ingestChanges(e){for(let[r,n]of T(this,Nr).read()){if(n.length===0||n.every(s=>s.ignoreInCodeGeneration))continue;let i=e.get(r);if(i){if(M(i)&&ps(n)){let s=e.get(Ra);s&&this.addChangeToQueue(s)}if(Te(i,this.treeStore.tree)){ta(i,n)&&this.addChangeToQueue(i);continue}if(Et(i)){if(!n.some(Im))continue;this.addChangeToQueue(i)}else if(he(i))this.addChangeToQueue(i);else{let s=this.treeStore.treeIndex.getGroundNodeIdFor(r),a=e.get(s);if(!a||ut(a))continue;let d=e.getScopeNodeFor(a);if(!he(d))continue;this.queueCanvasPageNodesFollowingLinks(e,a)}}}}queueCanvasPageNodesFollowingLinks(e,r){if(this.addChangeToQueue(r),!(!r.cache.links||r.cache.links.size===0))for(let n of r.cache.links){let i=this.treeStore.treeIndex.getGroundNodeIdFor(n),s=e.get(i);!s||ut(s)||this.queueCanvasPageNodesFollowingLinks(e,s)}}changeScope(){this.treeStore.tree.isViewOnly||dt.isTest||this.isIdle()||this.serialization.idle().then(()=>this.generateAndUpdateQueuedComponents()).then(()=>{if(!Yt.isOn("prioritizedModuleEvaluation")){this.persistence.process();return}this.persistence.isIdle()||this.persistence.changeScope()}).catch(e=>j.reportError(e))}async createVectorSet(e,r){let n=e[0];if(!n)return;let i=this.treeStore.tree.getScopeNodeFor(n);m(me(i),"VectorSet: VectorSetNode must exist.");let s=performance.now(),a=await this.batchSerializeVectors(e,r);if(!a)return;let d={},c=0,u=Object.keys(a).length,l=Yc(u),h=[];for(let g in a){let y=a[g];y&&(d[g]=y,c++,!(c%l!==0&&c!==u)&&(h.push(d),d={}))}for(let g=0;g<h.length;g++){let y=h[g];y&&(await this.persistence.persistBatch(y),r?.("persisting",g))}await this.forceComponentUpdate(i.id),j.debug("createVectorSet: Spent ",performance.now()-s,"ms creating a new vector set.")}async createModuleFromComponentSource(e,r){if(m(!this.treeStore.tree.isViewOnly,"CodeGenerationStore: viewers cannot create smart components or web pages."),m(Mt(e,this.treeStore.tree),"CodeGenerationStore: componentSourceNode must be a valid component source."),dr(e,this.treeStore.tree,this.modulesStore))return;j.debug("createModuleFromComponentSource",e.id),this.serialization.prepare(e.id);let i=await this.generateComponent(e.id,1,void 0,{intrinsicSize:r});if(!i)throw new Error("Code not generated");return await this.compileOutput(e,i),qn(e,this.treeStore.tree).map(s=>this.modulesStore.getPersistedModuleByLocalId(s))}revisionNodes(e=this.treeStore.tree){let r=[];for(let n of e.root.children)Te(n,e)&&r.push(n),(er(n)||gs(n))&&n.children.forEach(i=>{Te(i,e)&&r.push(i),ee(i)&&i.getUnsortedChildren().forEach(s=>{Te(s,e)&&r.push(s)})});return r}nodesWithStaleModules(e,r){let n=[],i=r?.ignoreHint??!1;for(let s of this.revisionNodes())_o(s)||e&&!e(s)||(!i&&s.moduleSourceRevisionHint!==s.moduleSourceRevisionCommittedHint||!this.allModulesAreAtRevision(s.id))&&n.push(s);return n}canSerialize(e){let r=this.treeStore.tree;if(!r.isViewOnly)return!0;let n=r.get(e);if(!n||!r.isGroundNode(n))return!1;let i=r.getScopeNodeFor(n);return pe(i)}async updateComponent(e,r=0){m(this.canSerialize(e),"CodeGenerationStore: viewers cannot generate smart component or web page updates.");let n=this.treeStore.tree.get(e);if(!n||!Mt(n,this.treeStore.tree))return!1;if(this.serialization.preparing(e))return await this.serialization.promise(e),await this.untilCompiled(e),!0;j.debug("Update component: ",e,", Condition: ",r);let i=T(this,H).get(e);this.serialization.prepare(e);let s=await this.generateComponent(e,r,i);return s?this.compileOutput(n,s):!1}async forceComponentUpdate(e){return m(this.canSerialize(e),"CodeGenerationStore: viewers cannot generate smart component or web page updates."),await this.updateComponent(e,2)?(await this.persistence.process(),!0):!1}queueCallbackAfterComponentCompilation(e,r){let n=T(this,ot).get(e);n?n.push(r):T(this,ot).set(e,[r])}untilCompiled(e){return new Promise(r=>{this.queueCallbackAfterComponentCompilation(e,r)})}calculateNewModuleRevision(e){let r=this.treeStore.tree.get(e);if(!r||!Te(r,this.treeStore.tree))return 1;if(!(!Lt(r)&&!Bi(this.treeStore.tree,e)||!this.treeStore.tree.has(e)))return Ic(e,this.scheduleDocumentUpdateIgnoringUndo)}allModulesAreAtRevision(e,r){let n=this.treeStore.tree.get(e);if(!n||!Te(n,this.treeStore.tree))return!1;let i=r??n.moduleSourceRevision;return zr(n,this.treeStore.tree).every(s=>this.modulesStore.forType(s).getByStableName(yt(n)).sourceRevision()===i)}async ensureDependencyModulesExist(){for(let e of this.revisionNodes())if(Mt(e,this.treeStore.tree)&&!dr(e,this.treeStore.tree,this.modulesStore))try{await this.updateComponent(e.id)}catch(r){j.error("Error updating dependency module",e.id,r)}}async ensureSourceNode(e){let r=this.treeStore.tree.get(e),n=kt(r)&&!r.isLoaded()?await r.load():r;if(n){if(M(n)&&(await this.ensureSiteMetadataModule(),m(n.loaded,"WebPageNode must be loaded"),await this.ensureReferencedCollectionsExportUpToDateEnumUtils(n.loaded)),ee(n)&&await this.ensureDependentModulesAreCompatibleWithCollection(n),ze(n)){let i=this.treeStore.tree.getScopeNodeFor(n);if(!me(i))return;let s=Q("vectorSet",i.id);if(this.modulesStore.getModuleEntryByLocalId(s))return;await this.createModuleFromComponentSource(i)}await this.ensureAllNodesWithLinksHaveLinkedScopesLoaded(n)}}async ensureSiteMetadataModule(){if(this.treeStore.tree.isViewOnly)return;let e=this.treeStore.tree.root;if(!dr(e,this.treeStore.tree,this.modulesStore))return this.updateComponent(e.id)}async ensureSnippetsModule(){if(this.treeStore.tree.isViewOnly)return;let e=xa.get(this.treeStore.tree);if(!e)return;let r=await e.load();if(!(!r||dr(r,this.treeStore.tree,this.modulesStore)))return this.updateComponent(r.id)}hasBlockingUpdates(){if(T(this,H).size>0){for(let[e,r]of T(this,H))if(this.treeStore.tree.has(e)&&r)return!0}return!this.persistence.isIdle()||!this.serialization.isIdle()}async updateModules(e,r){let n=this.treeStore.tree.get(e),i=this.timeline.remoteTreeVersion;if(!n||!Mt(n,this.treeStore.tree))return!1;let s=[];for(let{revision:d,source:c,type:u,artifacts:l}of r){let h={assets:l?.assets,submodules:l?.submodules,binaryAssets:l?.binaryAssets,preventCircularImports:u==="canvasComponent",telemetrySession:this.telemetrySession(e),treeVersion:i,sourceRevision:d,kitSectionsStructure:l?.kitSectionsStructure,svgIcon:l?.files?.find(v=>v.type==="svgIcon")?.content,stableName:!0},g=this.modulesStore.forType(u).getByStableName(yt(n)),y=g.sourceRevision()!==d,b=A.sections(Hc(),c);!y&&g.currentSourceEquals(b,h)||s.push({localId:g.localId,source:b,options:h})}if(s.length===0)return!1;let a=await this.modulesStore.updateSources(s);return ze(n)&&this.vectorsStore.delete(e),M(n)&&this.aiGenerationStore.deleteKitSectionsStructure(e),a}allModulesExistForSources(e,r){let n=yt(e);for(let i of r)if(!this.modulesStore.getPersistedModuleByLocalId(Q(i.type,n)))return!1;return!0}async compileOutput(e,r){if(!this.canSerialize(e.id))return!1;let n=r.slice().sort((s,a)=>this.moduleTypeOrder[s.type]-this.moduleTypeOrder[a.type]);if(this.allModulesExistForSources(e,n))await this.updateModules(e.id,n);else for(let s of n){let a=await this.updateModules(e.id,[s]),d=yt(e);!this.modulesStore.getPersistedModuleByLocalId(Q(s.type,d))&&a&&await this.persistence.persist(e.id,[s])}return ee(e)&&await this.ensureDependentModulesCanRenderCollectionColors(e),T(this,ot).get(e.id)?.forEach(s=>s()),T(this,ot).delete(e.id),this.persistence.persist(e.id,r,!0),!0}pauseCodeGeneration(e){return j.debug("Pausing code generation for",e),T(this,It).add(e),()=>{j.debug("Resuming code generation for",e),T(this,It).delete(e),T(this,on).debounce()}}async generateAndUpdateQueuedComponents(e){if(this.treeStore.tree.isViewOnly)return[];await this.ensureDependencyModulesExist();let r=[],n=new Map;for(let[s]of T(this,H)){if(T(this,It).has(s)||this.serialization.preparing(s))continue;let a=this.treeStore.tree.get(s);if(!a||!Mt(a,this.treeStore.tree)||e&&!zr(a,this.treeStore.tree).includes(e)){T(this,H).delete(s);continue}if(this.serialization.prepare(s),ze(a)){let d=this.treeStore.tree.getScopeNodeFor(a);if(!d)continue;let c=n.get(d.id)??[];c.push(a),n.set(d.id,c)}else r.push(a)}let i=new Set;j.debug("Batch generating queued vector nodes");for(let s of n.values())try{let a=await this.batchSerializeVectors(s,void 0,i);for(let d in a)this.persistence.persist(d,a[d],!0)}catch{}j.debug("Generating queued components",{ids:r.map(Wn)});for(let s of r)try{j.debug("Flushing queue of ",s.id);let a=await this.generateComponent(s.id,1);a&&(await this.compileOutput(s,a),i.add(s.id))}catch{}return Array.from(i)}async batchSerializeVectors(e,r,n){let i=e[0];if(!i)return;await this.ensureSourceNode(i.id),await this.ensureSourceCache(i.id),e.forEach(l=>this.serialization.prepare(l.id));let s=await wc(e,this.scheduleDocumentUpdateIgnoringUndo);m(s,"VectorSet: newModuleRevisions must exist");let a={componentLoader:this.componentLoader,assetMap:this.assetMap,modulesStore:this.modulesStore,treeStore:this.treeStore,vectorsStore:this.vectorsStore,aiGenerationStore:this.aiGenerationStore,engineChanges:this.engineChanges,measureNodes:this.measureNodes},d=await Promise.all(e.map(async l=>{if(!s[l.id])return;let b=(await this.serializerForSourceNode(l)(l,a,{serializationId:this.getSerializationId()}))?.[0];return m(b,"VectorSet: source must exist.",l.id),this.serialization.promise(l.id)?.resolve(),T(this,Y).delete(l.id),[l.id,b]})),c=0,u={};for(let l of d){if(!l)continue;let[h,g]=l;await this.updateModules(h,[g])&&(u[h]=[g],r?.("serializing",c),c++,n?.add(h))}return u}async createVersionedVectorSet(e){await this.generateAndPersistAllQueuedComponents();let r=await this.generateComponent(e.id,2,void 0,{includeVectorSetSaveIds:!0});return!r||!await this.compileOutput(e,r)?!1:(await this.persistence.process(),!0)}isSkippedEmptyScopeNode(e){return Lt(e)?!1:!!(kt(e)&&(!e.isLoaded()||e.loaded.children?.length===0))}async generateComponent(e,r,n,i){j.debug("Ensure source node",e),await this.ensureSourceNode(e),j.debug("Ensure source cache",e),await this.ensureSourceCache(e);let s=await this.calculateNewModuleRevision(e),a=this.treeStore.tree.get(e);if(!a||!Mt(a,this.treeStore.tree)||!this.shouldGenerateUnderCondition(r,a,s,n)){j.debug("Cancel serialization",e),this.serialization.cancel(e);return}let d=et(a)?a.getPrimaryVariant():a;return j.debug("Serialize",e),this.serialization.commit(a,d,r,i)}shouldGenerateUnderCondition(e,r,n,i){let s=i??T(this,H).get(r.id);if(T(this,H).delete(r.id),!dr(r,this.treeStore.tree,this.modulesStore))return!0;switch(e){case 2:return!0;case 1:return!U(n)||!this.allModulesAreAtRevision(r.id,n);case 0:return!U(n)&&!!s&&!this.allModulesAreAtRevision(r.id,n);default:ae(e)}}addChangeToQueue(e){if(!this.shouldSkipChange(e)){if(ze(e)&&this.vectorsStore.queue(e.id),_o(e)){let r=e.parentid;m(r,"Collection node has no parent"),T(this,H).set(r,!0);return}T(this,H).set(e.id,!0)}}serializerForSourceNode(e){return ee(e)?Mc:et(e)?Qi:Ko(e)?zc:he(e)?Uc:Et(e)?wd:er(e)?Ac:me(e)?Gc:ze(e)?Jc:Lt(e)?kd:pe(this.treeStore.tree.get(e.parentid))?Qi:Oc}shouldSkipChange(e){if(ut(e)){let r=Ee(e.codeComponentIdentifier);if(Vr(r)&&r.type==="screen")return!0}return!1}async ensureSourceCache(e){let r=this.treeStore.tree.get(e);!r||r.update===r.cache.lastUpdate||await new Promise(n=>{this.scheduler.runBeforeNextFrame(()=>{kt(r)&&r.update!==r.cache.lastUpdate&&this.updateTreeCache(r.id),n()})})}async ensureDependentModulesAreCompatibleWithCollection(e){let r=Q("collection",e.id),n=this.modulesStore.getDependentsOfModule(r);!n||n.size===0||await Promise.all(Array.from(n).map(async i=>{let s=i,a=this.modulesStore.getPersistedModuleByLocalId(s);if(!(!a||!$n(a)))return this.forceComponentUpdate(a.name)}))}async ensureDependentModulesCanRenderCollectionColors(e){let r=Q("collection",e.id),n=this.modulesStore.getDependentsOfModule(r);if(!n||n.size===0)return;let i=this.modulesStore.forType("collection").getByStableName(e.id);i&&i.annotations(null,"default")?.framerColorSyntax&&await Promise.all(Array.from(n).map(async s=>{let[a,d]=ua(s);a==="draftCollection"||this.modulesStore.forType(a).getByStableName(d)?.annotations(null,"default")?.framerColorSyntax||await this.forceComponentUpdate(d)}))}async ensureReferencedCollectionsExportUpToDateEnumUtils(e){let r=new Set;for(let n of e.variables){if(n.type!=="controlReference"||n.expectedType!=="enum")continue;let i=Ee(n.entityIdentifier);if(!Vr(i)||i.type!=="collection")continue;let d=this.modulesStore.forType("collection").getByStableName(i.localIdName)?.annotations(null,"default")?.framerEnumToDisplayNameUtils;B(d)&&d>=2||r.add(i.localIdName)}for(let n of r)ke("ui_interaction",{page:"canvas",id:"regenerate-collection-for-enum-utils"}),await this.forceComponentUpdate(n)}async ensureAllNodesWithLinksHaveLinkedScopesLoaded(e){let r=new Set;this.treeStore.tree.beginAllowPartialScopeAccess();for(let n of e.walkWithSkipChildren()){if(!la(n.node))continue;let i=n.node.getLink();if(!ks(i))continue;let s=this.treeStore.tree.get(i.webPageId);if(!s||s.loaded)continue;let a=this.modulesStore.forType("screen").getByStableName(i.webPageId)?.annotations(null,"default");U(a?.framerScrollSections)&&(r.add(s),n.skipChildren())}this.treeStore.tree.endAllowPartialScopeAccess(),await this.treeStore.tree.loadScopes(Array.from(r))}};It=new WeakMap,H=new WeakMap,ot=new WeakMap,Nr=new WeakMap,on=new WeakMap,Rr=new WeakMap,xr=new WeakMap,Y=new WeakMap,Ro=new WeakSet,il=async function(e,r,n,i){if(!Et(e)&&!this.treeStore.tree.has(r.id))return;let s=this.telemetrySession(e.id),a=s.start("synchronize"),d=performance.now();j.debug("Waiting for ModulesStore to be idle",{id:e.id}),await this.modulesStore.whenIdle();let c=performance.now()-d;if(j.debug("Waited",Math.round(c/1e3*100)/100,"seconds for ModulesStore to be idle",{id:e.id}),a.end(),!this.treeStore.tree.has(r.id))return;let u=e.draftOrCurrent();if(n!==2&&this.isSkippedEmptyScopeNode(u))return;let l=s.start("serialize");ee(e)&&Nm(e,this.componentLoader,this.treeStore,this);let h=this.serializerForSourceNode(e);T(this,Y).get(e.id)?.resolve(),T(this,Y).delete(e.id);let g=await h(e,{componentLoader:this.componentLoader,assetMap:this.assetMap,modulesStore:this.modulesStore,treeStore:this.treeStore,vectorsStore:this.vectorsStore,aiGenerationStore:this.aiGenerationStore,engineChanges:this.engineChanges,measureNodes:this.measureNodes},{serializationId:this.getSerializationId(),initialIntrinsicSize:i?.intrinsicSize,includeVectorSetSaveIds:i?.includeVectorSetSaveIds});return g.forEach(({source:y,artifacts:b})=>{if(j.trace("serializeComponent",`
>>>> >>>>
`,_(y),`
<<<< <<<<`),b?.submodules)for(let[v,C]of b.submodules)j.trace("serializeComponent",`
>>>>`,v,`>>>>
`,C,`
<<<<`,v,"<<<<")}),l.end(g),g};function Nm(o,t,e,r){let n=o.instanceIdentifier,i=t.dataForIdentifier(n);if(!i||!Object.values(i.properties).some(d=>d?.type==="image"))return;let a=new Set;for(let d of e.tree.root.children){if(!kt(d))continue;if(M(d)&&d.dataIdentifier===n){a.add(d);continue}d.loaded?.some(u=>hs(u)&&u.dataIdentifier===n)&&a.add(d)}a.forEach(d=>{r.forceComponentUpdate(d.id).catch(as)})}function xo(o){let{appEnvironment:t,session:e,seq:r,count:n,reasons:i,changes:s}=o;return{appEnvironment:t,session:e,seq:r,changes:s,count:n,reasons:i}}function sl(o,t){return{...o,next:t}}function al(o){return"rows"in o}var Rm={cache:!0,update:!0,mutable:!0,children:!0};function xm(o,t){if(o!=="cached")return t}function dl(o){return JSON.parse(JSON.stringify(o,xm))}function Do(o,t,e){let r=new Set,n=!1;function i(a,d){r.add(a.id),d+="."+a.id;let c=t.get(a.id);if(!c)n=!0,e.push("-node: "+d+(Zt(a)?" (replica child)":""));else{let u=[],l=a.children?.map(g=>g.id).join(","),h=c.children?.map(g=>g.id).join(",");l!==h&&u.push(" .children: ["+l+"] != ["+h+"]");for(let[g,y]of a.entries()){if(g in Rm)continue;let b=c[g];ct(y,b)?y&&typeof y=="object"&&y.__proto__!==(typeof b=="object"&&b&&"__proto__"in b?b.__proto__:void 0)&&u.push(" ."+g+": different prototypes"):(y===void 0||b===void 0||!ct(dl(y),dl(b)))&&g!=="contentHash"&&u.push(" ."+g+": "+JSON.stringify(y)+" != "+JSON.stringify(b))}u.length>0&&(n=!0,e.push("!node: "+d+(Zt(a)?" (replica child)":"")),e.push(...u))}for(let u of a.children??[])i(u,d)}function s(a,d){d+="."+a.id,r.has(a.id)||(n=!0,e.push("+node: "+d+(Zt(a)?" (replica child)":"")));for(let c of a.children??[])s(c,d)}return i(o.root,""),s(t.root,""),n}var ts=class{constructor(t,e){this.id=t;this.store=e;f(this,"loadedScope")}loadScopeDataFromStore(){let t=this.store.getObject(this.id);if(!t){Ne.debug("No object with id "+this.id+" in the store");return}return t}createNodeFromData(t){let e=this.buildPage(t);if(e)return e.cache.isShallowLoad=!1,e}async run(t){if(this.loadedScope)return this.loadedScope;let e=performance.now(),r=this.loadScopeDataFromStore(),n=performance.now()-e;if(await t.yield(),this.loadedScope)return this.loadedScope;let i=performance.now(),s=this.createNodeFromData(r),a=performance.now()-i;return this.loadedScope=new At(s,n+a),this.loadedScope}force(){if(this.loadedScope)return this.loadedScope;let t=performance.now(),e=this.loadScopeDataFromStore(),r=this.createNodeFromData(e),n=performance.now()-t;return this.loadedScope=new At(r,n),this.loadedScope}buildPage(t){if(!t)return;let e=[],r=Ne.isLoggingTraceMessages()?[]:void 0,n=pt(t,void 0,{extraChecksAndFixes:!0,errors:e,warnings:r});if(n&&zn(n,e),e.length>0&&Ne.warn("errors loading server tree: "+e.join(`
`)),r&&r.length>0&&Ne.trace("warnings loading server tree: "+r.join(`
`)),!!n)return n}},Ne=x("CrdtDocumentLoader"),Dr=class extends rt{constructor(e,...r){super(...r);this.store=e;f(this,"parsedIds",new Set)}async loadFirstCrdtTree(e){let r=[],i=this.store.getObjectWithShallowChildren(e.rootId,1),s=[...vd],a,d=this.settings.activeNodeId,c=d?this.store.getObjectWithShallowChildren(d,1):void 0;for(;c&&c.parentid!==e.rootId;){if(!c.parentid)throw Error("active node has no parent");c=this.store.getObjectWithShallowChildren(c.parentid,1)}je(c)?s.push(c.id):(a=Un(i.children,i?.homePageNodeId),s.push(a.maybeFirstPage.id));let u=pt(i,null,{extraChecksAndFixes:!0,errors:r,warnings:r});m(u,"Unable to load document");for(let g of u.children)g.cache.isShallowLoad=!0;for(let g of s){if(!g)continue;let y=this.store.getObject(g);if(!y){Ne.debug("No value for "+g);continue}let b=pt(y);m(b,"Scope node instance could not be created"),b.cache.isShallowLoad=!1;let v=u.children.findIndex(w=>w.id===g);u.children[v]=b,this.parsedIds.add(g);let C=b;g===a?.maybeFirstPage.id&&a.firstDesignPage&&td(C,a.firstDesignPage)!==C&&s.push(a.firstDesignPage.id)}hd(u,r);for(let g of u.children)this.parsedIds.has(g.id)||this.scopesToLoad.add(g.id);u.children.forEach(g=>{if(!this.parsedIds.has(g.id)&&Array.isArray(g.children)&&M(g)){g.cache.isShallowLoad=!0;return}});let l=kn.createByAdoptingRoot(u);l.verify(),l=Sn.treeDidLoad(l,this.componentLoader,[]).didNonLinearMove(this.componentLoader);let h=[];return pd(l,h)&&(h.forEach(g=>{r.push(`${g.id}: code component links itself via ${g.stack}`),gd(l,g.id,g.stack)}),l=l.commit(this.componentLoader)),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let g=performance.now();l.setService("loader",this),this.emit("loadedFirstData",l),ge("parsingFirstPage"),this.parsingDuration+=performance.now()-g}),l}async createTreeFromBuffer(e){this.documentSize=e.byteLength,this.store.fromBuffer(e);let r=this.store.getObject("meta");if(!r)throw new Error("Meta field not found");if(!ls(r.version))throw Error("cannot read document version");this.canvasTreeVersion=r.version,Ne.debug("createTree",this.canvasTreeVersion,cr(this.documentSize),Ie(this.loadingDuration)),this.emit("loadedDocumentVersion",r.version),this.tree=await this.loadFirstCrdtTree(r),await this.loadAllScopesAsync()}async start(){await this.scheduler.run(async()=>{Ne.debug("start"),ge("parsingInit"),this.updatePauseResumeState();let e=performance.now(),r=await this.loadCrdtData();this.loadingDuration=performance.now()-e,await this.scheduler.yield(),await this.createTreeFromBuffer(r)})}async loadCrdtData(){if(this.settings.loadedData&&this.settings.loadedData instanceof Uint8Array)return Ne.debug("loadData: loadedData"),this.settings.loadedData;let e=this.settings.initData,r=e?.version===this.treeVersion,n=e?.prefetchPromise;if(Ne.debug("loadData: prefetch"),r&&n){e&&delete e.prefetchPromise;let s=await n;if(n.then(a=>a.duration).then(a=>{ge("dataLoad",a)}),await this.scheduler.yield(),s.status<200||s.status>=300)throw new Error(`Failed to fetch project data. Status code: ${s.status}`);if(s.buffer){Ne.debug("loadData: prefetch bytes parser");let a=await s.buffer;return await this.scheduler.yield(),new Uint8Array(a)}}Ne.debug("loadData: fetch");let i;this.settings.refreshAccessToken&&(i=await this.settings.refreshAccessToken({}),await this.scheduler.yield());for(let s=0;s<Kn;++s){let a=await fetch(this.documentURL,i);if(a.ok){await this.scheduler.yield();let d=await a.arrayBuffer();return await this.scheduler.yield(),new Uint8Array(d)}(a.status<200||a.status>=300)&&(Ne.debug("onErrorStatusLoaded, retry:",s),await this.scheduler.sleep(s*$r+Math.random()*$r))}throw Error(`Failed to fetch project data after attempting ${Kn} times`)}createLoadingScope(e){return new ts(e,this.store)}};var Ge=x("remote:sync"),Eo=class{constructor(t){this.committer=t;f(this,"session",0);f(this,"treeVersion",0);f(this,"updatesSeen",0);f(this,"init",0);f(this,"expectingInitialUpdates",0);f(this,"hasError",!1);f(this,"waitingForTree",!1);f(this,"messageSeq",0);f(this,"unconfirmedCrdtUpdates",new Map)}get waitingForInitialUpdates(){return this.expectingInitialUpdates>this.updatesSeen}get isLoading(){return this.waitingForTree||this.waitingForInitialUpdates}get isReady(){return!(this.hasError||this.waitingForTree||this.waitingForInitialUpdates)}error(t,e){return this.hasError=!0,Error(t,{cause:e})}verify(t,e){let r=this.committer.getTreeForVersion(t);if(!r)return Ge.debug("verify: unable to find tree with version",t),!0;if(r.containsLocalEdits)return Ge.debug("verify: unable verify an entry with local edits"),!0;let n=r.tree,i=n.computeTreeHash();if(i!==e){if(Ge.warn("verify: failed",i,"!==",e),e===0)return!0;Ge.reportError("Tree verification failed",{localHash:i,serverHash:e,treeVersion:t,treeSize:n.size()})}else Ge.debug("verify: passed; hash:",e);return i===e}setTree(t,e,r){Ge.info("setTree",e),this.committer.reset(t,r),this.treeVersion=e,this.waitingForTree=!1,this.hasError=!1,this.unconfirmedCrdtUpdates.clear(),this.committer.recordHistoricTree(e,0)}resetSession(){this.messageSeq=0,this.unconfirmedCrdtUpdates.clear(),this.treeVersion=0,this.waitingForTree=!1}debugResetSessionAndTree(t){this.resetSession(),this.setTree(t,0)}handleInit(t,e){return this.init+=1,Ge.info("init",this.init,{treeVersion:t,initialUpdates:e,localTreeVersion:this.treeVersion}),this.hasError=!1,this.expectingInitialUpdates=e,this.updatesSeen=0,this.treeVersion!==t||this.waitingForTree?(this.waitingForTree=!0,!0):(this.committer.remoteTreeVersion=t,this.committer.recordHistoricTree(t,0),!1)}hasMessageForRemote(){return this.committer.hasLocalEdits()}hasOnlyEmptyChangesForRemote(){return this.committer.hasLocalEdits()?this.committer.hasOnlyEmptyChangesForRemote():!0}onLoadedFirstData(){this.committer.resetLastSeqTaken()}createMessage(t){let e=this.committer.takePendingRows(t);if(e.length<=0)return null;let r=this.committer.getEditReasons(),n={seq:++this.messageSeq,rows:e,reasons:r,ts:Date.now()};return Ge.debug("create CRDT rows message:",e.length,"inflight:",this.unconfirmedCrdtUpdates.size,n.seq),this.unconfirmedCrdtUpdates.set(n.seq,n),n}hasUnconfirmedChanges(){return this.unconfirmedCrdtUpdates.size>0}createUnconfirmedMessages(){m(this.isReady);let t=Array.from(this.unconfirmedCrdtUpdates.values());return this.unconfirmedCrdtUpdates.clear(),t.map(e=>{let r={...e,seq:++this.messageSeq};return this.unconfirmedCrdtUpdates.set(r.seq,r),r})}handleConfirmMessage(t){if(this.hasError||this.waitingForTree)return;let e=t.seq,r=this.unconfirmedCrdtUpdates.get(e);if(m(r,"update not found for seq",e),this.unconfirmedCrdtUpdates.delete(e),m(Number.isFinite(t.next),"Confirm must have tree version"),t.next!==this.treeVersion+1){if(t.next<=this.treeVersion){Ge.debug("ignoring old confirm:",t.next," <= ",this.treeVersion);return}throw this.error("missing update: "+this.treeVersion+" + 1 != "+t.next)}this.treeVersion=t.next,this.committer.handleRemoteConfirm(t.next,this.unconfirmedCrdtUpdates.size)}handleRemotePatches(t,e,r){if(!(this.hasError||this.waitingForTree)){if(m(Number.isFinite(e),"Update must have tree version"),e!==this.treeVersion+1){if(e<=this.treeVersion){Ge.debug("ignoring old update:",e," <= ",this.treeVersion);return}throw this.error("missing update: "+this.treeVersion+" + 1 != "+e)}return this.treeVersion=e,this.committer.handleRemotePatches(t,e,this.unconfirmedCrdtUpdates.size)}}resetTreesForRecovery(){return this.committer.tree}loadedAllScopes(){this.committer.loadedAllScopes(this.unconfirmedCrdtUpdates.size)}loadOneScope(t,e){return this.committer.loadOneScope(t,e)}};function ll(o,t,e){let r=new Set;for(let n of t){let i=cl(o,n.id,e);if(i&&r.add(i),n.key==="parentid"&&ro(n.value)){let s=ye(n.value);if(s!==N){let a=cl(o,s,e);a&&r.add(a)}}}return r}function cl(o,t,e){let r=t;for(;r;){let n=o.getObjectKey(r,"__class");if(n&&Dm(n,e))return r;let i=o.getParentId(r);if(!i||i===N)break;r=i}}function Dm(o,t){let e=t.get(o);if(e!==void 0)return e;let r=ka(o);if(!r)return!1;let n=Object.getPrototypeOf(r);for(;n;){if(n===Xs)return t.set(o,!0),!0;n=Object.getPrototypeOf(n)}return t.set(o,!1),!1}var wt=x("remote:connection"),Re=x("remote:verify"),Em=5,rs=class{constructor(t,e,r,n,i){this.componentLoader=e;this.userId=r;this.projectId=n;this.callbacks=i;f(this,"treeSync");f(this,"remoteUpdates",[]);f(this,"ignoreTreeVerifies",!1);f(this,"ignoreTreeVerifyVersion",0);f(this,"shouldCrashFromDebug",!1);f(this,"loader");f(this,"documentSize",0);f(this,"loaderPromise");f(this,"recorder");f(this,"scopeClassCache",new Map);f(this,"url");m(t instanceof po,"tree updater must be a CrdtTreeCommitter"),this.treeSync=new Eo(t),this.treeSync.waitingForTree=!0,window.store=this.store}get unconfirmedCrdtUpdates(){return this.treeSync.unconfirmedCrdtUpdates}get treeVersion(){return this.treeSync.treeVersion}get isReady(){return this.treeSync.isReady}get waitingForTree(){return this.treeSync.waitingForTree}get store(){return this.treeSync.committer.store}get isLoading(){return this.treeSync.isLoading}get localUpdatesInFlight(){return[]}get localUpdatesAtInit(){return[]}get hasError(){return this.treeSync.hasError}get init(){return this.treeSync.init}get session(){return this.treeSync.session}setTree(t,e,r){this.treeSync.setTree(t,e,r)}get hasUpdatesToProcess(){return!this.waitingForTree&&this.remoteUpdates.length>0}resetSession(){this.treeSync.resetSession()}debugResetSessionAndTree(t){this.treeSync.debugResetSessionAndTree(t)}debugCrash(){this.shouldCrashFromDebug=!0}canProcessChanges(){if(!this.treeSync.isReady||this.shouldCrashFromDebug){if(this.treeSync.hasOnlyEmptyChangesForRemote())return!1;let t="is not ready";throw this.treeSync.hasError?t="had an error":this.treeSync.waitingForTree?t="is waiting for tree data":this.treeSync.waitingForInitialUpdates?t="is waiting for initial updates":this.shouldCrashFromDebug&&(this.shouldCrashFromDebug=!1,t="is doing a deliberate crash test"),this.treeSync.error("cannot create local updates when the document "+t)}return!0}processViewOnly(){this.store.seq<=0||(this.treeSync.onLoadedFirstData(),wt.warn("cannot create local updates when the user is a viewer"))}handleRows(t,e){this.remoteUpdates.push(e)}handleConfirmRows(t){this.remoteUpdates.push(t)}handleInit(t,e){return this.remoteUpdates.length=0,{needsDownload:this.treeSync.handleInit(t,e)}}handleTreeUpdate(){throw new Error("Json tree updates cannot be handled by Crdt data handler")}handleTreeVerify(t,e,r){if(!this.treeSync.isReady||this.ignoreTreeVerifies||this.ignoreTreeVerifyVersion===e||this.treeSync.committer.tree.getService("loader"))return;if(!this.treeSync.verify(e,r)){wt.info("Tree verify failed for version",e,"hash",r);let s=this.treeSync.committer.getTreeForVersion(e)?.tree;s&&(this.verifyLocalTreeWithServer(t,s,e),this.verifyLocalTreeWithServerJson(t,s,e)),this.remoteUpdates.length=0,this.treeSync.hasError=!0;let a=new Error("Local document out of sync with document on server.");this.callbacks.error(a);return}let n=Vn(),i=Kt.isDevelopment||Kt.isLocal;if(n||i){let s=this.treeSync.committer.getTreeForVersion(e)?.tree;s&&(this.verifyLocalTreeWithServer(t,s,e),this.verifyLocalTreeWithServerJson(t,s,e))}}processRemoteUpdates(){if(wt.debug("processRemoteUpdates: starting - waitingForTree:",this.treeSync.waitingForTree,"waitingForInitialUpdates:",this.treeSync.waitingForInitialUpdates,"hasError:",this.treeSync.hasError,"isReady:",this.isReady,"remoteUpdates.length:",this.remoteUpdates.length),this.treeSync.waitingForTree){wt.debug("processRemoteUpdates: exiting early - waitingForTree=true");return}if(this.loader?.activelyLoadingScope){wt.debug("processRemoteUpdates: exiting early - activelyLoadingScope=true");return}let t;try{if(m(!this.treeSync.committer.tree.hasUncommittedChanges(),"tree must not have uncommitted changes"),this.shouldCrashFromDebug)throw this.shouldCrashFromDebug=!1,Error("RemoteDocument CrashTest");for(;this.remoteUpdates.length>0;){let e=this.remoteUpdates.shift();if(!e)break;if(t=e,!al(e)){this.treeSync.handleConfirmMessage(e);continue}m(typeof e.next=="number","Update must have tree version"),nt.verifyBatches(e.rows),this.ensureAllScopesAreLoaded(e.rows);let r=this.writeServerUpdateToTheStore(e);if(r){let n=this.treeSync.handleRemotePatches(r,e.next,e.rows.length);n&&this.loader?.addNodeChanges(n)}this.treeSync.updatesSeen+=1}if(this.loader){let e=this.treeSync.committer.tree.root.children;if(!e.some(n=>je(n)&&n.isValid())){wt.info("cannot show any page, forcing load of next page");let n=e.find(s=>je(s));if(!n)throw Error("No scope to load");let i=this.loader.loadScope(n.id);if(!i)throw Error("Unable to load scope");this.treeSync.loadOneScope(i,!1)}}this.callbacks.updateProcessed(this.treeSync.committer.tree)}catch(e){let r=Gt(e);throw this.remoteUpdates.length=0,wt.error("Error processing remote updates:",r),wt.debug("Last update:",t),this.callbacks.errorRecoverable(),this.treeSync.error(r.message),r}}async verifyTreeWithServer(){let t=new URL(`/projects/${this.projectId}/tree/latest?forceSnapshot=true`,window.location.href),e;try{this.ignoreTreeVerifies=!0,e=await fetch(t,await gt.withAuthorizationHeader({}))}finally{this.ignoreTreeVerifies=!1}if(!e.ok)throw Error(`unable to fetch document json: ${e.status} ${e.statusText}`);let r=e.headers.get("etag")||"",n=Number.parseInt(r.match(/Version-(\d+)/u)?.[1]??"0",10);if(!Number.isFinite(n)||n<=0)throw Error(`unable to parse document tree version from: ${r}`);let i=this.treeSync.treeVersion-n,s=this.treeSync.committer.getTreeForVersion(n)?.tree;if(!s)throw Error(`unable to get the local tree for version ${n}`);this.ignoreTreeVerifyVersion=n;let a=new Uint8Array(await e.arrayBuffer()),d=await this.loadServerTree(a,t.toString(),n),c=this.compareTreeWithServerJson(s,d,n);if(c)throw c;return this.url&&await this.verifyLocalTreeWithServerJson(this.url,s,n),i}async loadServerTree(t,e,r){m(!t||t instanceof Uint8Array,"treeData must be a Uint8Array");let n,i=new nt({client:0,user:""}),s=new Dr(i,this.componentLoader,r,e,{partialParsing:!0,loadInBackground:!0,loadedData:t,requestIdleCallback:this.callbacks.requestIdleCallback});return s.on("loadedFirstData",a=>{s.on("loadedScope",d=>{let c=a.root.children.findIndex(u=>u.id===d.id);a.remove(d.id),a.insertNode(d,a.root.id,c),a=a.commit(this.componentLoader)}),s.on("loadedAllData",()=>{n=a})}),await s.start(),m(n,"loadedAllData not called"),n}async loadServerJsonTree(t,e,r){let n,i=new rt(this.componentLoader,r,e,{partialParsing:!0,loadInBackground:!0,loadedData:t,requestIdleCallback:this.callbacks.requestIdleCallback});return i.on("loadedFirstData",s=>{i.on("loadedScope",a=>{let d=s.root.children.findIndex(c=>c.id===a.id);s.remove(a.id),s.insertNode(a,s.root.id,d),s=s.commit(this.componentLoader)}),i.on("loadedAllData",()=>{n=s})}),await i.start(),m(n,"loadedAllData not called"),n}flushUpdates(t){let e=this.treeSync.createMessage(this.userId);return e?(t.sendMessage({type:"rows",value:e}),!0):!1}resendUnconfirmedUpdates(t){let e=this.treeSync.createUnconfirmedMessages();for(let r of e)t.sendMessage({type:"rows",value:r})}cancelAndClearLoader(){this.loader?.scheduler.cancel(),this.loader=void 0}maybeSend(t){if(!this.treeSync.isReady||!this.treeSync.hasMessageForRemote())return"nothingToSend";if(this.treeSync.unconfirmedCrdtUpdates.size>=Em)return"postpone";let r=this.treeSync.createMessage(this.userId);return r?(t.sendMessage({type:"rows",value:r}),"didSend"):"nothingToSend"}writeServerUpdateToTheStore(t){let e=new nt({client:0,user:"temp-user"});e.addSerializableRows(t.rows);let r=Cc(this.store,e);return this.recorder&&this.recorder({source:"remote",rows:e.getSerializableRows()}),r}ensureAllScopesAreLoaded(t){if(!this.loader)return;let e=ll(this.store,t,this.scopeClassCache);for(let r of e){if(this.loader.hasLoadedScope(r))continue;let n=this.loader.loadScope(r);n&&this.treeSync.loadOneScope(n,!1)}}createLoader(t,e,r){this.url=t,this.loader?.scheduler.cancel();let n=new Dr(this.store,this.componentLoader,e,t,r);return this.loader=n,n.on("loadedFirstData",()=>{this.treeSync.onLoadedFirstData()}),this.loader}finishLoading(){this.loader=void 0}async verifyLocalTreeWithServer(t,e,r){try{let n=new URL(t.replace(/\d+\.crdt.*/u,r+".crdt"),window.location.href).pathname,i=new URL(n,window.location.href).toString();Re.debug("verifying local tree with server crdt:",i);let s=await fetch(i,await gt.withAuthorizationHeader({}));if(!s.ok)if(s.status===404){let c=new URL(`/projects/${this.projectId}/tree/latest`,window.location.href);if(Re.debug("404, retrying crdt with:",c),s=await fetch(c,await gt.withAuthorizationHeader({})),s.ok){if(!s.headers.get("etag")?.includes(r.toString()))throw Error(`lastest tree version does not match: ${s.headers.get("etag")} ${r}`)}else throw Error(`unable to fetch latest crdt document: ${s.status} ${s.statusText}`)}else throw Error(`unable to fetch crdt document: ${s.status} ${s.statusText}`);let a=new Uint8Array(await s.arrayBuffer()),d=await this.loadServerTree(a,t,r);Re.debug("using crdt from server"),this.compareTreeWithServerJson(e,d,r)}catch(n){Re.error("Error:",n),this.callbacks.error(Gt(n))}}async verifyLocalTreeWithServerJson(t,e,r){try{let n=new URL(t.replace(/\d+\.crdt.*/u,r+".json"),window.location.href).pathname,i=new URL(n,window.location.href).toString();Re.debug("verifying local tree with server json:",i);let s=await fetch(i,await gt.withAuthorizationHeader({}));if(!s.ok)throw Error(`unable to fetch document json: ${s.status} ${s.statusText}`);let a=await s.text(),d=await this.loadServerJsonTree(a,i,r);Re.debug("using json from server"),this.compareTreeWithServerJson(e,d,r)}catch(n){Re.error("Error:",n),this.callbacks.error(Gt(n))}}compareTreeWithServerJson(t,e,r){Re.debug("local:",t.computeTreeHash(),t.size(),"remote:",e.computeTreeHash(),e.size(),"version:",r);let n,i=[];return Do(t,e,i)?(Re.warn(`trees are different
`+i.join(`
`)),n=Error("Local document different from server document."),Re.reportError(n,{differences:i})):i.length>0?Re.debug(`trees have warnings:
`+i.join(`
`)):Re.debug("trees are same"),n}getRowsToSend(){return this.treeSync.committer.takePendingRows(this.userId)}loadedAllScopes(){this.treeSync.loadedAllScopes()}loadOneScope(t,e){return this.treeSync.loadOneScope(t,e)}hasUnconfirmedChanges(){return this.treeSync.hasUnconfirmedChanges()}resetTreesForRecovery(){return this.treeSync.resetTreesForRecovery()}error(t,e){return this.treeSync.error(t,e)}};var Nt=Dt(Uo(),1);var ul=Symbol("uninitialized");function Lm(o){return o+1}function FR(o,t,e,r){let n=js(),[,i]=(0,Nt.useReducer)(Lm,0),s=(0,Nt.useRef)(ul);s.current===ul&&(s.current=t());let a=(0,Nt.useRef)(t);a.current=t;let d=(0,Nt.useRef)(e);if(!yn(e,d.current)){d.current=e;let u=s.current,l=a.current();(r?!ct(u,l):!yn(u,l))&&(s.current=l)}let c=Array.isArray(o)?o:[o];return(0,Nt.useEffect)(()=>{let u=()=>{let g=s.current,y=a.current();(r?ct(g,y):yn(g,y))||(s.current=y,i())},l=[...c,u],h=n.scheduler.changes.observe(...l);return()=>n.scheduler.changes.removeObserver(h)},c),s.current}var ne=Dt(Uo(),1);var km=0,Lo=class{constructor(){f(this,"id",++km);f(this,"currentRtt",NaN);f(this,"rtts",[]);f(this,"rttIndex",0);f(this,"pending",Array.from(Array(128),()=>({type:"",time:0})));f(this,"start",0);f(this,"end",0);f(this,"overflow",0);f(this,"lastSendTime",0);f(this,"bytesSent",0);f(this,"bytesReceived",0)}read(){let{bytesSent:t,bytesReceived:e,id:r}=this;return this.bytesSent=0,this.bytesReceived=0,[t,e,this.rtt(),r]}computeRtt(){let t=this.rtts.length;if(t===0){this.currentRtt=NaN;return}let e=0;for(let r of this.rtts)e+=r;this.currentRtt=e/t}lastSend(){return this.lastSendTime}rtt(){return Number.isNaN(this.currentRtt)&&this.computeRtt(),Math.max(this.currentRtt||0,this.pendingRtt())}pendingRtt(){if(this.start===this.end)return 0;let t=this.pending[this.start];return performance.now()-t.time}pendingCount(t){if(!t)return this.start>this.end?128-this.start+this.end:this.end-this.start;let e=0;for(let r=this.start;r!==this.end;r=r+1&127)this.pending[r].type===t&&e++;return e}sent(t,e){this.bytesSent+=e.length,this.end===(this.start===0?127:this.start-1)&&(this.start=this.start+1&127,this.overflow++);let r=this.pending[this.end];r.type=t,r.time=performance.now(),this.end=this.end+1&127,this.lastSendTime=r.time}received(t){this.bytesReceived+=t.length}acked(){if(this.start===this.end){console.warn("Called SocketStats.acked() with empty buffer");return}if(this.overflow>0){this.overflow--;return}let t=this.pending[this.start],e=performance.now()-t.time;this.rtts.length<32?this.rtts.push(e):(this.rtts[this.rttIndex]=e,this.rttIndex=this.rttIndex+1&31),this.start=this.start+1&127,this.currentRtt=NaN}};var it=x("remote:socket"),Pm=30;function Mm(o){switch(o){case"AccessDenied":case"ClientNeedsUpdate":case"ClientTooNew":case"DocumentNotFound":case"UnsupportedSchema":case"Maintenance":case"UnknownPermanentError":case"ClientSidePermanentError":case"CrdtMigrationFailed":return!1;case"ReconnectToNewServer":case"UnknownRecoverableError":case"ClientSideRecoverableError":return!0;default:return ae(o)}}function WR({url:o,documentConnection:t,tunnel:e=void 0}){let r=(0,ne.useRef)(null),n=(0,ne.useRef)(!0),i=(0,ne.useRef)({onConnect:new Set,onDisconnect:new Set,onMessage:new Set}),s=(0,ne.useRef)(o),a=(0,ne.useRef)(!0),d=(0,ne.useRef)(void 0);function c(){d.current!==void 0&&(window.clearTimeout(d.current),d.current=void 0)}let u=(0,ne.useCallback)(()=>{a.current=!1;let y=r.current;y&&y.ws.readyState<WebSocket.CLOSING&&(y.clientClosed=!0,y.ws.close())},[]),l=(0,ne.useCallback)(()=>{if(c(),!a.current||r.current)return;function y(D){d.current===void 0&&(d.current=window.setTimeout(()=>{d.current=void 0,navigator.onLine&&!document.hidden&&l()},D))}let b=new URL(s.current);if(b.searchParams.set("v",Pm.toString()),b.searchParams.set("tunnel",e||""),ar()&&b.searchParams.set("mode","crdt"),t.treeSchema<=0)return;b.searchParams.set("treeSchema",t.treeSchema.toString()),b.searchParams.set("treeVersion",t.treeVersion.toString()),it.debug("connecting to",b.href);let v=performance.now(),C=new WebSocket(b.href),w=new Lo,R={ws:C,stats:w,clientClosed:!1};t.setSocketStats(w);let E=0;C.addEventListener("open",()=>{it.debug("open"),E=window.setInterval(()=>{if(performance.now()-w.lastSend()<1e3||w.pendingCount("ping")>1||C.readyState!==WebSocket.OPEN)return;let D="ping {}";C.send(D),w.sent("ping",D)},1e3);for(let D of i.current.onConnect)try{D(n.current)}catch(L){it.warn("Error in onConnect handler:",L)}n.current=!1}),C.addEventListener("close",D=>{let L=Am(D);if(it.debug("close:",L,"clientClosed:",R.clientClosed,D),E!==0&&(clearInterval(E),E=0),r.current===R){Mm(L)||(a.current=!1);for(let V of i.current.onDisconnect)try{V(L)}catch(F){it.warn("Error in onDisconnect handler:",F)}if(r.current=null,a.current){let V=1e3;L==="ReconnectToNewServer"?V=50:performance.now()-v<5e3&&(V=5e3),y(V)}}}),C.addEventListener("message",D=>{try{let L=D.data;w.received(L);let V=Fm(L);if(V.type==="ack"){w.acked();return}else V.type==="redirect"&&(s.current=V.value.url);for(let F of i.current.onMessage)try{F(V)}catch(se){it.warn("Error in onMessage handler:",se)}}catch(L){it.warn("Error receiving:",L)}}),r.current=R},[t]);(0,ne.useEffect)(()=>{l()},[l]);let h=(0,ne.useCallback)(({online:y,visible:b})=>{y&&b?l():c()},[l]);return Vm(h),(0,ne.useMemo)(()=>({getSocketStats(){return r.current?.stats},connect(){a.current=!0,l()},disconnect(){u()},onConnect(y){return i.current.onConnect.add(y),()=>{i.current.onConnect.delete(y)}},onDisconnect(y){return i.current.onDisconnect.add(y),()=>{i.current.onDisconnect.delete(y)}},onMessage(y){return i.current.onMessage.add(y),()=>{i.current.onMessage.delete(y)}},send(y){if(!r.current||r.current.ws.readyState!==1){y.type!=="state"&&it.warn("Dropping",y.type,"message.");return}try{let b=`${y.type} ${JSON.stringify(y.value)}`;r.current.ws.send(b),r.current.stats.sent(y.type,b)}catch(b){it.warn("Error sending",y.type,"message:",b)}}}),[l,u])}function Vm(o){(0,ne.useEffect)(()=>{document.addEventListener("visibilitychange",t),window.addEventListener("online",t),window.addEventListener("offline",t);function t(){o({online:navigator.onLine,visible:!document.hidden})}return()=>{document.removeEventListener("visibilitychange",t),window.removeEventListener("online",t),window.removeEventListener("offline",t)}},[o])}function Am(o){switch(o.reason){case"ERR_RECONNECT_TO_NEW_SERVER":return"ReconnectToNewServer";case"ERR_ACCESS_DENIED":return"AccessDenied";case"ERR_CLIENT_NEEDS_UPDATE":return"ClientNeedsUpdate";case"ERR_DOCUMENT_NOT_FOUND":return"DocumentNotFound";case"ERR_UNSUPPORTED_SCHEMA_VERSION":return"UnsupportedSchema";case"ERR_MAINTENANCE":return"Maintenance";case"ERR_INVALID_OPERATION":return"ClientSidePermanentError";case"ERR_CRDT_MIGRATION_FAILED":return"CrdtMigrationFailed";case"ERR_UNKNOWN":return"UnknownPermanentError"}return o.code===1011?"ClientNeedsUpdate":"UnknownRecoverableError"}function Fm(o){let t=o.indexOf(" "),e=o.indexOf(" ",t+1);m(t>=0&&e>=0,"Invalid data");let r=o.substring(0,t),n=o.substring(t+1,e),i=o.substring(e+1),s=JSON.parse(i);return{id:r,type:n,value:s}}function fl(o){return typeof o=="object"&&o!==null&&"next"in o}function ko(o){return fl(o)&&"session"in o}function Po(o){return fl(o)&&"changes"in o&&Array.isArray(o.changes)}var Ke=x("remote:sync"),ml=2**52,Mo=class{constructor(t,e,r=0,n){this.timeline=t;this.componentLoader=e;f(this,"rollingDiff",null);f(this,"session",Math.floor(Math.random()*ml));f(this,"seq",0);f(this,"treeVersion",0);f(this,"updatesSeen",0);f(this,"init",0);f(this,"expectingInitialUpdates",0);f(this,"localUpdatesInFlight",[]);f(this,"localUpdatesAtInit",[]);f(this,"hasError",!1);f(this,"waitingForTree",!1);this.setTree(t.tree,r,n)}get waitingForInitialUpdates(){return this.expectingInitialUpdates>this.updatesSeen}get isLoading(){return this.waitingForTree||this.waitingForInitialUpdates}get isReady(){return!(this.hasError||this.waitingForTree||this.waitingForInitialUpdates)}get tree(){return this.timeline.tree}error(t,e){return this.hasError=!0,Error(t,{cause:e})}verify(t,e){let r=this.timeline.getTreeForVersion(t);if(!r)return Ke.info("verify: unable to find tree with version",t),!0;let n=r.computeTreeHash();if(n!==e){if(Ke.warn("verify: failed",n,"!==",e),e===0)return!0;Ke.reportError("Tree verification failed",{localHash:n,serverHash:e,treeVersion:t,treeSize:r.size()})}else Ke.debug("verify: passed; hash:",e);return n===e}setTree(t,e,r){Ke.info("setTree",e),this.timeline.reset(t,r),this.setRemoteTreeVersion(e),!!r?.isLoading&&(this.rollingDiff=new ur,this.rollingDiff.addChanges(r?.initialChanges)),this.treeVersion=e,this.waitingForTree=!1,this.hasError=!1,this.localUpdatesInFlight=[]}resetSession(){this.treeVersion=0,this.session=Math.floor(Math.random()*ml),this.localUpdatesInFlight=[],this.localUpdatesAtInit=[]}debugResetSessionAndTree(t){this.resetSession(),this.setTree(t,0)}handleInit(t,e){return this.init+=1,this.init===1&&ge("wsTreeInitMessages"),Ke.info("init",this.init,{treeVersion:t,initialUpdates:e,localTreeVersion:this.treeVersion}),Ke.debug("init updates:",{seen:this.updatesSeen,inFlight:this.localUpdatesInFlight.length,previous:this.localUpdatesAtInit.length}),this.hasError=!1,this.expectingInitialUpdates=e,this.updatesSeen=0,this.localUpdatesAtInit=this.localUpdatesInFlight.slice(),this.treeVersion!==t||this.waitingForTree?(this.waitingForTree=!0,!0):!1}trimForShallowLoading(){let t=this.timeline,e=this.getRemoteIndex()-3;e<=0||(t.trimmed+=e,Ke.debug("trim",e,"new offset:",t.trimmed,"entries.length:",t.entries.length,"after load"),t.entries.splice(0,e),m(this.timeline.remoteTreeIndex===0||this.getRemoteIndex()>=0,"must have some buffer before remoteTreeIndex"))}loadedAllScopes(){let t=this.timeline;Ke.info("done loading, took:",Math.round((performance.now()-t.resetTime)/100)/10,"seconds"),m(t.isPartialLoading,"Must be in loading mode"),t.isPartialLoading=!1,this.rollingDiff=null;let e=this.getRemoteEntry();e&&(e.version=t.remoteTreeVersion,this.trimForShallowLoading())}loadOneScope(t,e){let r=this.timeline;Ke.debug("loadOneScope:",t.id),m(r.isPartialLoading,"Must be loading"),m(!t.cache.isShallowLoad,"Scope must not be shallow");let n=this.getRemoteEntry();m(n,"remote tree is missing");let i=r.tree.isViewOnly;n.tree.editClosed=!1,n.tree.isViewOnly=!1,n.tree.inEditor=!1,n.tree.makeLatest();let s=new Set,a=n.tree.root.children.findIndex(c=>c.id===t.id);if(t.__class==="WebPageNode"||t.__class==="SmartComponentNode"){fo(t),n.tree=n.tree.commitWithLoadedScope(this.componentLoader,t);for(let c of t.walk())r.trackChange(c.id),s.add(c.id)}else n.tree.remove(t.id),n.tree.insertNode(t,n.tree.root.id,a);if(this.rollingDiff){let c=this.rollingDiff.getChanges();s.size>0?sr(c,s)&&Pe(n.tree,c):Pe(n.tree,c)}else{let c=0,u=s.size>0,l=this.getRemoteIndex();for(let h of r.entries){if(c>l)break;c++,!h.wasScopeInsert&&(u&&!sr(h.changes,s)||(u=!1,Pe(n.tree,h.changes)))}}a===-1?m(!n.tree.get(t.id),"Scope must have been deleted by remote diffs"):n.tree.loadReplicasAndCodeComponents(t);let d=n.tree.commit(this.componentLoader,(c,u)=>{let l=c?.id??u?.id;l&&r.trackChange(l)});return n.tree.inEditor=!0,d.inEditor=!0,this.incrementRemoteTreeIndex(),e||(r.latestReversibleNodeChanges=null),this.addTreeToTimeline(d),r.legacyMode&&r.invalidateAllCursors(),r.tree.isViewOnly=i,this.rollingDiff&&this.trimForShallowLoading(),r.tree}getRemoteEntry(){return this.timeline.getEntry(this.getRemoteIndex())}setRemoteTreeVersion(t){if(this.timeline.remoteTreeVersion=t,this.timeline.isPartialLoading)return;let e=this.getRemoteEntry();m(e,"remote tree is missing"),e.version=t}};var Fe=x("remote:sync"),Vo=class extends Mo{constructor(){super(...arguments);f(this,"localChangesSentToRemote",0)}setTree(e,r,n){super.setTree(e,r,n),this.localChangesSentToRemote=0}handleRemoteUpdate(e){if(this.hasError||this.waitingForTree)return;m(typeof e.next=="number","must be a valid tree update");let r=e.next;if(Fe.trace("this:",this.session,this.seq,"at:",this.treeVersion,"update:",e),r!==this.treeVersion+1){if(r<=this.treeVersion){Fe.debug("ignoring old update:",r," <= ",this.treeVersion);return}throw this.error("missing update: "+this.treeVersion+" + 1 != "+r)}if(this.updatesSeen+=1,this.treeVersion=r,ko(e)&&e.session===this.session){let n=this.localUpdatesInFlight[0];if(n?.seq===e.seq)this.localUpdatesInFlight.shift(),this.confirmLocalChangesByRemote(n.count,r),n.confirmed=!0;else{let i=this.localUpdatesAtInit.find(s=>s.seq===e.seq);if(i)this.insertRemoteChanges(i.changes,r),i.confirmed=!0;else{let s=this.localUpdatesInFlight.findIndex(d=>d.seq===e.seq),a=s===-1?"unknown local update: "+e.seq+" != "+n?.seq:"missing local update: "+e.seq+" != "+n?.seq+", is index: "+s;throw this.error(a)}}}else Po(e)?e.changes.length>0&&this.insertRemoteChanges(e.changes,r):Fe.reportErrorOncePerMinute(new Error("Unknown remote update"),{update:e})}confirmLocalChangesByRemote(e,r=0){let n=this.timeline;if(m(e>=1,"cannot confirm less than one change"),m(this.localChangesSentToRemote>=e,"cannot confirm local changes that have not been sent"),m(n.remoteTreeIndex<n.localTreeIndex,"must have unconfirmed local changes"),this.rollingDiff)for(let i=1;i<=e;i++)this.rollingDiff.addChanges(n.getEntry(n.remoteTreeIndex+i)?.changes);return this.localChangesSentToRemote-=e,n.incrementRemoteTreeIndex(e),this.setRemoteTreeVersion(r),n.tree}insertRemoteChanges(e,r=0){let n=this.timeline;Fe.debug("insertRemoteChanges:",e.length),m(n.tree===n.getLastEntry().tree,"tree out of sync"),m(n.remoteTreeIndex<=n.localTreeIndex,"remote tree too far ahead"),this.rollingDiff&&this.rollingDiff.addChanges(e);let i=this.getRemoteEntry();m(i,"remote tree is missing");let s=n.tree.isViewOnly;i.tree.editClosed=!1,i.tree.isViewOnly=!1,i.tree.makeLatest(),i.tree.beginAllowPartialScopeAccess(),Pe(i.tree,e);let a=i.tree.commitDiffs(this.componentLoader);for(let c of e)n.trackChange(c.id,c);for(let c of i.tree.getNodesChangedByCommit())n.trackChange(c.id);n.incrementRemoteTreeIndex(1),n.latestReversibleNodeChanges=null;let d=n.entries.length-this.getRemoteIndex();return m(d>=0,"computed rebase is off"),d===0?this.addRemoteTreeWithChanges(a,e):this.rebaseRemoteTreeWithChanges(a,e,d),this.trim(),this.setRemoteTreeVersion(r),i.tree.endAllowPartialScopeAccess(),n.tree.isViewOnly=s,n.tree}addRemoteTreeWithChanges(e,r){Fe.trace("addRemoteTreeWithChanges:",r.length);let n=this.timeline.getLastEntry();return m(e.lineage===n.tree.lineage,"Trees must belong to the same line."),m(!e.hasUncommittedChanges(),"Tree cannot have uncommitted changes."),n.tree!==e&&n.tree.releaseMemory(),this.timeline.addEntry(e,r)}rebaseRemoteTreeWithChanges(e,r,n){let i=this.timeline;Fe.debug("rebaseRemoteTreeWithChanges:",n,"changes:",r.length),m(e.lineage===i.getLastEntry().tree.lineage,"Trees must belong to the same line."),m(!e.hasUncommittedChanges(),"Tree cannot have uncommitted changes."),m(i.entries.length>=n,"rebase",n,"> commits",i.entries.length);let s=i.entries.splice(i.entries.length-n,n);m(s.length===n,"must have",n,"entries to process");let a=i.addEntry(e,r,[],!0),d=e;for(let c=0;c<n;c++){let u=s[c];Pe(e,u.changes),e=e.commitDiffs(this.componentLoader);for(let l of u.changes)i.trackChange(l.id,l);for(let l of d.getNodesChangedByCommit())i.trackChange(l.id);i.addEntry(e,u.changes,u.editReasons,u.wasRebase),e!==d&&(d.releaseMemory(),d=e)}return i.tree=e,a}addTreeToTimeline(e){let n=this.timeline.entries.length-this.getRemoteIndex();m(n>=0,"computed rebase is off");let i;n===0?i=this.addRemoteTreeWithChanges(e,[]):i=this.rebaseRemoteTreeWithChanges(e,[],n),i.wasScopeInsert=!0}loadCompleteTree(e,r=0){let n=this.timeline;Fe.debug("load complete tree:",n.tree.sizeAtStart(),"->",e.size(),"entries:",n.entries.length),m(n.trimmed===0,"cannot load complete tree while having local changes"),m(!e.hasUncommittedChanges(),"tree should be clean"),n.entries.forEach((d,c)=>{c>n.remoteTreeIndex||Pe(e,d.changes)}),e.hasUncommittedChanges()&&(e=e.commitDiffs(this.componentLoader));let i=[],s=n.tree;if(s.sizeAtStart()*2>e.size()){let d={};for(let c of e.root.walk()){let u=s.getNodeAtStart(c.id)||void 0,l=ht(u,c);l&&(d[l.id]=l),n.trackChange(c.id,l)}i=Object.values(d),Fe.debug("load complete tree, diff:",i.length)}else n.invalidateAllCursors(),Fe.debug("load complete tree, resending:",n.tree.size());n.incrementRemoteTreeIndex(1),n.latestReversibleNodeChanges=null;let a=n.entries.length-n.remoteTreeIndex;return m(a>=0,"computed rebase is off"),e.lineage!==n.tree.lineage?(n.reset(e),this.setRemoteTreeVersion(r),n.tree):(a===0?this.addRemoteTreeWithChanges(e,i):this.rebaseRemoteTreeWithChanges(e,i,a),this.setRemoteTreeVersion(r),this.trim(),n.tree.forEachNode(d=>n.trackChange(d.id)),n.tree)}incrementRemoteTreeIndex(){this.timeline.incrementRemoteTreeIndex(1)}getRemoteIndex(){return this.timeline.remoteTreeIndex-this.timeline.trimmed}getUnconfirmedChangeCount(){return this.timeline.localTreeIndex-this.timeline.remoteTreeIndex}hasChangesForRemote(){let e=this.timeline.remoteTreeIndex+this.localChangesSentToRemote,r=this.timeline.localTreeIndex;return m(e<=r,"inconsistency in getting local changes to send"),e<r}hasOnlyEmptyChangesForRemote(){let e=this.timeline.remoteTreeIndex+this.localChangesSentToRemote,r=this.timeline.localTreeIndex;return e>=r?!0:this.timeline.computeForwardChanges(e,r).length===0}createUpdateToSend(){if(!this.isReady)throw Error("cannot create updates while not ready");if(!this.hasChangesForRemote())return null;let{changes:e,count:r,reasons:n}=this.getForwardChangesForRemote(),i=++this.seq,s={session:this.session,seq:i,changes:e,count:r,reasons:n,confirmed:!1};return this.localUpdatesInFlight.push(s),s}getForwardChangesForRemote(){let e=this.timeline.remoteTreeIndex+this.localChangesSentToRemote,r=this.timeline.localTreeIndex,n=this.timeline.getChangesBetweenEntries(e,r);return this.localChangesSentToRemote+=n.count,n}commitAndCreateUpdate(e=0){m(dt.isTest),this.timeline.commitLocalTree();let r=this.createUpdateToSend();return r?sl(r,e):null}resetTreesForRecovery(){return Fe.info("reset trees for recovery, remote:",this.getRemoteIndex(),"last index:",this.timeline.localTreeIndex,"number of entries to reapply to remote tree",this.localChangesSentToRemote),this.timeline.resetTreesForRecovery(this.getRemoteIndex(),this.localChangesSentToRemote)}trim(){if(this.timeline.isPartialLoading)return;let e=0;this.timeline.remoteTreeIndex>0?e=this.getRemoteIndex()-100:e=this.timeline.localTreeIndex-this.timeline.trimmed-100,!(e<=75)&&(this.timeline.trimmed+=e,Fe.debug("trim",e,"new offset:",this.timeline.trimmed,"entries.length:",this.timeline.entries.length),this.timeline.entries.splice(0,e),m(this.timeline.remoteTreeIndex===0||this.getRemoteIndex()>=0,"must have some buffer before remoteTreeIndex"))}};var Er=x("remote:connection"),jt=x("remote:verify"),Um=5,pl=class{constructor(t,e,r,n){this.componentLoader=e;this.projectId=r;this.callbacks=n;f(this,"treeSync");f(this,"remoteUpdates",[]);f(this,"ignoreTreeVerifies",!1);f(this,"ignoreTreeVerifyVersion",0);f(this,"shouldCrashFromDebug",!1);f(this,"loader");m(t instanceof Yn,"timeline must be a TreeTimeline"),this.treeSync=new Vo(t,e),this.treeSync.waitingForTree=!0}get init(){return this.treeSync.init}setTree(t,e,r){this.treeSync.setTree(t,e,r)}get timeline(){return this.treeSync.timeline}get treeVersion(){return this.treeSync.treeVersion}get isReady(){return this.treeSync.isReady}get waitingForTree(){return this.treeSync.waitingForTree}get isLoading(){return this.treeSync.isLoading}get session(){return this.treeSync.session}resetSession(){this.treeSync.resetSession()}debugResetSessionAndTree(t){this.treeSync.debugResetSessionAndTree(t)}debugCrash(){this.shouldCrashFromDebug=!0}canProcessChanges(){if(this.treeSync.trim(),!this.treeSync.isReady||this.shouldCrashFromDebug){if(this.treeSync.hasOnlyEmptyChangesForRemote())return!1;let t="is not ready";throw this.treeSync.hasError?t="had an error":this.treeSync.waitingForTree?t="is waiting for tree data":this.treeSync.waitingForInitialUpdates?t="is waiting for initial updates":this.shouldCrashFromDebug&&(this.shouldCrashFromDebug=!1,t="is doing a deliberate crash test"),this.treeSync.error("cannot create local updates when the document "+t)}return!0}processViewOnly(){if(!this.treeSync.hasChangesForRemote())return;let{changes:t,count:e}=this.treeSync.getForwardChangesForRemote();Er.warn("cannot create local updates when the user is a viewer, ignoring:",t),this.treeSync.confirmLocalChangesByRemote(e)}maybeSend(t){if(!this.treeSync.isReady||!this.treeSync.hasChangesForRemote())return"nothingToSend";let e=this.treeSync.localUpdatesInFlight.length;if(e>=Um)return"postpone";let r=this.treeSync.createUpdateToSend();return r?(Er.debug("sending update:",e,r.changes.length,r.reasons),t.sendMessage({type:"treeUpdate",value:xo(r)}),"didSend"):"nothingToSend"}handleRows(){throw Error("Crdt tree updates cannot be handled by Json data handler")}handleConfirmRows(){throw Error("Crdt tree updates cannot be handled by Json data handler")}get hasUpdatesToProcess(){return!this.waitingForTree&&this.remoteUpdates.length>0}handleInit(t,e){return this.remoteUpdates.length=0,{needsDownload:this.treeSync.handleInit(t,e)}}handleTreeVerify(t,e,r){if(!this.treeSync.isReady||this.ignoreTreeVerifies||this.ignoreTreeVerifyVersion===e)return;if(!this.treeSync.verify(e,r)){let s=this.treeSync.timeline.getTreeForVersion(e);if(s){let d=this.treeSync.timeline.entries.slice();this.verifyLocalTreeWithServer(t,s,e,d)}this.remoteUpdates.length=0,this.treeSync.hasError=!0;let a=new Error("Local document out of sync with document on server.");this.callbacks.error(a);return}let n=Vn(),i=Kt.isDevelopment||Kt.isLocal;if(n||i){let s=this.treeSync.timeline.getTreeForVersion(e);if(s){let a=this.treeSync.timeline.entries.slice();this.verifyLocalTreeWithServer(t,s,e,a)}}}async verifyLocalTreeWithServer(t,e,r,n){try{let i=t.replace(/\d+\.json/u,r+".json"),s=await fetch(i,await gt.withAuthorizationHeader({}));if(!s.ok)throw Error(`unable to fetch document json: ${s.status} ${s.statusText}`);let a=await s.text(),d=await this.loadServerTree(a,i,r);this.compareTreeWithServerJson(e,d,r,n)}catch(i){jt.error("Error:",i)}}compareTreeWithServerJson(t,e,r,n){jt.debug("local:",t.computeTreeHash(),t.size(),"remote:",e.computeTreeHash(),e.size(),"version:",r);let i,s=[];return Do(t,e,s)?(jt.warn(`trees are different
`+s.join(`
`)),n&&jt.debug("timeline.entries",n),i=Error("Local document different from server document."),jt.reportError(i,{differences:s,changes:n?.slice(-25).map(d=>d.changes)})):s.length>0?jt.debug(`trees have warnings:
`+s.join(`
`)):jt.debug("trees are same"),i}handleTreeUpdate(t){this.remoteUpdates.push(t)}processRemoteUpdates(){if(this.treeSync.waitingForTree)return;let t;try{if(m(!this.timeline.tree.hasUncommittedChanges(),"tree must not have uncommitted changes"),this.shouldCrashFromDebug)throw this.shouldCrashFromDebug=!1,Error("RemoteDocument CrashTest");for(;this.remoteUpdates.length>0;){let e=this.remoteUpdates.shift();if(!e)break;t=e,this.ensureAllScopesAreLoaded(e),this.treeSync.handleRemoteUpdate(e),this.loader&&!ko(e)&&this.loader.addNodeChanges(e.changes)}if(this.loader){let e=this.timeline.tree.root.children;if(!e.some(n=>je(n)&&n.isValid())){Er.info("cannot show any page, forcing load of next page");let n=e.find(s=>je(s));if(!n)throw Error("No scope to load");let i=this.loader.loadScope(n.id);if(!i)throw Error("Unable to load scope");this.treeSync.loadOneScope(i,!1)}}this.callbacks.updateProcessed(this.timeline.tree)}catch(e){let r=Gt(e);throw this.remoteUpdates.length=0,Er.error("Error processing remote updates:",r),Er.debug("Last update:",t),this.treeSync.error(r.message),this.callbacks.errorRecoverable(),r}}ensureAllScopesAreLoaded(t){if(!this.loader||!Po(t))return;let e=new Set;for(let r of t.changes)r.previousScope&&(e.add(r.previousScope),e.add(r.to.parentid));for(let r of e){if(this.loader.hasLoadedScope(r))continue;let n=this.loader.loadScope(r);n&&this.treeSync.loadOneScope(n,!1)}}createLoader(t,e,r){this.loader?.scheduler.cancel();let n=new rt(this.componentLoader,e,t,r);return this.loader=n,this.loader}async verifyTreeWithServer(){let t=new URL(`/projects/${this.projectId}/tree/latest?forceSnapshot=true`,window.location.href),e;try{this.ignoreTreeVerifies=!0,e=await fetch(t,await gt.withAuthorizationHeader({}))}finally{this.ignoreTreeVerifies=!1}if(!e.ok)throw Error(`unable to fetch document json: ${e.status} ${e.statusText}`);let r=e.headers.get("etag")||"",n=Number.parseInt(r.match(/Version-(\d+)/u)?.[1]??"0",10);if(!Number.isFinite(n)||n<=0)throw Error(`unable to parse document tree version from: ${r}`);let i=this.treeSync.treeVersion-n,s=this.treeSync.timeline.getTreeForVersion(n);if(!s)throw Error(`unable to get the local tree for version ${n}`);this.ignoreTreeVerifyVersion=n;let a=await e.text(),d=await this.loadServerTree(a,t.toString(),n),c=this.compareTreeWithServerJson(s,d,n);if(c)throw c;return i}async loadServerTree(t,e,r){m(!t||Z(t),"treeData must be a string");let n,i=new rt(this.componentLoader,r,e,{partialParsing:!0,loadInBackground:!0,loadedData:t,requestIdleCallback:this.callbacks.requestIdleCallback});return i.on("loadedFirstData",s=>{i.on("loadedScope",a=>{let d=s.root.children.findIndex(c=>c.id===a.id);s.remove(a.id),s.insertNode(a,s.root.id,d),s=s.commit(this.componentLoader)}),i.on("loadedAllData",()=>{n=s})}),await i.start(),m(n,"loadedAllData not called"),n}get localUpdatesInFlight(){return this.treeSync.localUpdatesInFlight}get localUpdatesAtInit(){return this.treeSync.localUpdatesAtInit}get hasError(){return this.treeSync.hasError}flushUpdates(t){if(this.localUpdatesInFlight.length===0)return!1;let e=this.treeSync.createUpdateToSend();return e&&t.sendMessage({type:"treeUpdate",value:xo(e)}),!0}resendUnconfirmedUpdates(t){m(this.isReady);let e=this.localUpdatesAtInit.filter(r=>!r.confirmed);if(e.length!==0){Er.debug("resending local updates:",e.length);for(let r of e)t.sendMessage({type:"treeUpdate",value:xo(r)})}}cancelAndClearLoader(){this.loader?.scheduler.cancel(),this.loader=void 0}finishLoading(){this.loader=void 0}loadOneScope(t,e){return this.treeSync.loadOneScope(t,e)}loadedAllScopes(){this.treeSync.loadedAllScopes()}hasUnconfirmedChanges(){return this.treeSync.getUnconfirmedChangeCount()>0}resetTreesForRecovery(){return this.treeSync.resetTreesForRecovery()}error(t){return this.treeSync.error(t)}};async function Nx(o,t){return Ga.get(`/web/v1/sites/hostnames/${o}`,void 0,t)}var hl=class extends wn{};var gl=class{constructor(){f(this,"undoBuffer",[]);f(this,"redoBuffer",[]);f(this,"undoGroup",[]);f(this,"scheduledEndUndoGroup")}canUndo(){return this.undoBuffer.length>0}peekUndo(){return this.undoBuffer.at(-1)}undo(t,e){let r=this.undoBuffer.pop();if(U(r))return;t.applyReverseChanges(r.changes),this.redoBuffer.push({...r,...e});let n=this.undoBuffer.length;return this.undoGroup.forEach((i,s)=>{this.undoGroup[s]=Math.min(i,n)}),r}canRedo(){return this.redoBuffer.length>0}peekRedo(){return this.redoBuffer.at(-1)}redo(t,e){let r=this.redoBuffer.pop();if(!U(r))return t.applyChanges(r.changes),this.undoBuffer.push({...r,...e}),r}beginUndoGroup(){this.undoGroup.push(this.undoBuffer.length)}discardUndoGroup(t){let e=this.undoGroup.pop();if(U(e)||e>=this.undoBuffer.length)return;let r=this.undoBuffer.splice(e),n=ei(r);return t.applyReverseChanges(n),r[0]}scheduleEndUndoGroup(){let t=this.undoGroup.pop();U(t)||t>=this.undoBuffer.length||(this.scheduledEndUndoGroup=t)}processScheduledEndUndoGroup(t){let e=this.scheduledEndUndoGroup;if(this.scheduledEndUndoGroup=void 0,U(e)||e>=this.undoBuffer.length)return;let r=this.undoBuffer.splice(e),n=ei(r);this.undoBuffer.push({changes:n,...t})}clearUndoStack(){this.undoBuffer.length=0,this.redoBuffer.length=0,this.undoGroup.length=0,this.scheduledEndUndoGroup=void 0}addUndoEntry(t){this.undoBuffer.push(t),this.redoBuffer.length=0}getUndoBufferSize(){return this.undoBuffer.length}};var yl="utils";function vl(o,t){let e=Ee(t);if(!fn(e)||e.kind!=="localModuleExport")return;let r=o.getPersistedModuleByLocalId(e.localId);if(r&&r.exports.includes(yl))return{exportIdentifier:yl,moduleURL:r.moduleURL,collectionId:e.localIdName}}function Vx(o,t){if(M(t)&&t.dataIdentifier)return vl(o,t.dataIdentifier)}function Ax(o,t,e){for(let r of t.variables){if(!As(r))continue;let n=vl(o,r.dataIdentifier);n&&e(n)}}function Ox(o,t){let e=t.getPrimaryVariant();Qo(e)&&(o.routes[t.id]=e.pageEffects)}function Bx(o,t,e){let r=t.getPrimaryVariant();if(Qo(r)){let n={};for(let i in r.pageEffects)n[i]=e.dedupe("effect",r.pageEffects[i]);o.routes[t.id]=n}}var Om=x("exportToHTML");function bl(o,t,e,r=new Set([e]),n=new Set){for(let{node:i,skipChildren:s}of e.walkWithSkipChildren()){if(n.has(i)){s();continue}n.add(i);for(let a of ca(i,t)){let d=da(a);if(!d)continue;let c=o.getNode(d);if(c){if(!o.isGroundNode(c)){Om.reportError("Navigation target node must be ground node",{sourceId:i.id,targetId:c.id});continue}r.add(c),bl(o,t,c,r,n)}}ut(i)&&Object.values(za(o,i,t)).flat().forEach(a=>bl(o,t,a.node,r,n))}return r}function Gx(o,t,e,r=void 0){if(!e&&!r)return;let n=r??$a(e??[]);n.length&&fd.resetPropertiesToMasterValues(o,t,n)}export{vl as a,Vx as b,Ax as c,Ox as d,Bx as e,cw as f,N as g,xi as h,Bt as i,oo as j,nt as k,Mi as l,Yn as m,Ai as n,Cc as o,Tc as p,po as q,bl as r,Gx as s,Yc as t,Kc as u,Ae as v,xu as w,xv as x,Dv as y,Eu as z,mw as A,wo as B,nl as C,Xm as D,Zm as E,ep as F,di as G,Gn as H,rt as I,Dr as J,ll as K,rs as L,Nx as M,hl as N,FR as O,gl as P,Lo as Q,Pm as R,Mm as S,WR as T,Am as U,Fm as V,pl as W};
//# sourceMappingURL=chunk-IORK7F2P.mjs.map
